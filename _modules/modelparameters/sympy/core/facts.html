
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>modelparameters.sympy.core.facts &#8212; modelparameters 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/nature.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">modelparameters 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modelparameters.sympy.core.facts</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for modelparameters.sympy.core.facts</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;This is rule-based deduction system for SymPy</span>

<span class="sd">The whole thing is split into two parts</span>

<span class="sd"> - rules compilation and preparation of tables</span>
<span class="sd"> - runtime inference</span>

<span class="sd">For rule-based inference engines, the classical work is RETE algorithm [1],</span>
<span class="sd">[2] Although we are not implementing it in full (or even significantly)</span>
<span class="sd">it&#39;s still still worth a read to understand the underlying ideas.</span>

<span class="sd">In short, every rule in a system of rules is one of two forms:</span>

<span class="sd"> - atom                     -&gt; ...      (alpha rule)</span>
<span class="sd"> - And(atom1, atom2, ...)   -&gt; ...      (beta rule)</span>


<span class="sd">The major complexity is in efficient beta-rules processing and usually for an</span>
<span class="sd">expert system a lot of effort goes into code that operates on beta-rules.</span>


<span class="sd">Here we take minimalistic approach to get something usable first.</span>

<span class="sd"> - (preparation)    of alpha- and beta- networks, everything except</span>
<span class="sd"> - (runtime)        FactRules.deduce_all_facts</span>

<span class="sd">             _____________________________________</span>
<span class="sd">            ( Kirr: I&#39;ve never thought that doing )</span>
<span class="sd">            ( logic stuff is that difficult...    )</span>
<span class="sd">             -------------------------------------</span>
<span class="sd">                    o   ^__^</span>
<span class="sd">                     o  (oo)\_______</span>
<span class="sd">                        (__)\       )\/\</span>
<span class="sd">                            ||----w |</span>
<span class="sd">                            ||     ||</span>


<span class="sd">Some references on the topic</span>
<span class="sd">----------------------------</span>

<span class="sd">[1] http://en.wikipedia.org/wiki/Rete_algorithm</span>
<span class="sd">[2] http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf</span>

<span class="sd">http://en.wikipedia.org/wiki/Propositional_formula</span>
<span class="sd">http://en.wikipedia.org/wiki/Inference_rule</span>
<span class="sd">http://en.wikipedia.org/wiki/List_of_rules_of_inference</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">.logic</span> <span class="kn">import</span> <span class="n">Logic</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Not</span>
<span class="kn">from</span> <span class="nn">.compatibility</span> <span class="kn">import</span> <span class="n">string_types</span><span class="p">,</span> <span class="nb">range</span>


<span class="k">def</span> <span class="nf">_base_fact</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the literal fact of an atom.</span>

<span class="sd">    Effectively, this merely strips the Not around a fact.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Not</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">atom</span><span class="o">.</span><span class="n">arg</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">atom</span>


<span class="k">def</span> <span class="nf">_as_pair</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Not</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">arg</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># XXX this prepares forward-chaining rules for alpha-network</span>


<div class="viewcode-block" id="transitive_closure"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.transitive_closure">[docs]</a><span class="k">def</span> <span class="nf">transitive_closure</span><span class="p">(</span><span class="n">implications</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the transitive closure of a list of implications</span>

<span class="sd">    Uses Warshall&#39;s algorithm, as described at</span>
<span class="sd">    http://www.cs.hope.edu/~cusack/Notes/Notes/DiscreteMath/Warshall.pdf.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">full_implications</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">implications</span><span class="p">)</span>
    <span class="n">literals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">full_implications</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">full_implications</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">literals</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">full_implications</span><span class="p">:</span>
                        <span class="n">full_implications</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">full_implications</span></div>


<div class="viewcode-block" id="deduce_alpha_implications"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.deduce_alpha_implications">[docs]</a><span class="k">def</span> <span class="nf">deduce_alpha_implications</span><span class="p">(</span><span class="n">implications</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;deduce all implications</span>

<span class="sd">       Description by example</span>
<span class="sd">       ----------------------</span>

<span class="sd">       given set of logic rules:</span>

<span class="sd">         a -&gt; b</span>
<span class="sd">         b -&gt; c</span>

<span class="sd">       we deduce all possible rules:</span>

<span class="sd">         a -&gt; b, c</span>
<span class="sd">         b -&gt; c</span>


<span class="sd">       implications: [] of (a,b)</span>
<span class="sd">       return:       {} of a -&gt; set([b, c, ...])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">implications</span> <span class="o">=</span> <span class="n">implications</span> <span class="o">+</span> <span class="p">[(</span><span class="n">Not</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">implications</span><span class="p">]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="n">full_implications</span> <span class="o">=</span> <span class="n">transitive_closure</span><span class="p">(</span><span class="n">implications</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">full_implications</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">continue</span>    <span class="c1"># skip a-&gt;a cyclic input</span>

        <span class="n">res</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="c1"># Clean up tautologies and check consistency</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">impl</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">impl</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">na</span> <span class="o">=</span> <span class="n">Not</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">impl</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;implications are inconsistent: </span><span class="si">%s</span><span class="s1"> -&gt; </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">impl</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="apply_beta_to_alpha_route"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.apply_beta_to_alpha_route">[docs]</a><span class="k">def</span> <span class="nf">apply_beta_to_alpha_route</span><span class="p">(</span><span class="n">alpha_implications</span><span class="p">,</span> <span class="n">beta_rules</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;apply additional beta-rules (And conditions) to already-built</span>
<span class="sd">    alpha implication tables</span>

<span class="sd">       TODO: write about</span>

<span class="sd">       - static extension of alpha-chains</span>
<span class="sd">       - attaching refs to beta-nodes to alpha chains</span>


<span class="sd">       e.g.</span>

<span class="sd">       alpha_implications:</span>

<span class="sd">       a  -&gt;  [b, !c, d]</span>
<span class="sd">       b  -&gt;  [d]</span>
<span class="sd">       ...</span>


<span class="sd">       beta_rules:</span>

<span class="sd">       &amp;(b,d) -&gt; e</span>


<span class="sd">       then we&#39;ll extend a&#39;s rule to the following</span>

<span class="sd">       a  -&gt;  [b, !c, d, e]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_impl</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">alpha_implications</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">x_impl</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">alpha_implications</span><span class="p">[</span><span class="n">x</span><span class="p">]),</span> <span class="p">[])</span>
    <span class="k">for</span> <span class="n">bcond</span><span class="p">,</span> <span class="n">bimpl</span> <span class="ow">in</span> <span class="n">beta_rules</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">bk</span> <span class="ow">in</span> <span class="n">bcond</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bk</span> <span class="ow">in</span> <span class="n">x_impl</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">x_impl</span><span class="p">[</span><span class="n">bk</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(),</span> <span class="p">[])</span>

    <span class="c1"># static extensions to alpha rules:</span>
    <span class="c1"># A: x -&gt; a,b   B: &amp;(a,b) -&gt; c  ==&gt;  A: x -&gt; a,b,c</span>
    <span class="n">seen_static_extension</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">seen_static_extension</span><span class="p">:</span>
        <span class="n">seen_static_extension</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">bcond</span><span class="p">,</span> <span class="n">bimpl</span> <span class="ow">in</span> <span class="n">beta_rules</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bcond</span><span class="p">,</span> <span class="n">And</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cond is not And&quot;</span><span class="p">)</span>
            <span class="n">bargs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bcond</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">ximpls</span><span class="p">,</span> <span class="n">bb</span><span class="p">)</span> <span class="ow">in</span> <span class="n">x_impl</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">x_all</span> <span class="o">=</span> <span class="n">ximpls</span> <span class="o">|</span> <span class="p">{</span><span class="n">x</span><span class="p">}</span>
                <span class="c1"># A: ... -&gt; a   B: &amp;(...) -&gt; a  is non-informative</span>
                <span class="k">if</span> <span class="n">bimpl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x_all</span> <span class="ow">and</span> <span class="n">bargs</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">x_all</span><span class="p">):</span>
                    <span class="n">ximpls</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bimpl</span><span class="p">)</span>

                    <span class="c1"># we introduced new implication - now we have to restore</span>
                    <span class="c1"># completeness of the whole set.</span>
                    <span class="n">bimpl_impl</span> <span class="o">=</span> <span class="n">x_impl</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bimpl</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bimpl_impl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ximpls</span> <span class="o">|=</span> <span class="n">bimpl_impl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">seen_static_extension</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># attach beta-nodes which can be possibly triggered by an alpha-chain</span>
    <span class="k">for</span> <span class="n">bidx</span><span class="p">,</span> <span class="p">(</span><span class="n">bcond</span><span class="p">,</span> <span class="n">bimpl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">beta_rules</span><span class="p">):</span>
        <span class="n">bargs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bcond</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">ximpls</span><span class="p">,</span> <span class="n">bb</span><span class="p">)</span> <span class="ow">in</span> <span class="n">x_impl</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">x_all</span> <span class="o">=</span> <span class="n">ximpls</span> <span class="o">|</span> <span class="p">{</span><span class="n">x</span><span class="p">}</span>
            <span class="c1"># A: ... -&gt; a   B: &amp;(...) -&gt; a      (non-informative)</span>
            <span class="k">if</span> <span class="n">bimpl</span> <span class="ow">in</span> <span class="n">x_all</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># A: x -&gt; a...  B: &amp;(!a,...) -&gt; ... (will never trigger)</span>
            <span class="c1"># A: x -&gt; a...  B: &amp;(...) -&gt; !a     (will never trigger)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bargs</span> <span class="ow">or</span> <span class="n">Not</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">==</span> <span class="n">bimpl</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x_all</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">bargs</span> <span class="o">&amp;</span> <span class="n">x_all</span><span class="p">:</span>
                <span class="n">bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bidx</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x_impl</span></div>


<div class="viewcode-block" id="rules_2prereq"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.rules_2prereq">[docs]</a><span class="k">def</span> <span class="nf">rules_2prereq</span><span class="p">(</span><span class="n">rules</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;build prerequisites table from rules</span>

<span class="sd">       Description by example</span>
<span class="sd">       ----------------------</span>

<span class="sd">       given set of logic rules:</span>

<span class="sd">         a -&gt; b, c</span>
<span class="sd">         b -&gt; c</span>

<span class="sd">       we build prerequisites (from what points something can be deduced):</span>

<span class="sd">         b &lt;- a</span>
<span class="sd">         c &lt;- a, b</span>

<span class="sd">       rules:   {} of a -&gt; [b, c, ...]</span>
<span class="sd">       return:  {} of c &lt;- [a, b, ...]</span>

<span class="sd">       Note however, that this prerequisites may be *not* enough to prove a</span>
<span class="sd">       fact. An example is &#39;a -&gt; b&#39; rule, where prereq(a) is b, and prereq(b)</span>
<span class="sd">       is a. That&#39;s because a=T -&gt; b=T, and b=F -&gt; a=F, but a=F -&gt; b=?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prereq</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">impl</span> <span class="ow">in</span> <span class="n">rules</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Not</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">impl</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Not</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">prereq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">prereq</span></div>

<span class="c1">################</span>
<span class="c1"># RULES PROVER #</span>
<span class="c1">################</span>


<div class="viewcode-block" id="TautologyDetected"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.TautologyDetected">[docs]</a><span class="k">class</span> <span class="nc">TautologyDetected</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;(internal) Prover uses it for reporting detected tautology&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="Prover"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.Prover">[docs]</a><span class="k">class</span> <span class="nc">Prover</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;ai - prover of logic rules</span>

<span class="sd">       given a set of initial rules, Prover tries to prove all possible rules</span>
<span class="sd">       which follow from given premises.</span>

<span class="sd">       As a result proved_rules are always either in one of two forms: alpha or</span>
<span class="sd">       beta:</span>

<span class="sd">       Alpha rules</span>
<span class="sd">       -----------</span>

<span class="sd">       This are rules of the form::</span>

<span class="sd">         a -&gt; b &amp; c &amp; d &amp; ...</span>


<span class="sd">       Beta rules</span>
<span class="sd">       ----------</span>

<span class="sd">       This are rules of the form::</span>

<span class="sd">         &amp;(a,b,...) -&gt; c &amp; d &amp; ...</span>


<span class="sd">       i.e. beta rules are join conditions that say that something follows when</span>
<span class="sd">       *several* facts are true at the same time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proved_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rules_seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<div class="viewcode-block" id="Prover.split_alpha_beta"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.Prover.split_alpha_beta">[docs]</a>    <span class="k">def</span> <span class="nf">split_alpha_beta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;split proved rules into alpha and beta chains&quot;&quot;&quot;</span>
        <span class="n">rules_alpha</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># a      -&gt; b</span>
        <span class="n">rules_beta</span> <span class="o">=</span> <span class="p">[]</span>     <span class="c1"># &amp;(...) -&gt; b</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proved_rules</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">And</span><span class="p">):</span>
                <span class="n">rules_beta</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rules_alpha</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rules_alpha</span><span class="p">,</span> <span class="n">rules_beta</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rules_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_alpha_beta</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rules_beta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_alpha_beta</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="Prover.process_rule"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.Prover.process_rule">[docs]</a>    <span class="k">def</span> <span class="nf">process_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;process a -&gt; b rule&quot;&quot;&quot;</span>   <span class="c1"># TODO write more?</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rules_seen</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rules_seen</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

        <span class="c1"># this is the core of processing</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">TautologyDetected</span><span class="p">:</span>
            <span class="k">pass</span></div>

    <span class="k">def</span> <span class="nf">_process_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="c1"># right part first</span>

        <span class="c1"># a -&gt; b &amp; c    --&gt;  a -&gt; b  ;  a -&gt; c</span>
        <span class="c1"># (?) FIXME this is only correct when b &amp; c != null !</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">And</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">barg</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">barg</span><span class="p">)</span>

        <span class="c1"># a -&gt; b | c    --&gt;  !b &amp; !c -&gt; !a</span>
        <span class="c1">#               --&gt;   a &amp; !b -&gt; c</span>
        <span class="c1">#               --&gt;   a &amp; !c -&gt; b</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Or</span><span class="p">):</span>
            <span class="c1"># detect tautology first</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Logic</span><span class="p">):</span>    <span class="c1"># Atom</span>
                <span class="c1"># tautology:  a -&gt; a|c|...</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TautologyDetected</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;a -&gt; a|c|...&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_rule</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Not</span><span class="p">(</span><span class="n">barg</span><span class="p">)</span> <span class="k">for</span> <span class="n">barg</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">]),</span> <span class="n">Not</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">bidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">)):</span>
                <span class="n">barg</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">bidx</span><span class="p">]</span>
                <span class="n">brest</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">[:</span><span class="n">bidx</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">bidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_rule</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">barg</span><span class="p">)),</span> <span class="n">Or</span><span class="p">(</span><span class="o">*</span><span class="n">brest</span><span class="p">))</span>

        <span class="c1"># left part</span>

        <span class="c1"># a &amp; b -&gt; c    --&gt;  IRREDUCIBLE CASE -- WE STORE IT AS IS</span>
        <span class="c1">#                    (this will be the basis of beta-network)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">And</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TautologyDetected</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;a &amp; b -&gt; a&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proved_rules</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
            <span class="c1"># XXX NOTE at present we ignore  !c -&gt; !a | !b</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Or</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TautologyDetected</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;a | b -&gt; a&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">aarg</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_rule</span><span class="p">(</span><span class="n">aarg</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># both `a` and `b` are atoms</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proved_rules</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>             <span class="c1"># a  -&gt; b</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proved_rules</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">Not</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>   <span class="c1"># !b -&gt; !a</span></div>

<span class="c1">########################################</span>


<div class="viewcode-block" id="FactRules"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.FactRules">[docs]</a><span class="k">class</span> <span class="nc">FactRules</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rules that describe how to deduce facts in logic space</span>

<span class="sd">       When defined, these rules allow implications to quickly be determined</span>
<span class="sd">       for a set of facts. For this precomputed deduction tables are used.</span>
<span class="sd">       see `deduce_all_facts`   (forward-chaining)</span>

<span class="sd">       Also it is possible to gather prerequisites for a fact, which is tried</span>
<span class="sd">       to be proven.    (backward-chaining)</span>


<span class="sd">       Definition Syntax</span>
<span class="sd">       -----------------</span>

<span class="sd">       a -&gt; b       -- a=T -&gt; b=T  (and automatically b=F -&gt; a=F)</span>
<span class="sd">       a -&gt; !b      -- a=T -&gt; b=F</span>
<span class="sd">       a == b       -- a -&gt; b &amp; b -&gt; a</span>
<span class="sd">       a -&gt; b &amp; c   -- a=T -&gt; b=T &amp; c=T</span>
<span class="sd">       # TODO b | c</span>


<span class="sd">       Internals</span>
<span class="sd">       ---------</span>

<span class="sd">       .full_implications[k, v]: all the implications of fact k=v</span>
<span class="sd">       .beta_triggers[k, v]: beta rules that might be triggered when k=v</span>
<span class="sd">       .prereq  -- {} k &lt;- [] of k&#39;s prerequisites</span>

<span class="sd">       .defined_facts -- set of defined fact names</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rules</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compile rules into internal lookup tables&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">rules</span> <span class="o">=</span> <span class="n">rules</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>

        <span class="c1"># --- parse and process rules ---</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">Prover</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
            <span class="c1"># XXX `a` is hardcoded to be always atom</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">a</span> <span class="o">=</span> <span class="n">Logic</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">Logic</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;-&gt;&#39;</span><span class="p">:</span>
                <span class="n">P</span><span class="o">.</span><span class="n">process_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;==&#39;</span><span class="p">:</span>
                <span class="n">P</span><span class="o">.</span><span class="n">process_rule</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="n">P</span><span class="o">.</span><span class="n">process_rule</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unknown op </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">op</span><span class="p">)</span>

        <span class="c1"># --- build deduction networks ---</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bcond</span><span class="p">,</span> <span class="n">bimpl</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">rules_beta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">_as_pair</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">bcond</span><span class="o">.</span><span class="n">args</span><span class="p">),</span> <span class="n">_as_pair</span><span class="p">(</span><span class="n">bimpl</span><span class="p">)))</span>

        <span class="c1"># deduce alpha implications</span>
        <span class="n">impl_a</span> <span class="o">=</span> <span class="n">deduce_alpha_implications</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rules_alpha</span><span class="p">)</span>

        <span class="c1"># now:</span>
        <span class="c1"># - apply beta rules to alpha chains  (static extension), and</span>
        <span class="c1"># - further associate beta rules to alpha chain (for inference</span>
        <span class="c1"># at runtime)</span>
        <span class="n">impl_ab</span> <span class="o">=</span> <span class="n">apply_beta_to_alpha_route</span><span class="p">(</span><span class="n">impl_a</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">rules_beta</span><span class="p">)</span>

        <span class="c1"># extract defined fact names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defined_facts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_base_fact</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">impl_ab</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># build rels (forward chains)</span>
        <span class="n">full_implications</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="n">beta_triggers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="n">betaidxs</span><span class="p">)</span> <span class="ow">in</span> <span class="n">impl_ab</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">full_implications</span><span class="p">[</span><span class="n">_as_pair</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_as_pair</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">impl</span><span class="p">)</span>
            <span class="n">beta_triggers</span><span class="p">[</span><span class="n">_as_pair</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">betaidxs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">full_implications</span> <span class="o">=</span> <span class="n">full_implications</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_triggers</span> <span class="o">=</span> <span class="n">beta_triggers</span>

        <span class="c1"># build prereq (backward chains)</span>
        <span class="n">prereq</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="n">rel_prereq</span> <span class="o">=</span> <span class="n">rules_2prereq</span><span class="p">(</span><span class="n">full_implications</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">pitems</span> <span class="ow">in</span> <span class="n">rel_prereq</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">prereq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">|=</span> <span class="n">pitems</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prereq</span> <span class="o">=</span> <span class="n">prereq</span></div>


<div class="viewcode-block" id="InconsistentAssumptions"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.InconsistentAssumptions">[docs]</a><span class="k">class</span> <span class="nc">InconsistentAssumptions</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kb</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">kb</span><span class="p">,</span> <span class="n">fact</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="FactKB"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.FactKB">[docs]</a><span class="k">class</span> <span class="nc">FactKB</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple propositional knowledge base relying on compiled inference rules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;{</span><span class="se">\n</span><span class="si">%s</span><span class="s1">}&#39;</span> <span class="o">%</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rules</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rules</span> <span class="o">=</span> <span class="n">rules</span>

    <span class="k">def</span> <span class="nf">_tell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add fact k=v to the knowledge base.</span>

<span class="sd">        Returns True if the KB has actually been updated, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InconsistentAssumptions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># *********************************************</span>
    <span class="c1"># * This is the workhorse, so keep it *fast*. *</span>
    <span class="c1"># *********************************************</span>
<div class="viewcode-block" id="FactKB.deduce_all_facts"><a class="viewcode-back" href="../../../../modelparameters.sympy.core.html#modelparameters.sympy.core.assumptions.FactKB.deduce_all_facts">[docs]</a>    <span class="k">def</span> <span class="nf">deduce_all_facts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the KB with all the implications of a list of facts.</span>

<span class="sd">        Facts can be specified as a dictionary or as a list of (key, value)</span>
<span class="sd">        pairs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># keep frequently used attributes locally, so we&#39;ll avoid extra</span>
        <span class="c1"># attribute access overhead</span>
        <span class="n">full_implications</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">full_implications</span>
        <span class="n">beta_triggers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">beta_triggers</span>
        <span class="n">beta_rules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">beta_rules</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">facts</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">facts</span> <span class="o">=</span> <span class="n">facts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

        <span class="k">while</span> <span class="n">facts</span><span class="p">:</span>
            <span class="n">beta_maytrigger</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="c1"># --- alpha chains ---</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">facts</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tell</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># lookup routing tables</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">full_implications</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tell</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

                <span class="n">beta_maytrigger</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">beta_triggers</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">])</span>

            <span class="c1"># --- beta chains ---</span>
            <span class="n">facts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">bidx</span> <span class="ow">in</span> <span class="n">beta_maytrigger</span><span class="p">:</span>
                <span class="n">bcond</span><span class="p">,</span> <span class="n">bimpl</span> <span class="o">=</span> <span class="n">beta_rules</span><span class="p">[</span><span class="n">bidx</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bcond</span><span class="p">):</span>
                    <span class="n">facts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bimpl</span><span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">modelparameters 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modelparameters.sympy.core.facts</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Johan Hake, Henrik Finsberg.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>