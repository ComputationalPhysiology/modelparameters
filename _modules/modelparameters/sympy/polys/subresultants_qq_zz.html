
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>modelparameters.sympy.polys.subresultants_qq_zz &#8212; modelparameters 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/nature.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">modelparameters 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modelparameters.sympy.polys.subresultants_qq_zz</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for modelparameters.sympy.polys.subresultants_qq_zz</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains functions for the computation</span>
<span class="sd">of Euclidean, generalized Sturmian and (modified) subresultant</span>
<span class="sd">polynomial remainder sequences (prs&#39;s).</span>

<span class="sd">The pseudo-remainder function prem() of sympy is _not_ used</span>
<span class="sd">by any of the functions in the module.</span>

<span class="sd">Instead of prem() we use the function</span>

<span class="sd">rem_z().</span>

<span class="sd">Included is also the function quo_z().</span>

<span class="sd">1. Theoretical background:</span>
<span class="sd">==========================</span>
<span class="sd">Consider the polynomials f, g ∈ Z[x] of degrees deg(f) = n and</span>
<span class="sd">deg(g) = m with n ≥ m.</span>

<span class="sd">Definition 1:</span>
<span class="sd">=============</span>
<span class="sd">The sign sequence of a polynomial remainder sequence (prs) is the</span>
<span class="sd">sequence of signs of the leading coefficients of its polynomials.</span>

<span class="sd">Sign sequences can be computed with the function:</span>

<span class="sd">sign_seq(poly_seq, x)</span>

<span class="sd">Definition 2:</span>
<span class="sd">=============</span>
<span class="sd">A polynomial remainder sequence (prs) is called complete if the</span>
<span class="sd">degree difference between any two consecutive polynomials is 1;</span>
<span class="sd">otherwise, it called incomplete.</span>

<span class="sd">It is understood that f, g belong to the sequences mentioned in</span>
<span class="sd">the two definitions.</span>

<span class="sd">1A. Euclidean and subresultant prs&#39;s:</span>
<span class="sd">=====================================</span>
<span class="sd">The subresultant prs of f, g is a sequence of polynomials in Z[x]</span>
<span class="sd">analogous to the Euclidean prs, the sequence obtained by applying</span>
<span class="sd">on f, g Euclid’s algorithm for polynomial greatest common divisors</span>
<span class="sd">(gcd) in Q[x].</span>

<span class="sd">The subresultant prs differs from the Euclidean prs in that the</span>
<span class="sd">coefficients of each polynomial in the former sequence are determinants</span>
<span class="sd">--- also referred to as subresultants --- of appropriately selected</span>
<span class="sd">sub-matrices of sylvester1(f, g, x), Sylvester’s matrix of 1840 of</span>
<span class="sd">dimensions (n + m) × (n + m).</span>

<span class="sd">Recall that the determinant of sylvester1(f, g, x) itself is</span>
<span class="sd">called the resultant of f, g and serves as a criterion of whether</span>
<span class="sd">the two polynomials have common roots or not.</span>

<span class="sd">In sympy the resultant is computed with the function</span>
<span class="sd">resultant(f, g, x). This function does _not_ evaluate the</span>
<span class="sd">determinant of sylvester(f, g, x, 1); instead, it returns</span>
<span class="sd">the last member of the subresultant prs of f, g, multiplied</span>
<span class="sd">(if needed) by an appropriate power of -1; see the caveat below.</span>

<span class="sd">Caveat: If Df = degree(f, x) and Dg = degree(g, x), then:</span>

<span class="sd">resultant(f, g, x) = (-1)**(Df*Dg) * resultant(g, f, x).</span>

<span class="sd">For complete prs’s the sign sequence of the Euclidean prs of f, g</span>
<span class="sd">is identical to the sign sequence of the subresultant prs of f, g</span>
<span class="sd">and the coefficients of one sequence  are easily computed from the</span>
<span class="sd">coefficients of the  other.</span>

<span class="sd">For incomplete prs’s the polynomials in the subresultant prs, generally</span>
<span class="sd">differ in sign from those of the Euclidean prs, and --- unlike the</span>
<span class="sd">case of complete prs’s --- it is not at all obvious how to compute</span>
<span class="sd">the coefficients of one sequence from the coefficients of the  other.</span>

<span class="sd">1B. Sturmian and modified subresultant prs&#39;s:</span>
<span class="sd">=============================================</span>
<span class="sd">For the same polynomials f, g ∈ Z[x] mentioned above, their ``modified&#39;&#39;</span>
<span class="sd">subresultant prs is a sequence of polynomials similar to the Sturmian</span>
<span class="sd">prs, the sequence obtained by applying in Q[x] Sturm’s algorithm on f, g.</span>

<span class="sd">The two sequences differ in that the coefficients of each polynomial</span>
<span class="sd">in the modified subresultant prs are the determinants --- also referred</span>
<span class="sd">to as modified subresultants --- of appropriately selected  sub-matrices</span>
<span class="sd">of sylvester2(f, g, x), Sylvester’s matrix of 1853 of dimensions 2n × 2n.</span>

<span class="sd">The determinant of sylvester2 itself is called the modified resultant</span>
<span class="sd">of f, g and it also can serve as a criterion of whether the two</span>
<span class="sd">polynomials have common roots or not.</span>

<span class="sd">For complete prs’s the  sign sequence of the Sturmian prs of f, g is</span>
<span class="sd">identical to the sign sequence of the modified subresultant prs of</span>
<span class="sd">f, g and the coefficients of one sequence  are easily computed from</span>
<span class="sd">the coefficients of the other.</span>

<span class="sd">For incomplete prs’s the polynomials in the modified subresultant prs,</span>
<span class="sd">generally differ in sign from those of the Sturmian prs, and --- unlike</span>
<span class="sd">the case of complete prs’s --- it is not at all obvious how to compute</span>
<span class="sd">the coefficients of one sequence from the coefficients of the  other.</span>

<span class="sd">As Sylvester pointed out, the coefficients of the polynomial remainders</span>
<span class="sd">obtained as (modified) subresultants are the smallest possible without</span>
<span class="sd">introducing rationals and without computing (integer) greatest common</span>
<span class="sd">divisors.</span>

<span class="sd">1C. On terminology:</span>
<span class="sd">===================</span>
<span class="sd">Whence the terminology? Well generalized Sturmian prs&#39;s are</span>
<span class="sd">``modifications&#39;&#39; of Euclidean prs&#39;s; the hint came from the title</span>
<span class="sd">of the Pell-Gordon paper of 1917.</span>

<span class="sd">In the literature one also encounters the name ``non signed&#39;&#39; and</span>
<span class="sd">``signed&#39;&#39; prs for Euclidean and Sturmian prs respectively.</span>

<span class="sd">Likewise ``non signed&#39;&#39; and ``signed&#39;&#39; subresultant prs for</span>
<span class="sd">subresultant and modified subresultant prs respectively.</span>

<span class="sd">2. Functions in the module:</span>
<span class="sd">===========================</span>
<span class="sd">No function utilizes sympy&#39;s function prem().</span>

<span class="sd">2A. Matrices:</span>
<span class="sd">=============</span>
<span class="sd">The functions sylvester(f, g, x, method=1) and</span>
<span class="sd">sylvester(f, g, x, method=2) compute either Sylvester matrix.</span>
<span class="sd">They can be used to compute (modified) subresultant prs&#39;s by</span>
<span class="sd">direct determinant evaluation.</span>

<span class="sd">The function bezout(f, g, x, method=&#39;prs&#39;) provides a matrix of</span>
<span class="sd">smaller dimensions than either Sylvester matrix. It is the function</span>
<span class="sd">of choice for computing (modified) subresultant prs&#39;s by direct</span>
<span class="sd">determinant evaluation.</span>

<span class="sd">sylvester(f, g, x, method=1)</span>
<span class="sd">sylvester(f, g, x, method=2)</span>
<span class="sd">bezout(f, g, x, method=&#39;prs&#39;)</span>

<span class="sd">The following identity holds:</span>

<span class="sd">bezout(f, g, x, method=&#39;prs&#39;) =</span>
<span class="sd">backward_eye(deg(f))*bezout(f, g, x, method=&#39;bz&#39;)*backward_eye(deg(f))</span>

<span class="sd">2B. Subresultant and modified subresultant prs&#39;s by</span>
<span class="sd">===================================================</span>
<span class="sd">determinant evaluation:</span>
<span class="sd">=======================</span>
<span class="sd">Instead of utilizing the Sylvester matrices, we employ</span>
<span class="sd">the Bezout matrix of smaller dimensions.</span>

<span class="sd">subresultants_bezout(f, g, x)</span>
<span class="sd">modified_subresultants_bezout(f, g, x)</span>

<span class="sd">2C. Subresultant prs&#39;s by ONE determinant evaluation:</span>
<span class="sd">=====================================================</span>
<span class="sd">All three functions in this section evaluate one determinant</span>
<span class="sd">per remainder polynomial; this is the determinant of an</span>
<span class="sd">appropriately selected sub-matrix of sylvester1(f, g, x),</span>
<span class="sd">Sylvester’s matrix of 1840.</span>

<span class="sd">To compute the remainder polynomials the function</span>
<span class="sd">subresultants_rem(f, g, x) employs rem(f, g, x).</span>
<span class="sd">By contrast, the other two functions implement Van Vleck’s ideas</span>
<span class="sd">of 1900 and compute the remainder polynomials by trinagularizing</span>
<span class="sd">sylvester2(f, g, x), Sylvester’s matrix of 1853.</span>


<span class="sd">subresultants_rem(f, g, x)</span>
<span class="sd">subresultants_vv(f, g, x)</span>
<span class="sd">subresultants_vv_2(f, g, x).</span>

<span class="sd">2E. Euclidean, Sturmian prs&#39;s in Q[x]:</span>
<span class="sd">======================================</span>
<span class="sd">euclid_q(f, g, x)</span>
<span class="sd">sturm_q(f, g, x)</span>

<span class="sd">2F. Euclidean, Sturmian and (modified) subresultant prs&#39;s P-G:</span>
<span class="sd">==============================================================</span>
<span class="sd">All functions in this section are based on the Pell-Gordon (P-G)</span>
<span class="sd">theorem of 1917.</span>
<span class="sd">Computations are done in Q[x], employing the function rem(f, g, x)</span>
<span class="sd">for the computation of the remainder polynomials.</span>

<span class="sd">euclid_pg(f, g, x)</span>
<span class="sd">sturm pg(f, g, x)</span>
<span class="sd">subresultants_pg(f, g, x)</span>
<span class="sd">modified_subresultants_pg(f, g, x)</span>

<span class="sd">2G. Euclidean, Sturmian and (modified) subresultant prs&#39;s A-M-V:</span>
<span class="sd">================================================================</span>
<span class="sd">All functions in this section are based on the Akritas-Malaschonok-</span>
<span class="sd">Vigklas (A-M-V) theorem of 2015.</span>
<span class="sd">Computations are done in Z[x], employing the function rem_z(f, g, x)</span>
<span class="sd">for the computation of the remainder polynomials.</span>

<span class="sd">euclid_amv(f, g, x)</span>
<span class="sd">sturm_amv(f, g, x)</span>
<span class="sd">subresultants_amv(f, g, x)</span>
<span class="sd">modified_subresultants_amv(f, g, x)</span>

<span class="sd">2Ga. Exception:</span>
<span class="sd">===============</span>
<span class="sd">subresultants_amv_q(f, g, x)</span>

<span class="sd">This function employs rem(f, g, x) for the computation of</span>
<span class="sd">the remainder polynomials, despite the fact that it implements</span>
<span class="sd">the A-M-V Theorem.</span>

<span class="sd">It is included in our module in order to show that theorems P-G</span>
<span class="sd">and A-M-V can be implemented utilizing either the function</span>
<span class="sd">rem(f, g, x) or the function rem_z(f, g, x).</span>

<span class="sd">For clearly historical reasons --- since the Collins-Brown-Traub</span>
<span class="sd">coefficients-reduction factor β_i was not available in 1917 ---</span>
<span class="sd">we have implemented the Pell-Gordon theorem with the function</span>
<span class="sd">rem(f, g, x) and the A-M-V Theorem  with the function rem_z(f, g, x).</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Abs</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">expand</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">LC</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">nan</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">pprint</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">quo</span><span class="p">,</span> <span class="n">rem</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">simplify</span><span class="p">,</span> <span class="n">summation</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">zeros</span><span class="p">)</span>

<div class="viewcode-block" id="sylvester"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.sylvester">[docs]</a><span class="k">def</span> <span class="nf">sylvester</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">      The input polynomials f, g are in Z[x] or in Q[x].</span>
<span class="sd">      Let mx = max( degree(f, x) , degree(g, x) ).</span>

<span class="sd">      a. If method = 1 (default), computes sylvester1, Sylvester&#39;s matrix of 1840</span>
<span class="sd">          of dimension (m + n) x (m + n). The determinants of properly chosen</span>
<span class="sd">          submatrices of this matrix (a.k.a. subresultants) can be</span>
<span class="sd">          used to compute the coefficients of the Euclidean PRS of f, g.</span>

<span class="sd">      b. If method = 2, computes sylvester2, Sylvester&#39;s matrix of 1853</span>
<span class="sd">          of dimension (2*mx) x (2*mx). The determinants of properly chosen</span>
<span class="sd">          submatrices of this matrix (a.k.a. ``modified&#39;&#39; subresultants) can be</span>
<span class="sd">          used to compute the coefficients of the Sturmian PRS of f, g.</span>

<span class="sd">      Applications of these Matrices can be found in the references below.</span>
<span class="sd">      Especially, for applications of sylvester2, see the first reference!!</span>

<span class="sd">      References:</span>
<span class="sd">      ===========</span>
<span class="sd">      1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem</span>
<span class="sd">      by Van Vleck Regarding Sturm Sequences. Serdica Journal of Computing,</span>
<span class="sd">      Vol. 7, No 4, 101–134, 2013.</span>

<span class="sd">      2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences</span>
<span class="sd">      and Modified Subresultant Polynomial Remainder Sequences.&#39;&#39;</span>
<span class="sd">      Serdica Journal of Computing, Vol. 8, No 1, 29–46, 2014.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># obtain degrees of polys</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span> <span class="n">Poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">degree</span><span class="p">(</span> <span class="n">Poly</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Special cases:</span>
    <span class="c1"># A:: case m = n &lt; 0 (i.e. both polys are 0)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([])</span>

    <span class="c1"># B:: case m = n = 0  (i.e. both polys are constants)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([])</span>

    <span class="c1"># C:: m == 0 and n &lt; 0 or m &lt; 0 and n == 0</span>
    <span class="c1"># (i.e. one poly is constant and the other is 0)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([])</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([])</span>

    <span class="c1"># D:: m &gt;= 1 and n &lt; 0 or m &lt; 0 and n &gt;=1</span>
    <span class="c1"># (i.e. one poly is of degree &gt;=1 and the other is 0)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()</span>

    <span class="c1"># Sylvester&#39;s matrix of 1840 (default; a.k.a. sylvester1)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">gp</span><span class="p">:</span>
                <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">M</span>

    <span class="c1"># Sylvester&#39;s matrix of 1853 (a.k.a sylvester2)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">gp</span><span class="p">):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">fp</span><span class="p">)):</span>
                <span class="n">h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">fp</span><span class="p">[</span> <span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">gp</span><span class="p">)):</span>
                <span class="n">h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">gp</span><span class="p">[</span> <span class="p">:</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">mx</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span> <span class="n">dim</span> <span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">mx</span> <span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">gp</span><span class="p">:</span>
                <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">M</span></div>

<div class="viewcode-block" id="sign_seq"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.sign_seq">[docs]</a><span class="k">def</span> <span class="nf">sign_seq</span><span class="p">(</span><span class="n">poly_seq</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a sequence of polynomials poly_seq, it returns</span>
<span class="sd">    the sequence of signs of the leading coefficients of</span>
<span class="sd">    the polynomials in poly_seq.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">sign</span><span class="p">(</span><span class="n">LC</span><span class="p">(</span><span class="n">poly_seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">poly_seq</span><span class="p">))]</span></div>

<div class="viewcode-block" id="bezout"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.bezout">[docs]</a><span class="k">def</span> <span class="nf">bezout</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bz&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The input polynomials p, q are in Z[x] or in Q[x]. Let</span>
<span class="sd">    mx = max( degree(p, x) , degree(q, x) ).</span>

<span class="sd">    The default option bezout(p, q, x, method=&#39;bz&#39;) returns Bezout&#39;s</span>
<span class="sd">    symmetric matrix of p and q, of dimensions (mx) x (mx). The</span>
<span class="sd">    determinant of this matrix is equal to the determinant of sylvester2,</span>
<span class="sd">    Sylvester&#39;s matrix of 1853, whose dimensions are (2*mx) x (2*mx);</span>
<span class="sd">    however the subresultants of these two matrices may differ.</span>

<span class="sd">    The other option, bezout(p, q, x, &#39;prs&#39;), is of interest to us</span>
<span class="sd">    in this module because it returns a matrix equivalent to sylvester2.</span>
<span class="sd">    In this case all subresultants of the two matrices are identical.</span>

<span class="sd">    Both the subresultant polynomial remainder sequence (prs) and</span>
<span class="sd">    the modified subresultant prs of p and q can be computed by</span>
<span class="sd">    evaluating determinants of appropriately selected submatrices of</span>
<span class="sd">    bezout(p, q, x, &#39;prs&#39;) --- one determinant per coefficient of the</span>
<span class="sd">    remainder polynomials.</span>

<span class="sd">    The matrices bezout(p, q, x, &#39;bz&#39;) and bezout(p, q, x, &#39;prs&#39;)</span>
<span class="sd">    are related by the formula</span>

<span class="sd">    bezout(p, q, x, &#39;prs&#39;) =</span>
<span class="sd">    backward_eye(deg(p)) * bezout(p, q, x, &#39;bz&#39;) * backward_eye(deg(p)),</span>

<span class="sd">    where backward_eye() is the backward identity function.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants</span>
<span class="sd">    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,</span>
<span class="sd">    Vol. 15, 233–266, 2004.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># obtain degrees of polys</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span> <span class="n">Poly</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">degree</span><span class="p">(</span> <span class="n">Poly</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Special cases:</span>
    <span class="c1"># A:: case m = n &lt; 0 (i.e. both polys are 0)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([])</span>

    <span class="c1"># B:: case m = n = 0  (i.e. both polys are constants)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([])</span>

    <span class="c1"># C:: m == 0 and n &lt; 0 or m &lt; 0 and n == 0</span>
    <span class="c1"># (i.e. one poly is constant and the other is 0)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([])</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([])</span>

    <span class="c1"># D:: m &gt;= 1 and n &lt; 0 or m &lt; 0 and n &gt;=1</span>
    <span class="c1"># (i.e. one poly is of degree &gt;=1 and the other is 0)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>

    <span class="c1"># expr is 0 when x = y</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">})</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span><span class="n">y</span><span class="p">})</span> <span class="o">*</span> <span class="n">q</span>

    <span class="c1"># hence expr is exactly divisible by x - y</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span> <span class="n">quo</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># form Bezout matrix and store them in B as indicated to get</span>
    <span class="c1"># the LC coefficient of each poly either in the first position</span>
    <span class="c1"># of each row (method=&#39;prs&#39;) or in the last (method=&#39;bz&#39;).</span>
    <span class="n">mx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mx</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;prs&#39;</span><span class="p">:</span>
                <span class="n">B</span><span class="p">[</span><span class="n">mx</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">mx</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">nth</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">nth</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">B</span></div>

<div class="viewcode-block" id="backward_eye"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.backward_eye">[docs]</a><span class="k">def</span> <span class="nf">backward_eye</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the backward identity matrix of dimensions n x n.</span>

<span class="sd">    Needed to &quot;turn&quot; the Bezout matrices</span>
<span class="sd">    so that the leading coefficients are first.</span>
<span class="sd">    See docstring of the function bezout(p, q, x, method=&#39;bz&#39;).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># identity matrix of order n</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)):</span>
        <span class="n">M</span><span class="o">.</span><span class="n">row_swap</span><span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">M</span></div>

<div class="viewcode-block" id="process_bezout_output"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.process_bezout_output">[docs]</a><span class="k">def</span> <span class="nf">process_bezout_output</span><span class="p">(</span><span class="n">poly_seq</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    poly_seq is a polynomial remainder sequence computed either by</span>
<span class="sd">    subresultants_bezout or by modified_subresultants_bezout.</span>

<span class="sd">    This function removes from poly_seq all zero polynomials as well</span>
<span class="sd">    as all those whose degree is equal to the degree of a previous</span>
<span class="sd">    polynomial in poly_seq, as we scan it from left to right.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">poly_seq</span><span class="p">[:]</span>  <span class="c1"># get a copy of the input sequence</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
        <span class="n">d_i</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d_i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>          <span class="c1"># zero poly</span>
            <span class="n">L</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">d_i</span><span class="p">:</span>         <span class="c1"># poly degree equals degree of previous poly</span>
            <span class="n">L</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">d_i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d_i</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">L</span></div>

<div class="viewcode-block" id="subresultants_bezout"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.subresultants_bezout">[docs]</a><span class="k">def</span> <span class="nf">subresultants_bezout</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the subresultant polynomial remainder sequence</span>
<span class="sd">    of p, q by evaluating determinants of appropriately selected</span>
<span class="sd">    submatrices of bezout(p, q, x, &#39;prs&#39;). The dimensions of the</span>
<span class="sd">    latter are deg(p) x deg(p).</span>

<span class="sd">    Each coefficient is computed by evaluating the determinant of the</span>
<span class="sd">    corresponding submatrix of bezout(p, q, x, &#39;prs&#39;).</span>

<span class="sd">    bezout(p, q, x, &#39;prs) is used instead of sylvester(p, q, x, 1),</span>
<span class="sd">    Sylvester&#39;s matrix of 1840, because the dimensions of the latter</span>
<span class="sd">    are (deg(p) + deg(q)) x (deg(p) + deg(q)).</span>

<span class="sd">    If the subresultant prs is complete, then the output coincides</span>
<span class="sd">    with the Euclidean sequence of the polynomials p, q.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants</span>
<span class="sd">    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,</span>
<span class="sd">    Vol. 15, 233–266, 2004.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither p nor q is 0</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">degF</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">degG</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">degF</span><span class="p">,</span> <span class="n">degG</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">degG</span><span class="p">,</span> <span class="n">degF</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>

    <span class="n">SR_L</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>      <span class="c1"># subresultant list</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">LC</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">degF</span> <span class="o">-</span> <span class="n">degG</span><span class="p">)</span>

    <span class="c1"># form the bezout matrix</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">bezout</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;prs&#39;</span><span class="p">)</span>

    <span class="c1"># pick appropriate submatrices of B</span>
    <span class="c1"># and form subresultant polys</span>
    <span class="k">if</span> <span class="n">degF</span> <span class="o">&gt;</span> <span class="n">degG</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">degF</span> <span class="o">==</span> <span class="n">degG</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">degF</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">coeff_L</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">degF</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coeff_L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">[:</span> <span class="p">,</span><span class="mi">0</span> <span class="p">:</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">det</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">degF</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">M</span><span class="o">.</span><span class="n">col_swap</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># apply Theorem 2.1 in the paper by Toca &amp; Vega 2004</span>
        <span class="c1"># to get correct signs</span>
        <span class="n">SR_L</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">int</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">Poly</span><span class="p">(</span><span class="n">coeff_L</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">as_expr</span><span class="p">())</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">process_bezout_output</span><span class="p">(</span><span class="n">SR_L</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="modified_subresultants_bezout"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.modified_subresultants_bezout">[docs]</a><span class="k">def</span> <span class="nf">modified_subresultants_bezout</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the modified subresultant polynomial remainder sequence</span>
<span class="sd">    of p, q by evaluating determinants of appropriately selected</span>
<span class="sd">    submatrices of bezout(p, q, x, &#39;prs&#39;). The dimensions of the</span>
<span class="sd">    latter are deg(p) x deg(p).</span>

<span class="sd">    Each coefficient is computed by evaluating the determinant of the</span>
<span class="sd">    corresponding submatrix of bezout(p, q, x, &#39;prs&#39;).</span>

<span class="sd">    bezout(p, q, x, &#39;prs&#39;) is used instead of sylvester(p, q, x, 2),</span>
<span class="sd">    Sylvester&#39;s matrix of 1853, because the dimensions of the latter</span>
<span class="sd">    are 2*deg(p) x 2*deg(p).</span>

<span class="sd">    If the modified subresultant prs is complete, and LC( p ) &gt; 0, the output</span>
<span class="sd">    coincides with the (generalized) Sturm&#39;s sequence of the polynomials p, q.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences</span>
<span class="sd">    and Modified Subresultant Polynomial Remainder Sequences.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, Vol. 8, No 1, 29–46, 2014.</span>

<span class="sd">    2. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants</span>
<span class="sd">    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,</span>
<span class="sd">    Vol. 15, 233–266, 2004.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither p nor q is 0</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">degF</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">degG</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">degF</span><span class="p">,</span> <span class="n">degG</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">degG</span><span class="p">,</span> <span class="n">degF</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>

    <span class="n">SR_L</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>      <span class="c1"># subresultant list</span>

    <span class="c1"># form the bezout matrix</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">bezout</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;prs&#39;</span><span class="p">)</span>

    <span class="c1"># pick appropriate submatrices of B</span>
    <span class="c1"># and form subresultant polys</span>
    <span class="k">if</span> <span class="n">degF</span> <span class="o">&gt;</span> <span class="n">degG</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">degF</span> <span class="o">==</span> <span class="n">degG</span><span class="p">:</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">degF</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">coeff_L</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">degF</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coeff_L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">[:</span> <span class="p">,</span><span class="mi">0</span> <span class="p">:</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">det</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">degF</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">M</span><span class="o">.</span><span class="n">col_swap</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1">## Theorem 2.1 in the paper by Toca &amp; Vega 2004 is _not needed_</span>
        <span class="c1">## in this case since</span>
        <span class="c1">## the bezout matrix is equivalent to sylvester2</span>
        <span class="n">SR_L</span><span class="o">.</span><span class="n">append</span><span class="p">((</span> <span class="n">Poly</span><span class="p">(</span><span class="n">coeff_L</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">as_expr</span><span class="p">())</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">process_bezout_output</span><span class="p">(</span><span class="n">SR_L</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="sturm_pg"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.sturm_pg">[docs]</a><span class="k">def</span> <span class="nf">sturm_pg</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].</span>
<span class="sd">    If q = diff(p, x, 1) it is the usual Sturm sequence.</span>

<span class="sd">    A. If method == 0, default, the remainder coefficients of the sequence</span>
<span class="sd">       are (in absolute value) ``modified&#39;&#39; subresultants, which for non-monic</span>
<span class="sd">       polynomials are greater than the coefficients of the corresponding</span>
<span class="sd">       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).</span>

<span class="sd">    B. If method == 1, the remainder coefficients of the sequence are (in</span>
<span class="sd">       absolute value) subresultants, which for non-monic polynomials are</span>
<span class="sd">       smaller than the coefficients of the corresponding ``modified&#39;&#39;</span>
<span class="sd">       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).</span>

<span class="sd">    If the Sturm sequence is complete, method=0 and LC( p ) &gt; 0, the coefficients</span>
<span class="sd">    of the polynomials in the sequence are ``modified&#39;&#39; subresultants.</span>
<span class="sd">    That is, they are  determinants of appropriately selected submatrices of</span>
<span class="sd">    sylvester2, Sylvester&#39;s matrix of 1853. In this case the Sturm sequence</span>
<span class="sd">    coincides with the ``modified&#39;&#39; subresultant prs, of the polynomials</span>
<span class="sd">    p, q.</span>

<span class="sd">    If the Sturm sequence is incomplete and method=0 then the signs of the</span>
<span class="sd">    coefficients of the polynomials in the sequence may differ from the signs</span>
<span class="sd">    of the coefficients of the corresponding polynomials in the ``modified&#39;&#39;</span>
<span class="sd">    subresultant prs; however, the absolute values are the same.</span>

<span class="sd">    To compute the coefficients, no determinant evaluation takes place. Instead,</span>
<span class="sd">    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);</span>
<span class="sd">    the coefficients of the remainders computed this way become (``modified&#39;&#39;)</span>
<span class="sd">    subresultants with the help of the Pell-Gordon Theorem of 1917.</span>
<span class="sd">    See also the function euclid_pg(p, q, x).</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding</span>
<span class="sd">    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,</span>
<span class="sd">    Second Series, 18 (1917), No. 4, 188–193.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences</span>
<span class="sd">    and Modified Subresultant Polynomial Remainder Sequences.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, Vol. 8, No 1, 29–46, 2014.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither p nor q is 0</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="n">d0</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">d1</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d0</span><span class="p">:</span>
        <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d0</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure LC(p) &gt; 0</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span>  <span class="n">LC</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span>
        <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="n">q</span>

    <span class="c1"># initialize</span>
    <span class="n">lcf</span> <span class="o">=</span> <span class="n">LC</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">d0</span> <span class="o">-</span> <span class="n">d1</span><span class="p">)</span>               <span class="c1"># lcf * subr = modified subr</span>
    <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>                           <span class="c1"># the input polys</span>
    <span class="n">sturm_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">]</span>                    <span class="c1"># the output list</span>
    <span class="n">del0</span> <span class="o">=</span> <span class="n">d0</span> <span class="o">-</span> <span class="n">d1</span>                          <span class="c1"># degree difference</span>
    <span class="n">rho1</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                       <span class="c1"># leading coeff of a1</span>
    <span class="n">exp_deg</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="mi">1</span>                        <span class="c1"># expected degree of a2</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">rem</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>           <span class="c1"># first remainder</span>
    <span class="n">rho2</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>                        <span class="c1"># leading coeff of a2</span>
    <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                     <span class="c1"># actual degree of a2</span>
    <span class="n">deg_diff_new</span> <span class="o">=</span> <span class="n">exp_deg</span> <span class="o">-</span> <span class="n">d2</span>             <span class="c1"># expected - actual degree</span>
    <span class="n">del1</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span>                          <span class="c1"># degree difference</span>

    <span class="c1"># mul_fac is the factor by which a2 is multiplied to</span>
    <span class="c1"># get integer coefficients</span>
    <span class="n">mul_fac_old</span> <span class="o">=</span> <span class="n">rho1</span><span class="o">**</span><span class="p">(</span><span class="n">del0</span> <span class="o">+</span> <span class="n">del1</span> <span class="o">-</span> <span class="n">deg_diff_new</span><span class="p">)</span>

    <span class="c1"># append accordingly</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sturm_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">simplify</span><span class="p">(</span><span class="n">lcf</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">*</span>  <span class="n">Abs</span><span class="p">(</span><span class="n">mul_fac_old</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sturm_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">simplify</span><span class="p">(</span> <span class="n">a2</span> <span class="o">*</span>  <span class="n">Abs</span><span class="p">(</span><span class="n">mul_fac_old</span><span class="p">)))</span>

    <span class="c1"># main loop</span>
    <span class="n">deg_diff_old</span> <span class="o">=</span> <span class="n">deg_diff_new</span>
    <span class="k">while</span> <span class="n">d2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span>      <span class="c1"># update polys and degrees</span>
        <span class="n">del0</span> <span class="o">=</span> <span class="n">del1</span>                          <span class="c1"># update degree difference</span>
        <span class="n">exp_deg</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="mi">1</span>                     <span class="c1"># new expected degree</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">rem</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>        <span class="c1"># new remainder</span>
        <span class="n">rho3</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                    <span class="c1"># leading coeff of a2</span>
        <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                  <span class="c1"># actual degree of a2</span>
        <span class="n">deg_diff_new</span> <span class="o">=</span> <span class="n">exp_deg</span> <span class="o">-</span> <span class="n">d2</span>          <span class="c1"># expected - actual degree</span>
        <span class="n">del1</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span>                       <span class="c1"># degree difference</span>

        <span class="c1"># take into consideration the power</span>
        <span class="c1"># rho1**deg_diff_old that was &quot;left out&quot;</span>
        <span class="n">expo_old</span> <span class="o">=</span> <span class="n">deg_diff_old</span>               <span class="c1"># rho1 raised to this power</span>
        <span class="n">expo_new</span> <span class="o">=</span> <span class="n">del0</span> <span class="o">+</span> <span class="n">del1</span> <span class="o">-</span> <span class="n">deg_diff_new</span> <span class="c1"># rho2 raised to this power</span>

        <span class="c1"># update variables and append</span>
        <span class="n">mul_fac_new</span> <span class="o">=</span> <span class="n">rho2</span><span class="o">**</span><span class="p">(</span><span class="n">expo_new</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho1</span><span class="o">**</span><span class="p">(</span><span class="n">expo_old</span><span class="p">)</span> <span class="o">*</span> <span class="n">mul_fac_old</span>
        <span class="n">deg_diff_old</span><span class="p">,</span> <span class="n">mul_fac_old</span> <span class="o">=</span> <span class="n">deg_diff_new</span><span class="p">,</span> <span class="n">mul_fac_new</span>
        <span class="n">rho1</span><span class="p">,</span> <span class="n">rho2</span> <span class="o">=</span> <span class="n">rho2</span><span class="p">,</span> <span class="n">rho3</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sturm_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">simplify</span><span class="p">(</span><span class="n">lcf</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">*</span>  <span class="n">Abs</span><span class="p">(</span><span class="n">mul_fac_old</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sturm_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">simplify</span><span class="p">(</span> <span class="n">a2</span> <span class="o">*</span>  <span class="n">Abs</span><span class="p">(</span><span class="n">mul_fac_old</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>          <span class="c1"># change the sign of the sequence</span>
        <span class="n">sturm_seq</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sturm_seq</span><span class="p">]</span>

    <span class="c1"># gcd is of degree &gt; 0 ?</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sturm_seq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sturm_seq</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nan</span> <span class="ow">or</span> <span class="n">sturm_seq</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sturm_seq</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sturm_seq</span></div>

<div class="viewcode-block" id="sturm_q"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.sturm_q">[docs]</a><span class="k">def</span> <span class="nf">sturm_q</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the (generalized) Sturm sequence of p and q in Q[x].</span>
<span class="sd">    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).</span>

<span class="sd">    The coefficients of the polynomials in the Sturm sequence can be uniquely</span>
<span class="sd">    determined from the corresponding coefficients of the polynomials found</span>
<span class="sd">    either in:</span>

<span class="sd">        (a) the ``modified&#39;&#39; subresultant prs, (references 1, 2)</span>

<span class="sd">    or in</span>

<span class="sd">        (b) the subresultant prs (reference 3).</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding</span>
<span class="sd">    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,</span>
<span class="sd">    Second Series, 18 (1917), No. 4, 188–193.</span>

<span class="sd">    2 Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences</span>
<span class="sd">    and Modified Subresultant Polynomial Remainder Sequences.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, Vol. 8, No 1, 29–46, 2014.</span>

<span class="sd">    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result</span>
<span class="sd">    on the Theory of Subresultants.&#39;&#39; Submitted for publication.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither p nor q is 0</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="n">d0</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">d1</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d0</span><span class="p">:</span>
        <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d0</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure LC(p) &gt; 0</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span>  <span class="n">LC</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span>
        <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="n">q</span>

    <span class="c1"># initialize</span>
    <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>                           <span class="c1"># the input polys</span>
    <span class="n">sturm_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">]</span>                    <span class="c1"># the output list</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="o">-</span><span class="n">rem</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>            <span class="c1"># first remainder</span>
    <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                     <span class="c1"># degree of a2</span>
    <span class="n">sturm_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">a2</span> <span class="p">)</span>

    <span class="c1"># main loop</span>
    <span class="k">while</span> <span class="n">d2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span>      <span class="c1"># update polys and degrees</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="o">-</span><span class="n">rem</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>         <span class="c1"># new remainder</span>
        <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                  <span class="c1"># actual degree of a2</span>
        <span class="n">sturm_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">a2</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>          <span class="c1"># change the sign of the sequence</span>
        <span class="n">sturm_seq</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sturm_seq</span><span class="p">]</span>

    <span class="c1"># gcd is of degree &gt; 0 ?</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sturm_seq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sturm_seq</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nan</span> <span class="ow">or</span> <span class="n">sturm_seq</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sturm_seq</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sturm_seq</span></div>

<div class="viewcode-block" id="sturm_amv"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.sturm_amv">[docs]</a><span class="k">def</span> <span class="nf">sturm_amv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].</span>
<span class="sd">    If q = diff(p, x, 1) it is the usual Sturm sequence.</span>

<span class="sd">    A. If method == 0, default, the remainder coefficients of the</span>
<span class="sd">       sequence are (in absolute value) ``modified&#39;&#39; subresultants, which</span>
<span class="sd">       for non-monic polynomials are greater than the coefficients of the</span>
<span class="sd">       corresponding subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).</span>

<span class="sd">    B. If method == 1, the remainder coefficients of the sequence are (in</span>
<span class="sd">       absolute value) subresultants, which for non-monic polynomials are</span>
<span class="sd">       smaller than the coefficients of the corresponding ``modified&#39;&#39;</span>
<span class="sd">       subresultants by the factor Abs( LC(p)**( deg(p)- deg(q)) ).</span>

<span class="sd">    If the Sturm sequence is complete, method=0 and LC( p ) &gt; 0, then the</span>
<span class="sd">    coefficients of the polynomials in the sequence are ``modified&#39;&#39; subresultants.</span>
<span class="sd">    That is, they are  determinants of appropriately selected submatrices of</span>
<span class="sd">    sylvester2, Sylvester&#39;s matrix of 1853. In this case the Sturm sequence</span>
<span class="sd">    coincides with the ``modified&#39;&#39; subresultant prs, of the polynomials</span>
<span class="sd">    p, q.</span>

<span class="sd">    If the Sturm sequence is incomplete and method=0 then the signs of the</span>
<span class="sd">    coefficients of the polynomials in the sequence may differ from the signs</span>
<span class="sd">    of the coefficients of the corresponding polynomials in the ``modified&#39;&#39;</span>
<span class="sd">    subresultant prs; however, the absolute values are the same.</span>

<span class="sd">    To compute the coefficients, no determinant evaluation takes place.</span>
<span class="sd">    Instead, we first compute the euclidean sequence  of p and q using</span>
<span class="sd">    euclid_amv(p, q, x) and then: (a) change the signs of the remainders in the</span>
<span class="sd">    Euclidean sequence according to the pattern &quot;-, -, +, +, -, -, +, +,...&quot;</span>
<span class="sd">    (see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference)</span>
<span class="sd">    and (b) if method=0, assuming deg(p) &gt; deg(q), we multiply the remainder</span>
<span class="sd">    coefficients of the Euclidean sequence times the factor</span>
<span class="sd">    Abs( LC(p)**( deg(p)- deg(q)) ) to make them modified subresultants.</span>
<span class="sd">    See also the function sturm_pg(p, q, x).</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result</span>
<span class="sd">    on the Theory of Subresultants.&#39;&#39; Submitted for publication.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders</span>
<span class="sd">    Obtained in Finding the Greatest Common Divisor of Two Polynomials.&#39;&#39; Serdica</span>
<span class="sd">    Journal of Computing, to appear.</span>

<span class="sd">    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial</span>
<span class="sd">    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].&#39;&#39;</span>
<span class="sd">    Submitted for publication.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute the euclidean sequence</span>
    <span class="n">prs</span> <span class="o">=</span> <span class="n">euclid_amv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># defensive</span>
    <span class="k">if</span> <span class="n">prs</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">prs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prs</span>

    <span class="c1"># the coefficients in prs are subresultants and hence are smaller</span>
    <span class="c1"># than the corresponding subresultants by the factor</span>
    <span class="c1"># Abs( LC(prs[0])**( deg(prs[0]) - deg(prs[1])) ); Theorem 2, 2nd reference.</span>
    <span class="n">lcf</span> <span class="o">=</span> <span class="n">Abs</span><span class="p">(</span> <span class="n">LC</span><span class="p">(</span><span class="n">prs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="p">(</span> <span class="n">degree</span><span class="p">(</span><span class="n">prs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">degree</span><span class="p">(</span><span class="n">prs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

    <span class="c1"># the signs of the first two polys in the sequence stay the same</span>
    <span class="n">sturm_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">prs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># change the signs according to &quot;-, -, +, +, -, -, +, +,...&quot;</span>
    <span class="c1"># and multiply times lcf if needed</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prs</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span>  <span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sturm_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span> <span class="n">prs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">sturm_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span> <span class="n">prs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sturm_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">prs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">sturm_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">prs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># subresultants or modified subresultants?</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">lcf</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">aux_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">sturm_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sturm_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">aux_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">sturm_seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">lcf</span> <span class="p">))</span>
        <span class="n">sturm_seq</span> <span class="o">=</span> <span class="n">aux_seq</span>

    <span class="k">return</span> <span class="n">sturm_seq</span></div>

<div class="viewcode-block" id="euclid_pg"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.euclid_pg">[docs]</a><span class="k">def</span> <span class="nf">euclid_pg</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the Euclidean sequence of p and q in Z[x] or Q[x].</span>

<span class="sd">    If the Euclidean sequence is complete the coefficients of the polynomials</span>
<span class="sd">    in the sequence are subresultants. That is, they are  determinants of</span>
<span class="sd">    appropriately selected submatrices of sylvester1, Sylvester&#39;s matrix of 1840.</span>
<span class="sd">    In this case the Euclidean sequence coincides with the subresultant prs</span>
<span class="sd">    of the polynomials p, q.</span>

<span class="sd">    If the Euclidean sequence is incomplete the signs of the coefficients of the</span>
<span class="sd">    polynomials in the sequence may differ from the signs of the coefficients of</span>
<span class="sd">    the corresponding polynomials in the subresultant prs; however, the absolute</span>
<span class="sd">    values are the same.</span>

<span class="sd">    To compute the Euclidean sequence, no determinant evaluation takes place.</span>
<span class="sd">    We first compute the (generalized) Sturm sequence  of p and q using</span>
<span class="sd">    sturm_pg(p, q, x, 1), in which case the coefficients are (in absolute value)</span>
<span class="sd">    equal to subresultants. Then we change the signs of the remainders in the</span>
<span class="sd">    Sturm sequence according to the pattern &quot;-, -, +, +, -, -, +, +,...&quot; ;</span>
<span class="sd">    see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference as well as</span>
<span class="sd">    the function sturm_pg(p, q, x).</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result</span>
<span class="sd">    on the Theory of Subresultants.&#39;&#39; Submitted for publication.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders</span>
<span class="sd">    Obtained in Finding the Greatest Common Divisor of Two Polynomials.&#39;&#39; Serdica</span>
<span class="sd">    Journal of Computing, to appear.</span>

<span class="sd">    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial</span>
<span class="sd">    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].&#39;&#39;</span>
<span class="sd">    Submitted for publication.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute the sturmian sequence using the Pell-Gordon (or AMV) theorem</span>
    <span class="c1"># with the coefficients in the prs being (in absolute value) subresultants</span>
    <span class="n">prs</span> <span class="o">=</span> <span class="n">sturm_pg</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">## any other method would do</span>

    <span class="c1"># defensive</span>
    <span class="k">if</span> <span class="n">prs</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">prs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prs</span>

    <span class="c1"># the signs of the first two polys in the sequence stay the same</span>
    <span class="n">euclid_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">prs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># change the signs according to &quot;-, -, +, +, -, -, +, +,...&quot;</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prs</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span>  <span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">euclid_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span> <span class="n">prs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">euclid_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span> <span class="n">prs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">euclid_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">euclid_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">euclid_seq</span></div>

<div class="viewcode-block" id="euclid_q"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.euclid_q">[docs]</a><span class="k">def</span> <span class="nf">euclid_q</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the Euclidean sequence of p and q in Q[x].</span>
<span class="sd">    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).</span>

<span class="sd">    The coefficients of the polynomials in the Euclidean sequence can be uniquely</span>
<span class="sd">    determined from the corresponding coefficients of the polynomials found</span>
<span class="sd">    either in:</span>

<span class="sd">        (a) the ``modified&#39;&#39; subresultant polynomial remainder sequence,</span>
<span class="sd">    (references 1, 2)</span>

<span class="sd">    or in</span>

<span class="sd">        (b) the subresultant polynomial remainder sequence (references 3).</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding</span>
<span class="sd">    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,</span>
<span class="sd">    Second Series, 18 (1917), No. 4, 188–193.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences</span>
<span class="sd">    and Modified Subresultant Polynomial Remainder Sequences.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, Vol. 8, No 1, 29–46, 2014.</span>

<span class="sd">    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result</span>
<span class="sd">    on the Theory of Subresultants.&#39;&#39; Submitted for publication.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither p nor q is 0</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="n">d0</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">d1</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d0</span><span class="p">:</span>
        <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d0</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure LC(p) &gt; 0</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span>  <span class="n">LC</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">p</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span>
        <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="n">q</span>

    <span class="c1"># initialize</span>
    <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>                           <span class="c1"># the input polys</span>
    <span class="n">euclid_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">]</span>                   <span class="c1"># the output list</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">rem</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>             <span class="c1"># first remainder</span>
    <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                     <span class="c1"># degree of a2</span>
    <span class="n">euclid_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">a2</span> <span class="p">)</span>

    <span class="c1"># main loop</span>
    <span class="k">while</span> <span class="n">d2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span>      <span class="c1"># update polys and degrees</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">rem</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>          <span class="c1"># new remainder</span>
        <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                  <span class="c1"># actual degree of a2</span>
        <span class="n">euclid_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">a2</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>          <span class="c1"># change the sign of the sequence</span>
        <span class="n">euclid_seq</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">euclid_seq</span><span class="p">]</span>

    <span class="c1"># gcd is of degree &gt; 0 ?</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">euclid_seq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">euclid_seq</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nan</span> <span class="ow">or</span> <span class="n">euclid_seq</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">euclid_seq</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">euclid_seq</span></div>

<div class="viewcode-block" id="euclid_amv"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.euclid_amv">[docs]</a><span class="k">def</span> <span class="nf">euclid_amv</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    f, g are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(f, x) &gt;= degree(g, x).</span>

<span class="sd">    Computes the Euclidean sequence of p and q in Z[x] or Q[x].</span>

<span class="sd">    If the Euclidean sequence is complete the coefficients of the polynomials</span>
<span class="sd">    in the sequence are subresultants. That is, they are  determinants of</span>
<span class="sd">    appropriately selected submatrices of sylvester1, Sylvester&#39;s matrix of 1840.</span>
<span class="sd">    In this case the Euclidean sequence coincides with the subresultant prs,</span>
<span class="sd">    of the polynomials p, q.</span>

<span class="sd">    If the Euclidean sequence is incomplete the signs of the coefficients of the</span>
<span class="sd">    polynomials in the sequence may differ from the signs of the coefficients of</span>
<span class="sd">    the corresponding polynomials in the subresultant prs; however, the absolute</span>
<span class="sd">    values are the same.</span>

<span class="sd">    To compute the coefficients, no determinant evaluation takes place.</span>
<span class="sd">    Instead, polynomial divisions in Z[x] or Q[x] are performed, using</span>
<span class="sd">    the function rem_z(f, g, x);  the coefficients of the remainders</span>
<span class="sd">    computed this way become subresultants with the help of the</span>
<span class="sd">    Collins-Brown-Traub formula for coefficient reduction.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result</span>
<span class="sd">    on the Theory of Subresultants.&#39;&#39; Submitted for publication.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial</span>
<span class="sd">    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].&#39;&#39;</span>
<span class="sd">    Submitted for publication.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither f nor g is 0</span>
    <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">g</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="n">d0</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">d1</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d0</span><span class="p">:</span>
        <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d0</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>

    <span class="c1"># initialize</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">f</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">g</span>
    <span class="n">euclid_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">]</span>
    <span class="n">deg_dif_p1</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">degree</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># compute the first polynomial of the prs</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">rem_z</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">Abs</span><span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">deg_dif_p1</span> <span class="p">)</span>     <span class="c1"># first remainder</span>
    <span class="n">euclid_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">a2</span> <span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                              <span class="c1"># actual degree of a2</span>

    <span class="c1"># main loop</span>
    <span class="k">while</span> <span class="n">d2</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span>       <span class="c1"># update polys and degrees</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">sigma0</span> <span class="o">=</span> <span class="o">-</span><span class="n">LC</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma0</span><span class="o">**</span><span class="p">(</span><span class="n">deg_dif_p1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="p">(</span><span class="n">deg_dif_p1</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">deg_dif_p1</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">d2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">rem_z</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">Abs</span><span class="p">(</span> <span class="p">((</span><span class="n">c</span><span class="o">**</span><span class="p">(</span><span class="n">deg_dif_p1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">sigma0</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">euclid_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">a2</span> <span class="p">)</span>
        <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                   <span class="c1"># actual degree of a2</span>

    <span class="c1"># gcd is of degree &gt; 0 ?</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">euclid_seq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">euclid_seq</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nan</span> <span class="ow">or</span> <span class="n">euclid_seq</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">euclid_seq</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">euclid_seq</span></div>

<div class="viewcode-block" id="modified_subresultants_pg"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.modified_subresultants_pg">[docs]</a><span class="k">def</span> <span class="nf">modified_subresultants_pg</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the ``modified&#39;&#39; subresultant prs of p and q in Z[x] or Q[x];</span>
<span class="sd">    the coefficients of the polynomials in the sequence are</span>
<span class="sd">    ``modified&#39;&#39; subresultants. That is, they are  determinants of appropriately</span>
<span class="sd">    selected submatrices of sylvester2, Sylvester&#39;s matrix of 1853.</span>

<span class="sd">    To compute the coefficients, no determinant evaluation takes place. Instead,</span>
<span class="sd">    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);</span>
<span class="sd">    the coefficients of the remainders computed this way become ``modified&#39;&#39;</span>
<span class="sd">    subresultants with the help of the Pell-Gordon Theorem of 1917.</span>

<span class="sd">    If the ``modified&#39;&#39; subresultant prs is complete, and LC( p ) &gt; 0, it coincides</span>
<span class="sd">    with the (generalized) Sturm sequence of the polynomials p, q.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding</span>
<span class="sd">    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,</span>
<span class="sd">    Second Series, 18 (1917), No. 4, 188–193.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences</span>
<span class="sd">    and Modified Subresultant Polynomial Remainder Sequences.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, Vol. 8, No 1, 29–46, 2014.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither p nor q is 0</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="n">d0</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="n">d1</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d0</span><span class="p">:</span>
        <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d0</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">]</span>

    <span class="c1"># initialize</span>
    <span class="n">k</span> <span class="o">=</span>  <span class="n">var</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>                               <span class="c1"># index in summation formula</span>
    <span class="n">u_list</span> <span class="o">=</span> <span class="p">[]</span>                                 <span class="c1"># of elements (-1)**u_i</span>
    <span class="n">subres_l</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>                           <span class="c1"># mod. subr. prs output list</span>
    <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>                               <span class="c1"># the input polys</span>
    <span class="n">del0</span> <span class="o">=</span> <span class="n">d0</span> <span class="o">-</span> <span class="n">d1</span>                              <span class="c1"># degree difference</span>
    <span class="n">degdif</span> <span class="o">=</span> <span class="n">del0</span>                               <span class="c1"># save it</span>
    <span class="n">rho_1</span> <span class="o">=</span> <span class="n">LC</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>                              <span class="c1"># lead. coeff (a0)</span>

    <span class="c1"># Initialize Pell-Gordon variables</span>
    <span class="n">rho_list_minus_1</span> <span class="o">=</span>  <span class="n">sign</span><span class="p">(</span> <span class="n">LC</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>      <span class="c1"># sign of LC(a0)</span>
    <span class="n">rho1</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                         <span class="c1"># leading coeff of a1</span>
    <span class="n">rho_list</span> <span class="o">=</span> <span class="p">[</span> <span class="n">sign</span><span class="p">(</span><span class="n">rho1</span><span class="p">)]</span>                  <span class="c1"># of signs</span>
    <span class="n">p_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">del0</span><span class="p">]</span>                           <span class="c1"># of degree differences</span>
    <span class="n">u</span> <span class="o">=</span>  <span class="n">summation</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>      <span class="c1"># value of u</span>
    <span class="n">u_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>                          <span class="c1"># of u values</span>
    <span class="n">v</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p_list</span><span class="p">)</span>                           <span class="c1"># v value</span>

    <span class="c1"># first remainder</span>
    <span class="n">exp_deg</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="mi">1</span>                          <span class="c1"># expected degree of a2</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">rem</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>             <span class="c1"># first remainder</span>
    <span class="n">rho2</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                         <span class="c1"># leading coeff of a2</span>
    <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                       <span class="c1"># actual degree of a2</span>
    <span class="n">deg_diff_new</span> <span class="o">=</span> <span class="n">exp_deg</span> <span class="o">-</span> <span class="n">d2</span>               <span class="c1"># expected - actual degree</span>
    <span class="n">del1</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span>                            <span class="c1"># degree difference</span>

    <span class="c1"># mul_fac is the factor by which a2 is multiplied to</span>
    <span class="c1"># get integer coefficients</span>
    <span class="n">mul_fac_old</span> <span class="o">=</span> <span class="n">rho1</span><span class="o">**</span><span class="p">(</span><span class="n">del0</span> <span class="o">+</span> <span class="n">del1</span> <span class="o">-</span> <span class="n">deg_diff_new</span><span class="p">)</span>

    <span class="c1"># update Pell-Gordon variables</span>
    <span class="n">p_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">deg_diff_new</span><span class="p">)</span>              <span class="c1"># deg_diff_new is 0 for complete seq</span>

    <span class="c1"># apply Pell-Gordon formula (7) in second reference</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>                                     <span class="c1"># numerator of fraction</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u_list</span><span class="p">)):</span>
        <span class="n">num</span> <span class="o">*=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">u_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">v</span>

    <span class="c1"># denominator depends on complete / incomplete seq</span>
    <span class="k">if</span> <span class="n">deg_diff_new</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>                        <span class="c1"># complete seq</span>
        <span class="n">den</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_list</span><span class="p">)):</span>
            <span class="n">den</span> <span class="o">*=</span> <span class="n">rho_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">p_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_list</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">den</span> <span class="o">*</span> <span class="n">rho_list_minus_1</span>
    <span class="k">else</span><span class="p">:</span>                                       <span class="c1"># incomplete seq</span>
        <span class="n">den</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">den</span> <span class="o">*=</span> <span class="n">rho_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">p_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_list</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">den</span> <span class="o">*</span> <span class="n">rho_list_minus_1</span>
        <span class="n">expo</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_list</span><span class="p">)]</span> <span class="o">-</span> <span class="n">deg_diff_new</span><span class="p">)</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">den</span> <span class="o">*</span> <span class="n">rho_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="n">expo</span>

    <span class="c1"># the sign of the determinant depends on sg(num / den)</span>
    <span class="k">if</span>  <span class="n">sign</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subres_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">simplify</span><span class="p">(</span><span class="n">rho_1</span><span class="o">**</span><span class="n">degdif</span><span class="o">*</span><span class="n">a2</span><span class="o">*</span> <span class="n">Abs</span><span class="p">(</span><span class="n">mul_fac_old</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subres_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span> <span class="n">simplify</span><span class="p">(</span><span class="n">rho_1</span><span class="o">**</span><span class="n">degdif</span><span class="o">*</span><span class="n">a2</span><span class="o">*</span> <span class="n">Abs</span><span class="p">(</span><span class="n">mul_fac_old</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

    <span class="c1"># update Pell-Gordon variables</span>
    <span class="n">k</span> <span class="o">=</span>  <span class="n">var</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
    <span class="n">rho_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sign</span><span class="p">(</span><span class="n">rho2</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span>  <span class="n">summation</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">p_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="n">u_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p_list</span><span class="p">)</span>
    <span class="n">deg_diff_old</span><span class="o">=</span><span class="n">deg_diff_new</span>

    <span class="c1"># main loop</span>
    <span class="k">while</span> <span class="n">d2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span>      <span class="c1"># update polys and degrees</span>
        <span class="n">del0</span> <span class="o">=</span> <span class="n">del1</span>                          <span class="c1"># update degree difference</span>
        <span class="n">exp_deg</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="mi">1</span>                     <span class="c1"># new expected degree</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="o">-</span> <span class="n">rem</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>        <span class="c1"># new remainder</span>
        <span class="n">rho3</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                    <span class="c1"># leading coeff of a2</span>
        <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                  <span class="c1"># actual degree of a2</span>
        <span class="n">deg_diff_new</span> <span class="o">=</span> <span class="n">exp_deg</span> <span class="o">-</span> <span class="n">d2</span>          <span class="c1"># expected - actual degree</span>
        <span class="n">del1</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span>                       <span class="c1"># degree difference</span>

        <span class="c1"># take into consideration the power</span>
        <span class="c1"># rho1**deg_diff_old that was &quot;left out&quot;</span>
        <span class="n">expo_old</span> <span class="o">=</span> <span class="n">deg_diff_old</span>               <span class="c1"># rho1 raised to this power</span>
        <span class="n">expo_new</span> <span class="o">=</span> <span class="n">del0</span> <span class="o">+</span> <span class="n">del1</span> <span class="o">-</span> <span class="n">deg_diff_new</span> <span class="c1"># rho2 raised to this power</span>

        <span class="n">mul_fac_new</span> <span class="o">=</span> <span class="n">rho2</span><span class="o">**</span><span class="p">(</span><span class="n">expo_new</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho1</span><span class="o">**</span><span class="p">(</span><span class="n">expo_old</span><span class="p">)</span> <span class="o">*</span> <span class="n">mul_fac_old</span>

        <span class="c1"># update variables</span>
        <span class="n">deg_diff_old</span><span class="p">,</span> <span class="n">mul_fac_old</span> <span class="o">=</span> <span class="n">deg_diff_new</span><span class="p">,</span> <span class="n">mul_fac_new</span>
        <span class="n">rho1</span><span class="p">,</span> <span class="n">rho2</span> <span class="o">=</span> <span class="n">rho2</span><span class="p">,</span> <span class="n">rho3</span>

        <span class="c1"># update Pell-Gordon variables</span>
        <span class="n">p_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">deg_diff_new</span><span class="p">)</span>       <span class="c1"># deg_diff_new is 0 for complete seq</span>

        <span class="c1"># apply Pell-Gordon formula (7) in second reference</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span>                              <span class="c1"># numerator</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u_list</span><span class="p">)):</span>
            <span class="n">num</span> <span class="o">*=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">u_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">v</span>

        <span class="c1"># denominator depends on complete / incomplete seq</span>
        <span class="k">if</span> <span class="n">deg_diff_new</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>                 <span class="c1"># complete seq</span>
            <span class="n">den</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_list</span><span class="p">)):</span>
                <span class="n">den</span> <span class="o">*=</span> <span class="n">rho_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">p_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_list</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">den</span> <span class="o">*</span> <span class="n">rho_list_minus_1</span>
        <span class="k">else</span><span class="p">:</span>                                <span class="c1"># incomplete seq</span>
            <span class="n">den</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">den</span> <span class="o">*=</span> <span class="n">rho_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">p_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_list</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">den</span> <span class="o">*</span> <span class="n">rho_list_minus_1</span>
            <span class="n">expo</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_list</span><span class="p">)]</span> <span class="o">-</span> <span class="n">deg_diff_new</span><span class="p">)</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">den</span> <span class="o">*</span> <span class="n">rho_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rho_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="n">expo</span>

        <span class="c1"># the sign of the determinant depends on sg(num / den)</span>
        <span class="k">if</span>  <span class="n">sign</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">subres_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">simplify</span><span class="p">(</span><span class="n">rho_1</span><span class="o">**</span><span class="n">degdif</span><span class="o">*</span><span class="n">a2</span><span class="o">*</span> <span class="n">Abs</span><span class="p">(</span><span class="n">mul_fac_old</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subres_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span> <span class="n">simplify</span><span class="p">(</span><span class="n">rho_1</span><span class="o">**</span><span class="n">degdif</span><span class="o">*</span><span class="n">a2</span><span class="o">*</span> <span class="n">Abs</span><span class="p">(</span><span class="n">mul_fac_old</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

        <span class="c1"># update Pell-Gordon variables</span>
        <span class="n">k</span> <span class="o">=</span>  <span class="n">var</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="n">rho_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sign</span><span class="p">(</span><span class="n">rho2</span><span class="p">))</span>
        <span class="n">u</span> <span class="o">=</span>  <span class="n">summation</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p_list</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">p_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="n">u_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p_list</span><span class="p">)</span>

    <span class="c1"># gcd is of degree &gt; 0 ?</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subres_l</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subres_l</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nan</span> <span class="ow">or</span> <span class="n">subres_l</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subres_l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># LC( p ) &lt; 0</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subres_l</span><span class="p">)</span>   <span class="c1"># list may be shorter now due to deg(gcd ) &gt; 0</span>
    <span class="k">if</span> <span class="n">LC</span><span class="p">(</span> <span class="n">p</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">aux_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">subres_l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subres_l</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">aux_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">subres_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">))</span>
        <span class="n">subres_l</span> <span class="o">=</span> <span class="n">aux_seq</span>

    <span class="k">return</span>  <span class="n">subres_l</span></div>

<div class="viewcode-block" id="subresultants_pg"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.subresultants_pg">[docs]</a><span class="k">def</span> <span class="nf">subresultants_pg</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the subresultant prs of p and q in Z[x] or Q[x], from</span>
<span class="sd">    the modified subresultant prs of p and q.</span>

<span class="sd">    The coefficients of the polynomials in these two sequences differ only</span>
<span class="sd">    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in</span>
<span class="sd">    Theorem 2 of the reference.</span>

<span class="sd">    The coefficients of the polynomials in the output sequence are</span>
<span class="sd">    subresultants. That is, they are  determinants of appropriately</span>
<span class="sd">    selected submatrices of sylvester1, Sylvester&#39;s matrix of 1840.</span>

<span class="sd">    If the subresultant prs is complete, then it coincides with the</span>
<span class="sd">    Euclidean sequence of the polynomials p, q.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ‘‘On the Remainders</span>
<span class="sd">    Obtained in Finding the Greatest Common Divisor of Two Polynomials.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, to appear.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute the modified subresultant prs</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="n">modified_subresultants_pg</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>  <span class="c1">## any other method would do</span>

    <span class="c1"># defensive</span>
    <span class="k">if</span> <span class="n">lst</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lst</span>

    <span class="c1"># the coefficients in lst are modified subresultants and, hence, are</span>
    <span class="c1"># greater than those of the corresponding subresultants by the factor</span>
    <span class="c1"># LC(lst[0])**( deg(lst[0]) - deg(lst[1])); see Theorem 2 in reference.</span>
    <span class="n">lcf</span> <span class="o">=</span> <span class="n">LC</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="p">(</span> <span class="n">degree</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">degree</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># Initialize the subresultant prs list</span>
    <span class="n">subr_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># compute the degree sequences m_i and j_i of Theorem 2 in reference.</span>
    <span class="n">deg_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">degree</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>
    <span class="n">deg</span> <span class="o">=</span> <span class="n">deg_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">deg_seq_s</span> <span class="o">=</span> <span class="n">deg_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">m_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">deg_seq_s</span><span class="p">]</span>
    <span class="n">j_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">deg</span> <span class="o">-</span> <span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m_seq</span><span class="p">]</span>

    <span class="c1"># compute the AMV factors of Theorem 2 in reference.</span>
    <span class="n">fact</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span> <span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">j_seq</span><span class="p">]</span>

    <span class="c1"># shortened list without the first two polys</span>
    <span class="n">lst_s</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

    <span class="c1"># poly lst_s[k] is multiplied times fact[k], divided by lcf</span>
    <span class="c1"># and appended to the subresultant prs list</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fact</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sign</span><span class="p">(</span><span class="n">fact</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">subr_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">lst_s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">lcf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subr_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst_s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">lcf</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subr_seq</span></div>

<div class="viewcode-block" id="subresultants_amv_q"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.subresultants_amv_q">[docs]</a><span class="k">def</span> <span class="nf">subresultants_amv_q</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the subresultant prs of p and q in Q[x];</span>
<span class="sd">    the coefficients of the polynomials in the sequence are</span>
<span class="sd">    subresultants. That is, they are  determinants of appropriately</span>
<span class="sd">    selected submatrices of sylvester1, Sylvester&#39;s matrix of 1840.</span>

<span class="sd">    To compute the coefficients, no determinant evaluation takes place.</span>
<span class="sd">    Instead, polynomial divisions in Q[x] are performed, using the</span>
<span class="sd">    function rem(p, q, x);  the coefficients of the remainders</span>
<span class="sd">    computed this way become subresultants with the help of the</span>
<span class="sd">    Akritas-Malaschonok-Vigklas Theorem of 2015.</span>

<span class="sd">    If the subresultant prs is complete, then it coincides with the</span>
<span class="sd">    Euclidean sequence of the polynomials p, q.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result</span>
<span class="sd">    on the Theory of Subresultants.&#39;&#39; Submitted for publication.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial</span>
<span class="sd">    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].&#39;&#39;</span>
<span class="sd">    Submitted for publication.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither p nor q is 0</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="n">d0</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">d1</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d0</span><span class="p">:</span>
        <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d0</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="c1"># initialize</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>                              <span class="c1"># counters for remainders &amp; odd elements</span>
    <span class="n">p_odd_index_sum</span> <span class="o">=</span> <span class="mi">0</span>                      <span class="c1"># contains the sum of p_1, p_3, etc</span>
    <span class="n">subres_l</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>                        <span class="c1"># subresultant prs output list</span>
    <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>                            <span class="c1"># the input polys</span>
    <span class="n">sigma1</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                      <span class="c1"># leading coeff of a1</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">d0</span> <span class="o">-</span> <span class="n">d1</span>                             <span class="c1"># degree difference</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="n">mul_fac</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">d1</span>

    <span class="c1"># main loop</span>
    <span class="k">while</span> <span class="n">d2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">rem</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span> <span class="n">QQ</span><span class="p">)</span>          <span class="c1"># new remainder</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sigma2</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma3</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span> <span class="o">=</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">sigma3</span>
        <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">phi</span> <span class="o">+</span> <span class="n">p_odd_index_sum</span>

        <span class="c1"># new mul_fac</span>
        <span class="n">mul_fac</span> <span class="o">=</span> <span class="n">sigma1</span><span class="o">**</span><span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">mul_fac</span>

        <span class="c1">## compute the sign of the first fraction in formula (9) of the paper</span>
        <span class="c1"># numerator</span>
        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">psi</span>
        <span class="c1"># denominator</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">mul_fac</span><span class="p">)</span>

        <span class="c1"># the sign of the determinant depends on sign( num / den ) != 0</span>
        <span class="k">if</span>  <span class="n">sign</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">subres_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">a2</span><span class="o">*</span> <span class="n">Abs</span><span class="p">(</span><span class="n">mul_fac</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subres_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span> <span class="n">simplify</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">a2</span><span class="o">*</span> <span class="n">Abs</span><span class="p">(</span><span class="n">mul_fac</span><span class="p">))))</span>

        <span class="c1">## bring into mul_fac the missing power of sigma if there was a degree gap</span>
        <span class="k">if</span> <span class="n">p1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mul_fac</span> <span class="o">=</span> <span class="n">mul_fac</span> <span class="o">*</span> <span class="n">sigma1</span><span class="o">**</span><span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

       <span class="c1"># update AMV variables</span>
        <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">p1</span>
        <span class="k">if</span> <span class="n">p0</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">p_odd_index_sum</span> <span class="o">+=</span> <span class="n">p0</span>             <span class="c1"># p_i has odd index</span>

    <span class="c1"># gcd is of degree &gt; 0 ?</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subres_l</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subres_l</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nan</span> <span class="ow">or</span> <span class="n">subres_l</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subres_l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span>  <span class="n">subres_l</span></div>

<div class="viewcode-block" id="compute_sign"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.compute_sign">[docs]</a><span class="k">def</span> <span class="nf">compute_sign</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">expo</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    base != 0 and expo &gt;= 0 are integers;</span>

<span class="sd">    returns the sign of base**expo without</span>
<span class="sd">    evaluating the power itself!</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sb</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sb</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">pe</span> <span class="o">=</span> <span class="n">expo</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">pe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">sb</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sb</span></div>

<div class="viewcode-block" id="rem_z"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.rem_z">[docs]</a><span class="k">def</span> <span class="nf">rem_z</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Intended mainly for p, q polynomials in Z[x] so that,</span>
<span class="sd">    on dividing p by q, the remainder will also be in Z[x]. (However,</span>
<span class="sd">    it also works fine for polynomials in Q[x].) It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    It premultiplies p by the _absolute_ value of the leading coefficient</span>
<span class="sd">    of q, raised to the power deg(p) - deg(q) + 1 and then performs</span>
<span class="sd">    polynomial division in Q[x], using the function rem(p, q, x).</span>

<span class="sd">    By contrast the function prem(p, q, x) does _not_ use the absolute</span>
<span class="sd">    value of the leading coefficient of q.</span>
<span class="sd">    This results not only in ``messing up the signs&#39;&#39; of the Euclidean and</span>
<span class="sd">    Sturmian prs&#39;s as mentioned in the second reference,</span>
<span class="sd">    but also in violation of the main results of the first and third</span>
<span class="sd">    references --- Theorem 4 and Theorem 1 respectively. Theorems 4 and 1</span>
<span class="sd">    establish a one-to-one correspondence between the Euclidean and the</span>
<span class="sd">    Sturmian prs of p, q, on one hand, and the subresultant prs of p, q,</span>
<span class="sd">    on the other.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders</span>
<span class="sd">    Obtained in Finding the Greatest Common Divisor of Two Polynomials.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, to appear.</span>

<span class="sd">    2. http://planetMath.org/sturmstheorem</span>

<span class="sd">    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result on</span>
<span class="sd">    the Theory of Subresultants.&#39;&#39; Submitted for publication.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">degree</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rem</span><span class="p">(</span><span class="n">Abs</span><span class="p">(</span><span class="n">LC</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">**</span><span class="n">delta</span>  <span class="o">*</span>  <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="quo_z"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.quo_z">[docs]</a><span class="k">def</span> <span class="nf">quo_z</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Intended mainly for p, q polynomials in Z[x] so that,</span>
<span class="sd">    on dividing p by q, the quotient will also be in Z[x]. (However,</span>
<span class="sd">    it also works fine for polynomials in Q[x].) It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    It premultiplies p by the _absolute_ value of the leading coefficient</span>
<span class="sd">    of q, raised to the power deg(p) - deg(q) + 1 and then performs</span>
<span class="sd">    polynomial division in Q[x], using the function quo(p, q, x).</span>

<span class="sd">    By contrast the function pquo(p, q, x) does _not_ use the absolute</span>
<span class="sd">    value of the leading coefficient of q.</span>

<span class="sd">    See also function rem_z(p, q, x) for additional comments and references.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">degree</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quo</span><span class="p">(</span><span class="n">Abs</span><span class="p">(</span><span class="n">LC</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">**</span><span class="n">delta</span>  <span class="o">*</span>  <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="subresultants_amv"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.subresultants_amv">[docs]</a><span class="k">def</span> <span class="nf">subresultants_amv</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(f, x) &gt;= degree(g, x).</span>

<span class="sd">    Computes the subresultant prs of p and q in Z[x] or Q[x];</span>
<span class="sd">    the coefficients of the polynomials in the sequence are</span>
<span class="sd">    subresultants. That is, they are  determinants of appropriately</span>
<span class="sd">    selected submatrices of sylvester1, Sylvester&#39;s matrix of 1840.</span>

<span class="sd">    To compute the coefficients, no determinant evaluation takes place.</span>
<span class="sd">    Instead, polynomial divisions in Z[x] or Q[x] are performed, using</span>
<span class="sd">    the function rem_z(p, q, x);  the coefficients of the remainders</span>
<span class="sd">    computed this way become subresultants with the help of the</span>
<span class="sd">    Akritas-Malaschonok-Vigklas Theorem of 2015 and the Collins-Brown-</span>
<span class="sd">    Traub formula for coefficient reduction.</span>

<span class="sd">    If the subresultant prs is complete, then it coincides with the</span>
<span class="sd">    Euclidean sequence of the polynomials p, q.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result</span>
<span class="sd">    on the Theory of Subresultants.&#39;&#39; Submitted for publication.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial</span>
<span class="sd">    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].&#39;&#39;</span>
<span class="sd">    Submitted for publication.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither f nor g is 0</span>
    <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">g</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="n">d0</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">d1</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="n">d0</span><span class="p">:</span>
        <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d0</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span>
    <span class="k">if</span> <span class="n">d0</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>

    <span class="c1"># initialize</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">f</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">g</span>
    <span class="n">subres_l</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">]</span>
    <span class="n">deg_dif_p1</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">degree</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># initialize AMV variables</span>
    <span class="n">sigma1</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                      <span class="c1"># leading coeff of a1</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>                              <span class="c1"># counters for remainders &amp; odd elements</span>
    <span class="n">p_odd_index_sum</span> <span class="o">=</span> <span class="mi">0</span>                      <span class="c1"># contains the sum of p_1, p_3, etc</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">deg_dif_p1</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span>

    <span class="c1"># compute the first polynomial of the prs</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">rem_z</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">Abs</span><span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">deg_dif_p1</span> <span class="p">)</span>     <span class="c1"># first remainder</span>
    <span class="n">sigma2</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                       <span class="c1"># leading coeff of a2</span>
    <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                       <span class="c1"># actual degree of a2</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span>                              <span class="c1"># degree difference</span>

    <span class="c1"># sgn_den is the factor, the denominator 1st fraction of (9),</span>
    <span class="c1"># by which a2 is multiplied to get integer coefficients</span>
    <span class="n">sgn_den</span> <span class="o">=</span> <span class="n">compute_sign</span><span class="p">(</span> <span class="n">sigma1</span><span class="p">,</span> <span class="n">p0</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>

    <span class="c1">## compute sign of the 1st fraction in formula (9) of the paper</span>
    <span class="c1"># numerator</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">phi</span> <span class="o">+</span> <span class="n">p_odd_index_sum</span>
    <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">psi</span>
    <span class="c1"># denominator</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">sgn_den</span>

    <span class="c1"># the sign of the determinant depends on sign(num / den) != 0</span>
    <span class="k">if</span>  <span class="n">sign</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subres_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">a2</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subres_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span><span class="n">a2</span> <span class="p">)</span>

    <span class="c1"># update AMV variable</span>
    <span class="k">if</span> <span class="n">p1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># bring in the missing power of sigma if there was gap</span>
    <span class="k">if</span> <span class="n">p1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sgn_den</span> <span class="o">=</span> <span class="n">sgn_den</span> <span class="o">*</span> <span class="n">compute_sign</span><span class="p">(</span> <span class="n">sigma1</span><span class="p">,</span> <span class="n">p1</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span>

    <span class="c1"># main loop</span>
    <span class="k">while</span> <span class="n">d2</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">p_odd_index_sum</span> <span class="o">+=</span> <span class="n">p1</span>             <span class="c1"># p_i has odd index</span>
        <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">d0</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span>       <span class="c1"># update polys and degrees</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">p1</span>                               <span class="c1"># update degree difference</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">sigma0</span> <span class="o">=</span> <span class="o">-</span><span class="n">LC</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma0</span><span class="o">**</span><span class="p">(</span><span class="n">deg_dif_p1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="p">(</span><span class="n">deg_dif_p1</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">deg_dif_p1</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">d2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">rem_z</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">Abs</span><span class="p">(</span> <span class="p">((</span><span class="n">c</span><span class="o">**</span><span class="p">(</span><span class="n">deg_dif_p1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">sigma0</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">sigma3</span> <span class="o">=</span>  <span class="n">LC</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                   <span class="c1"># leading coeff of a2</span>
        <span class="n">d2</span> <span class="o">=</span>  <span class="n">degree</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>                   <span class="c1"># actual degree of a2</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">-</span> <span class="n">d2</span>                          <span class="c1"># degree difference</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">phi</span> <span class="o">+</span> <span class="n">p_odd_index_sum</span>

        <span class="c1"># update variables</span>
        <span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span> <span class="o">=</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">sigma3</span>

        <span class="c1"># new sgn_den</span>
        <span class="n">sgn_den</span> <span class="o">=</span> <span class="n">compute_sign</span><span class="p">(</span> <span class="n">sigma1</span><span class="p">,</span> <span class="n">p0</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">*</span> <span class="n">sgn_den</span>

        <span class="c1"># compute the sign of the first fraction in formula (9) of the paper</span>
        <span class="c1"># numerator</span>
        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">psi</span>
        <span class="c1"># denominator</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">sgn_den</span>

        <span class="c1"># the sign of the determinant depends on sign( num / den ) != 0</span>
        <span class="k">if</span>  <span class="n">sign</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">subres_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">a2</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subres_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span><span class="n">a2</span> <span class="p">)</span>

        <span class="c1"># update AMV variable</span>
        <span class="k">if</span> <span class="n">p1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># bring in the missing power of sigma if there was gap</span>
        <span class="k">if</span> <span class="n">p1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sgn_den</span> <span class="o">=</span> <span class="n">sgn_den</span> <span class="o">*</span> <span class="n">compute_sign</span><span class="p">(</span> <span class="n">sigma1</span><span class="p">,</span> <span class="n">p1</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span>

    <span class="c1"># gcd is of degree &gt; 0 ?</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subres_l</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subres_l</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nan</span> <span class="ow">or</span> <span class="n">subres_l</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subres_l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">subres_l</span></div>

<div class="viewcode-block" id="modified_subresultants_amv"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.modified_subresultants_amv">[docs]</a><span class="k">def</span> <span class="nf">modified_subresultants_amv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the modified subresultant prs of p and q in Z[x] or Q[x],</span>
<span class="sd">    from the subresultant prs of p and q.</span>
<span class="sd">    The coefficients of the polynomials in the two sequences differ only</span>
<span class="sd">    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in</span>
<span class="sd">    Theorem 2 of the reference.</span>

<span class="sd">    The coefficients of the polynomials in the output sequence are</span>
<span class="sd">    modified subresultants. That is, they are  determinants of appropriately</span>
<span class="sd">    selected submatrices of sylvester2, Sylvester&#39;s matrix of 1853.</span>

<span class="sd">    If the modified subresultant prs is complete, and LC( p ) &gt; 0, it coincides</span>
<span class="sd">    with the (generalized) Sturm&#39;s sequence of the polynomials p, q.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ‘‘On the Remainders</span>
<span class="sd">    Obtained in Finding the Greatest Common Divisor of Two Polynomials.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, to appear.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute the subresultant prs</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="n">subresultants_amv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>     <span class="c1">## any other method would do</span>

    <span class="c1"># defensive</span>
    <span class="k">if</span> <span class="n">lst</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lst</span>

    <span class="c1"># the coefficients in lst are subresultants and, hence, smaller than those</span>
    <span class="c1"># of the corresponding modified subresultants by the factor</span>
    <span class="c1"># LC(lst[0])**( deg(lst[0]) - deg(lst[1])); see Theorem 2.</span>
    <span class="n">lcf</span> <span class="o">=</span> <span class="n">LC</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="p">(</span> <span class="n">degree</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">degree</span><span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># Initialize the modified subresultant prs list</span>
    <span class="n">subr_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># compute the degree sequences m_i and j_i of Theorem 2</span>
    <span class="n">deg_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">degree</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>
    <span class="n">deg</span> <span class="o">=</span> <span class="n">deg_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">deg_seq_s</span> <span class="o">=</span> <span class="n">deg_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">m_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">deg_seq_s</span><span class="p">]</span>
    <span class="n">j_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">deg</span> <span class="o">-</span> <span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m_seq</span><span class="p">]</span>

    <span class="c1"># compute the AMV factors of Theorem 2</span>
    <span class="n">fact</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span> <span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">j_seq</span><span class="p">]</span>

    <span class="c1"># shortened list without the first two polys</span>
    <span class="n">lst_s</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

    <span class="c1"># poly lst_s[k] is multiplied times fact[k] and times lcf</span>
    <span class="c1"># and appended to the subresultant prs list</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fact</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sign</span><span class="p">(</span><span class="n">fact</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">subr_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">simplify</span><span class="p">(</span><span class="o">-</span><span class="n">lst_s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">lcf</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subr_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">simplify</span><span class="p">(</span><span class="n">lst_s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">lcf</span><span class="p">)</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">subr_seq</span></div>

<div class="viewcode-block" id="correct_sign"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.correct_sign">[docs]</a><span class="k">def</span> <span class="nf">correct_sign</span><span class="p">(</span><span class="n">deg_f</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">rdel</span><span class="p">,</span> <span class="n">cdel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used in various subresultant prs algorithms.</span>

<span class="sd">    Evaluates the determinant, (a.k.a. subresultant) of a properly selected</span>
<span class="sd">    submatrix of s1, Sylvester&#39;s matrix of 1840, to get the correct sign</span>
<span class="sd">    and value of the leading coefficient of a given polynomial remainder.</span>

<span class="sd">    deg_f, deg_g are the degrees of the original polynomials p, q for which the</span>
<span class="sd">    matrix s1 = sylvester(p, q, x, 1) was constructed.</span>

<span class="sd">    rdel denotes the expected degree of the remainder; it is the number of</span>
<span class="sd">    rows to be deleted from each group of rows in s1 as described in the</span>
<span class="sd">    reference below.</span>

<span class="sd">    cdel denotes the expected degree minus the actual degree of the remainder;</span>
<span class="sd">    it is the number of columns to be deleted --- starting with the last column</span>
<span class="sd">    forming the square matrix --- from the matrix resulting after the row deletions.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences</span>
<span class="sd">    and Modified Subresultant Polynomial Remainder Sequences.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, Vol. 8, No 1, 29–46, 2014.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[:,</span> <span class="p">:]</span>   <span class="c1"># copy of matrix s1</span>

    <span class="c1"># eliminate rdel rows from the first deg_g rows</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="n">deg_f</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="n">deg_f</span> <span class="o">-</span> <span class="n">rdel</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">M</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># eliminate rdel rows from the last deg_f rows</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="n">rdel</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">M</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># eliminate cdel columns</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cdel</span><span class="p">):</span>
        <span class="n">M</span><span class="o">.</span><span class="n">col_del</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># define submatrix</span>
    <span class="n">Md</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span> <span class="n">M</span><span class="o">.</span><span class="n">rows</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">Md</span><span class="o">.</span><span class="n">det</span><span class="p">()</span></div>

<div class="viewcode-block" id="subresultants_rem"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.subresultants_rem">[docs]</a><span class="k">def</span> <span class="nf">subresultants_rem</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the subresultant prs of p and q in Z[x] or Q[x];</span>
<span class="sd">    the coefficients of the polynomials in the sequence are</span>
<span class="sd">    subresultants. That is, they are  determinants of appropriately</span>
<span class="sd">    selected submatrices of sylvester1, Sylvester&#39;s matrix of 1840.</span>

<span class="sd">    To compute the coefficients polynomial divisions in Q[x] are</span>
<span class="sd">    performed, using the function rem(p, q, x). The coefficients</span>
<span class="sd">    of the remainders computed this way become subresultants by evaluating</span>
<span class="sd">    one subresultant per remainder --- that of the leading coefficient.</span>
<span class="sd">    This way we obtain the correct sign and value of the leading coefficient</span>
<span class="sd">    of the remainder and we easily ``force&#39;&#39; the rest of the coefficients</span>
<span class="sd">    to become subresultants.</span>

<span class="sd">    If the subresultant prs is complete, then it coincides with the</span>
<span class="sd">    Euclidean sequence of the polynomials p, q.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G.:``Three New Methods for Computing Subresultant</span>
<span class="sd">    Polynomial Remainder Sequences (PRS’s).&#39;&#39; Serdica Journal of Computing,</span>
<span class="sd">    to appear.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither p nor q is 0</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">deg_f</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">deg_g</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">deg_f</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">deg_f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>

    <span class="c1"># initialize</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">sylvester</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">sr_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>      <span class="c1"># subresultant list</span>

    <span class="c1"># main loop</span>
    <span class="k">while</span> <span class="n">deg_g</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rem</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sr_list</span>

        <span class="c1"># make coefficients subresultants evaluating ONE determinant</span>
        <span class="n">exp_deg</span> <span class="o">=</span> <span class="n">deg_g</span> <span class="o">-</span> <span class="mi">1</span>          <span class="c1"># expected degree</span>
        <span class="n">sign_value</span> <span class="o">=</span> <span class="n">correct_sign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">exp_deg</span><span class="p">,</span> <span class="n">exp_deg</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">((</span><span class="n">r</span> <span class="o">/</span> <span class="n">LC</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">*</span> <span class="n">sign_value</span><span class="p">)</span>

        <span class="c1"># append poly with subresultant coeffs</span>
        <span class="n">sr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="c1"># update degrees and polys</span>
        <span class="n">deg_f</span><span class="p">,</span> <span class="n">deg_g</span> <span class="o">=</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">d</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span>

    <span class="c1"># gcd is of degree &gt; 0 ?</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sr_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sr_list</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nan</span> <span class="ow">or</span> <span class="n">sr_list</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sr_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sr_list</span></div>

<div class="viewcode-block" id="pivot"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.pivot">[docs]</a><span class="k">def</span> <span class="nf">pivot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    M is a matrix, and M[i, j] specifies the pivot element.</span>

<span class="sd">    All elements below M[i, j], in the j-th column, will</span>
<span class="sd">    be zeroed, if they are not already 0, according to</span>
<span class="sd">    Dodgson-Bareiss&#39; integer preserving transformations.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G.: ``A new method for computing polynomial greatest</span>
<span class="sd">    common divisors and polynomial remainder sequences.&#39;&#39;</span>
<span class="sd">    Numerische MatheMatik 52, 119-127, 1988.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem</span>
<span class="sd">    by Van Vleck Regarding Sturm Sequences.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, 7, No 4, 101–134, 2013.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:,</span> <span class="p">:]</span> <span class="c1"># copy of matrix M</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">rows</span> <span class="c1"># No. of rows</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">cols</span> <span class="c1"># No. of cols</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">rs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ma</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
                <span class="n">ma</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">ma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">ma</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">ma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">*</span> <span class="n">ma</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">ma</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">ma</span></div>

<div class="viewcode-block" id="rotate_r"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.rotate_r">[docs]</a><span class="k">def</span> <span class="nf">rotate_r</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Rotates right by k. L is a row of a matrix or a list.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ll</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ll</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">ll</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ll</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ll</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="k">else</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">ll</span><span class="p">])</span></div>

<div class="viewcode-block" id="rotate_l"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.rotate_l">[docs]</a><span class="k">def</span> <span class="nf">rotate_l</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Rotates left by k. L is a row of a matrix or a list.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ll</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ll</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">ll</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ll</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ll</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="k">else</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">ll</span><span class="p">])</span></div>

<div class="viewcode-block" id="row2poly"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.row2poly">[docs]</a><span class="k">def</span> <span class="nf">row2poly</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Converts the row of a matrix to a poly of degree deg and variable x.</span>
<span class="sd">    Some entries at the beginning and/or at the end of the row may be zero.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">leng</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

    <span class="c1"># find the beginning of the poly ; i.e. the first</span>
    <span class="c1"># non-zero element of the row</span>
    <span class="k">while</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># append the next deg + 1 elements to poly</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">leng</span><span class="p">:</span>
            <span class="n">poly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="n">j</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Poly</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="create_ma"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.create_ma">[docs]</a><span class="k">def</span> <span class="nf">create_ma</span><span class="p">(</span><span class="n">deg_f</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">,</span> <span class="n">col_num</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Creates a ``small&#39;&#39; matrix M to be triangularized.</span>

<span class="sd">    deg_f, deg_g are the degrees of the divident and of the</span>
<span class="sd">    divisor polynomials respectively, deg_g &gt; deg_f.</span>

<span class="sd">    The coefficients of the divident poly are the elements</span>
<span class="sd">    in row2 and those of the divisor poly are the elements</span>
<span class="sd">    in row1.</span>

<span class="sd">    col_num defines the number of columns of the matrix M.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">deg_g</span> <span class="o">-</span> <span class="n">deg_f</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reverse degrees&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">col_num</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rotate_r</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">m</span><span class="p">[</span><span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">row2</span>

    <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="find_degree"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.find_degree">[docs]</a><span class="k">def</span> <span class="nf">find_degree</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">deg_f</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Finds the degree of the poly corresponding (after triangularization)</span>
<span class="sd">    to the _last_ row of the ``small&#39;&#39; matrix M, created by create_ma().</span>

<span class="sd">    deg_f is the degree of the divident poly.</span>
<span class="sd">    If _last_ row is all 0&#39;s returns None.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">deg_f</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">j</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="final_touches"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.final_touches">[docs]</a><span class="k">def</span> <span class="nf">final_touches</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    s2 is sylvester2, r is the row pointer in s2,</span>
<span class="sd">    deg_g is the degree of the poly last inserted in s2.</span>

<span class="sd">    After a gcd of degree &gt; 0 has been found with Van Vleck&#39;s</span>
<span class="sd">    method, and was inserted into s2, if its last term is not</span>
<span class="sd">    in the last column of s2, then it is inserted as many</span>
<span class="sd">    times as needed, rotated right by one each time, until</span>
<span class="sd">    the condition is met.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># find the first non zero term</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># missing rows until last term is in last column</span>
    <span class="n">mr</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">deg_g</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># insert them by replacing the existing entries in the row</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">mr</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="n">rows</span> <span class="p">:</span>
        <span class="n">s2</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="p">:</span> <span class="p">]</span> <span class="o">=</span> <span class="n">rotate_r</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">mr</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">s2</span></div>

<div class="viewcode-block" id="subresultants_vv"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.subresultants_vv">[docs]</a><span class="k">def</span> <span class="nf">subresultants_vv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the subresultant prs of p, q by triangularizing,</span>
<span class="sd">    in Z[x] or in Q[x], all the smaller matrices encountered in the</span>
<span class="sd">    process of triangularizing sylvester2, Sylvester&#39;s matrix of 1853;</span>
<span class="sd">    see references 1 and 2 for Van Vleck&#39;s method. With each remainder,</span>
<span class="sd">    sylvester2 gets updated and is prepared to be printed if requested.</span>

<span class="sd">    If sylvester2 has small dimensions and you want to see the final,</span>
<span class="sd">    triangularized matrix use this version with method=1; otherwise,</span>
<span class="sd">    use either this version with method=0 (default) or the faster version,</span>
<span class="sd">    subresultants_vv_2(p, q, x), where sylvester2 is used implicitly.</span>

<span class="sd">    Sylvester&#39;s matrix sylvester1  is also used to compute one</span>
<span class="sd">    subresultant per remainder; namely, that of the leading</span>
<span class="sd">    coefficient, in order to obtain the correct sign and to</span>
<span class="sd">    force the remainder coefficients to become subresultants.</span>

<span class="sd">    If the subresultant prs is complete, then it coincides with the</span>
<span class="sd">    Euclidean sequence of the polynomials p, q.</span>

<span class="sd">    If the final, triangularized matrix s2 is printed, then:</span>
<span class="sd">        (a) if deg(p) - deg(q) &gt; 1 or deg( gcd(p, q) ) &gt; 0, several</span>
<span class="sd">            of the last rows in s2 will remain unprocessed;</span>
<span class="sd">        (b) if deg(p) - deg(q) == 0, p will not appear in the final matrix.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G.: ``A new method for computing polynomial greatest</span>
<span class="sd">    common divisors and polynomial remainder sequences.&#39;&#39;</span>
<span class="sd">    Numerische MatheMatik 52, 119-127, 1988.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem</span>
<span class="sd">    by Van Vleck Regarding Sturm Sequences.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, 7, No 4, 101–134, 2013.</span>

<span class="sd">    3. Akritas, A. G.:``Three New Methods for Computing Subresultant</span>
<span class="sd">    Polynomial Remainder Sequences (PRS’s).&#39;&#39; Serdica Journal of Computing,</span>
<span class="sd">    to appear.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither p nor q is 0</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">deg_f</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">deg_g</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">deg_f</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">deg_f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>

    <span class="c1"># initialize</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">sylvester</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">sylvester</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">sr_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>
    <span class="n">col_num</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span>         <span class="c1"># columns in s2</span>

    <span class="c1"># make two rows (row0, row1) of poly coefficients</span>
    <span class="n">row0</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()</span>
    <span class="n">leng0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col_num</span> <span class="o">-</span> <span class="n">leng0</span><span class="p">):</span>
        <span class="n">row0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">row0</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">row0</span><span class="p">])</span>
    <span class="n">row1</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">x</span><span class="p">,</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()</span>
    <span class="n">leng1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col_num</span> <span class="o">-</span> <span class="n">leng1</span><span class="p">):</span>
        <span class="n">row1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">row1</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">row1</span><span class="p">])</span>

    <span class="c1"># row pointer for deg_f - deg_g == 1; may be reset below</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># modify first rows of s2 matrix depending on poly degrees</span>
    <span class="k">if</span> <span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># replacing the existing entries in the rows of s2,</span>
        <span class="c1"># insert row0 (deg_f - deg_g - 1) times, rotated each time</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">s2</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="p">:</span> <span class="p">]</span> <span class="o">=</span> <span class="n">rotate_r</span><span class="p">(</span><span class="n">row0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># insert row1 (deg_f - deg_g) times, rotated each time</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span><span class="p">):</span>
            <span class="n">s2</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="p">:</span> <span class="p">]</span> <span class="o">=</span> <span class="n">rotate_r</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span>

    <span class="k">if</span> <span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># main loop</span>
    <span class="k">while</span> <span class="n">deg_g</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># create a small matrix M, and triangularize it;</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">create_ma</span><span class="p">(</span><span class="n">deg_f</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">row1</span><span class="p">,</span> <span class="n">row0</span><span class="p">,</span> <span class="n">col_num</span><span class="p">)</span>
        <span class="c1"># will need only the first and last rows of M</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">M1</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M1</span><span class="p">[:,</span> <span class="p">:]</span>

        <span class="c1"># treat last row of M as poly; find its degree</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">find_degree</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">deg_f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">exp_deg</span> <span class="o">=</span> <span class="n">deg_g</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># evaluate one determinant &amp; make coefficients subresultants</span>
        <span class="n">sign_value</span> <span class="o">=</span> <span class="n">correct_sign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">exp_deg</span><span class="p">,</span> <span class="n">exp_deg</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">row2poly</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">temp2</span> <span class="o">=</span> <span class="n">LC</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">((</span><span class="n">poly</span> <span class="o">/</span> <span class="n">temp2</span><span class="p">)</span> <span class="o">*</span> <span class="n">sign_value</span><span class="p">)</span>

        <span class="c1"># update s2 by inserting first row of M as needed</span>
        <span class="n">row0</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_g</span> <span class="o">-</span> <span class="n">d</span><span class="p">):</span>
            <span class="n">s2</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rotate_r</span><span class="p">(</span><span class="n">row0</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">deg_g</span> <span class="o">-</span> <span class="n">d</span>

        <span class="c1"># update s2 by inserting last row of M as needed</span>
        <span class="n">row1</span> <span class="o">=</span> <span class="n">rotate_l</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">deg_f</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">row1</span> <span class="o">=</span> <span class="p">(</span><span class="n">row1</span> <span class="o">/</span> <span class="n">temp2</span><span class="p">)</span> <span class="o">*</span> <span class="n">sign_value</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_g</span> <span class="o">-</span> <span class="n">d</span><span class="p">):</span>
            <span class="n">s2</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rotate_r</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">deg_g</span> <span class="o">-</span> <span class="n">d</span>

        <span class="c1"># update degrees</span>
        <span class="n">deg_f</span><span class="p">,</span> <span class="n">deg_g</span> <span class="o">=</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">d</span>

        <span class="c1"># append poly with subresultant coeffs</span>
        <span class="n">sr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>

    <span class="c1"># final touches to print the s2 matrix</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s2</span><span class="o">.</span><span class="n">rows</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">final_touches</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">)</span>
        <span class="n">pprint</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s2</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rotate_r</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pprint</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sr_list</span></div>

<div class="viewcode-block" id="subresultants_vv_2"><a class="viewcode-back" href="../../../../modelparameters.sympy.polys.html#modelparameters.sympy.polys.subresultants_qq_zz.subresultants_vv_2">[docs]</a><span class="k">def</span> <span class="nf">subresultants_vv_2</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed</span>
<span class="sd">    that degree(p, x) &gt;= degree(q, x).</span>

<span class="sd">    Computes the subresultant prs of p, q by triangularizing,</span>
<span class="sd">    in Z[x] or in Q[x], all the smaller matrices encountered in the</span>
<span class="sd">    process of triangularizing sylvester2, Sylvester&#39;s matrix of 1853;</span>
<span class="sd">    see references 1 and 2 for Van Vleck&#39;s method.</span>

<span class="sd">    If the sylvester2 matrix has big dimensions use this version,</span>
<span class="sd">    where sylvester2 is used implicitly. If you want to see the final,</span>
<span class="sd">    triangularized matrix sylvester2, then use the first version,</span>
<span class="sd">    subresultants_vv(p, q, x, 1).</span>

<span class="sd">    sylvester1, Sylvester&#39;s matrix of 1840, is also used to compute</span>
<span class="sd">    one subresultant per remainder; namely, that of the leading</span>
<span class="sd">    coefficient, in order to obtain the correct sign and to</span>
<span class="sd">    ``force&#39;&#39; the remainder coefficients to become subresultants.</span>

<span class="sd">    If the subresultant prs is complete, then it coincides with the</span>
<span class="sd">    Euclidean sequence of the polynomials p, q.</span>

<span class="sd">    References:</span>
<span class="sd">    ===========</span>
<span class="sd">    1. Akritas, A. G.: ``A new method for computing polynomial greatest</span>
<span class="sd">    common divisors and polynomial remainder sequences.&#39;&#39;</span>
<span class="sd">    Numerische MatheMatik 52, 119-127, 1988.</span>

<span class="sd">    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem</span>
<span class="sd">    by Van Vleck Regarding Sturm Sequences.&#39;&#39;</span>
<span class="sd">    Serdica Journal of Computing, 7, No 4, 101–134, 2013.</span>

<span class="sd">    3. Akritas, A. G.:``Three New Methods for Computing Subresultant</span>
<span class="sd">    Polynomial Remainder Sequences (PRS’s).&#39;&#39; Serdica Journal of Computing,</span>
<span class="sd">    to appear.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure neither p nor q is 0</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>

    <span class="c1"># make sure proper degrees</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">deg_f</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">deg_g</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">deg_f</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">deg_f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>

    <span class="c1"># initialize</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">sylvester</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">sr_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">]</span>      <span class="c1"># subresultant list</span>
    <span class="n">col_num</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span>       <span class="c1"># columns in sylvester2</span>

    <span class="c1"># make two rows (row0, row1) of poly coefficients</span>
    <span class="n">row0</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()</span>
    <span class="n">leng0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col_num</span> <span class="o">-</span> <span class="n">leng0</span><span class="p">):</span>
        <span class="n">row0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">row0</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">row0</span><span class="p">])</span>
    <span class="n">row1</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">x</span><span class="p">,</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()</span>
    <span class="n">leng1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col_num</span> <span class="o">-</span> <span class="n">leng1</span><span class="p">):</span>
        <span class="n">row1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">row1</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">row1</span><span class="p">])</span>

    <span class="c1"># main loop</span>
    <span class="k">while</span> <span class="n">deg_g</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># create a small matrix M, and triangularize it</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">create_ma</span><span class="p">(</span><span class="n">deg_f</span><span class="p">,</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">row1</span><span class="p">,</span> <span class="n">row0</span><span class="p">,</span> <span class="n">col_num</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg_f</span> <span class="o">-</span> <span class="n">deg_g</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">M1</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">M1</span><span class="p">[:,</span> <span class="p">:]</span>

        <span class="c1"># treat last row of M as poly; find its degree</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">find_degree</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">deg_f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sr_list</span>
        <span class="n">exp_deg</span> <span class="o">=</span> <span class="n">deg_g</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># evaluate one determinant &amp; make coefficients subresultants</span>
        <span class="n">sign_value</span> <span class="o">=</span> <span class="n">correct_sign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">exp_deg</span><span class="p">,</span> <span class="n">exp_deg</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">row2poly</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">M</span><span class="o">.</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">((</span><span class="n">poly</span> <span class="o">/</span> <span class="n">LC</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">*</span> <span class="n">sign_value</span><span class="p">)</span>

        <span class="c1"># append poly with subresultant coeffs</span>
        <span class="n">sr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>

        <span class="c1"># update degrees and rows</span>
        <span class="n">deg_f</span><span class="p">,</span> <span class="n">deg_g</span> <span class="o">=</span> <span class="n">deg_g</span><span class="p">,</span> <span class="n">d</span>
        <span class="n">row0</span> <span class="o">=</span> <span class="n">row1</span>
        <span class="n">row1</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()</span>
        <span class="n">leng1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col_num</span> <span class="o">-</span> <span class="n">leng1</span><span class="p">):</span>
            <span class="n">row1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">row1</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">row1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">sr_list</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">modelparameters 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modelparameters.sympy.polys.subresultants_qq_zz</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Johan Hake, Henrik Finsberg.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>
  </body>
</html>