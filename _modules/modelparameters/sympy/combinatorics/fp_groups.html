
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>modelparameters.sympy.combinatorics.fp_groups &#8212; modelparameters 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/nature.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">modelparameters 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modelparameters.sympy.combinatorics.fp_groups</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for modelparameters.sympy.combinatorics.fp_groups</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Finitely Presented Groups and its algorithms. &quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">..core.basic</span> <span class="kn">import</span> <span class="n">Basic</span>
<span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Mod</span>
<span class="kn">from</span> <span class="nn">..printing.defaults</span> <span class="kn">import</span> <span class="n">DefaultPrinting</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="kn">import</span> <span class="n">public</span>
<span class="kn">from</span> <span class="nn">..utilities.iterables</span> <span class="kn">import</span> <span class="n">flatten</span>
<span class="kn">from</span> <span class="nn">.free_groups</span> <span class="kn">import</span> <span class="n">FreeGroupElement</span><span class="p">,</span> <span class="n">free_group</span><span class="p">,</span> <span class="n">zero_mul_simp</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span>


<div class="viewcode-block" id="fp_group"><a class="viewcode-back" href="../../../../modelparameters.sympy.combinatorics.html#modelparameters.sympy.combinatorics.fp_groups.fp_group">[docs]</a><span class="nd">@public</span>
<span class="k">def</span> <span class="nf">fp_group</span><span class="p">(</span><span class="n">fr_grp</span><span class="p">,</span> <span class="n">relators</span><span class="o">=</span><span class="p">[]):</span>
    <span class="n">_fp_group</span> <span class="o">=</span> <span class="n">FpGroup</span><span class="p">(</span><span class="n">fr_grp</span><span class="p">,</span> <span class="n">relators</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">_fp_group</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_fp_group</span><span class="o">.</span><span class="n">_generators</span><span class="p">)</span></div>

<div class="viewcode-block" id="xfp_group"><a class="viewcode-back" href="../../../../modelparameters.sympy.combinatorics.html#modelparameters.sympy.combinatorics.fp_groups.xfp_group">[docs]</a><span class="nd">@public</span>
<span class="k">def</span> <span class="nf">xfp_group</span><span class="p">(</span><span class="n">fr_grp</span><span class="p">,</span> <span class="n">relators</span><span class="o">=</span><span class="p">[]):</span>
    <span class="n">_fp_group</span> <span class="o">=</span> <span class="n">FpGroup</span><span class="p">(</span><span class="n">fr_grp</span><span class="p">,</span> <span class="n">relators</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">_fp_group</span><span class="p">,</span> <span class="n">_fp_group</span><span class="o">.</span><span class="n">_generators</span><span class="p">)</span></div>

<div class="viewcode-block" id="vfp_group"><a class="viewcode-back" href="../../../../modelparameters.sympy.combinatorics.html#modelparameters.sympy.combinatorics.fp_groups.vfp_group">[docs]</a><span class="nd">@public</span>
<span class="k">def</span> <span class="nf">vfp_group</span><span class="p">(</span><span class="n">fr_grpm</span><span class="p">,</span> <span class="n">relators</span><span class="p">):</span>
    <span class="n">_fp_group</span> <span class="o">=</span> <span class="n">FpGroup</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">relators</span><span class="p">)</span>
    <span class="n">pollute</span><span class="p">([</span><span class="n">sym</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">_fp_group</span><span class="o">.</span><span class="n">symbols</span><span class="p">],</span> <span class="n">_fp_group</span><span class="o">.</span><span class="n">generators</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_fp_group</span></div>


<span class="k">def</span> <span class="nf">_parse_relators</span><span class="p">(</span><span class="n">rels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse the passed relators.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">rels</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                           FINITELY PRESENTED GROUPS                         #</span>
<span class="c1">###############################################################################</span>


<span class="k">class</span> <span class="nc">FpGroup</span><span class="p">(</span><span class="n">DefaultPrinting</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The FpGroup would take a FreeGroup and a list/tuple of relators, the</span>
<span class="sd">    relators would be specified in such a way that each of them be equal to the</span>
<span class="sd">    identity of the provided free group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_group</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_FpGroup</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_PermutationGroup</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fr_grp</span><span class="p">,</span> <span class="n">relators</span><span class="p">):</span>
        <span class="n">relators</span> <span class="o">=</span> <span class="n">_parse_relators</span><span class="p">(</span><span class="n">relators</span><span class="p">)</span>
        <span class="c1"># return the corresponding FreeGroup if no relators are specified</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">relators</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fr_grp</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">free_group</span> <span class="o">=</span> <span class="n">fr_grp</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">relators</span> <span class="o">=</span> <span class="n">relators</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">generators</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_generators</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s2">&quot;FpGroupElement&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">FpGroupElement</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="p">})</span>

        <span class="c1"># CosetTable instance on identity subgroup</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_coset_table</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># returns whether coset table on identity subgroup</span>
        <span class="c1"># has been standardized</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_standardized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_generators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_group</span><span class="o">.</span><span class="n">generators</span>

    <span class="k">def</span> <span class="nf">subgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gens</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the subgroup generated by `gens` using the</span>
<span class="sd">        Reidemeister-Schreier algorithm</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">FreeGroupElement</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Generators must be `FreeGroupElement`s&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">group</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_group</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Given generators are not members of the group&quot;</span><span class="p">)</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">rels</span> <span class="o">=</span> <span class="n">reidemeister_presentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gens</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">FpGroup</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">group</span><span class="p">,</span> <span class="n">rels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">coset_enumeration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;relator_based&quot;</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an instance of ``coset table``, when Todd-Coxeter algorithm is</span>
<span class="sd">        run over the ``self`` with ``H`` as subgroup, using ``strategy``</span>
<span class="sd">        argument as strategy. The returned coset table is compressed but not</span>
<span class="sd">        standardized.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">max_cosets</span><span class="p">:</span>
            <span class="n">max_cosets</span> <span class="o">=</span> <span class="n">CosetTable</span><span class="o">.</span><span class="n">coset_table_max_limit</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;relator_based&#39;</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">coset_enumeration_r</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">max_cosets</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">coset_enumeration_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">max_cosets</span><span class="p">)</span>
        <span class="n">C</span><span class="o">.</span><span class="n">compress</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">C</span>

    <span class="k">def</span> <span class="nf">standardize_coset_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standardized the coset table ``self`` and makes the internal variable</span>
<span class="sd">        ``_is_standardized`` equal to ``True``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coset_table</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_standardized</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">coset_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;relator_based&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mathematical coset table of ``self`` in ``H``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">H</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_table</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_standardized</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">standardize_coset_table</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_enumeration</span><span class="p">([],</span> <span class="n">strategy</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_coset_table</span> <span class="o">=</span> <span class="n">C</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">standardize_coset_table</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_table</span><span class="o">.</span><span class="n">table</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_enumeration</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">strategy</span><span class="p">)</span>
            <span class="n">C</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span>

    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;relator_based&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the order of the finitely presented group ``self``. It uses</span>
<span class="sd">        the coset enumeration with identity group as subgroup, i.e ``H=[]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">        &gt;&gt;&gt; from .fp_groups import FpGroup</span>
<span class="sd">        &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = FpGroup(F, [x, y**2])</span>
<span class="sd">        &gt;&gt;&gt; f.order(strategy=&quot;coset_table_based&quot;)</span>
<span class="sd">        2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">gcd</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coset_table</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coset_table</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">array_form</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">relators</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_infinite</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gens</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finite_index_subgroup</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">C</span><span class="p">:</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">ind</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">subgroup</span><span class="p">(</span><span class="n">gens</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">([])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>

    <span class="k">def</span> <span class="nf">_is_infinite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Test if the group is infinite. Return `True` if the test succeeds</span>
<span class="sd">        and `None` otherwise</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Abelianisation test: check is the abelianisation is infinite</span>
        <span class="n">abelian_rels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="kn">from</span> <span class="nn">..polys.solvers</span> <span class="kn">import</span> <span class="n">RawMatrix</span> <span class="k">as</span> <span class="n">Matrix</span>
        <span class="kn">from</span> <span class="nn">..polys.domains</span> <span class="kn">import</span> <span class="n">ZZ</span>
        <span class="kn">from</span> <span class="nn">..matrices.normalforms</span> <span class="kn">import</span> <span class="n">invariant_factors</span>
        <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">relators</span><span class="p">:</span>
            <span class="n">abelian_rels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">rel</span><span class="o">.</span><span class="n">exponent_sum</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">])</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">abelian_rels</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">&quot;ring&quot;</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">invariant_factors</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">_finite_index_subgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Find the elements of `self` that generate a finite index subgroup</span>
<span class="sd">        and, if found, return the list of elements and the coset table of `self` by</span>
<span class="sd">        the subgroup, otherwise return `(None, None)`</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">most_frequent_generator</span><span class="p">()</span>
        <span class="n">rels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">)</span>
        <span class="n">rels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relators</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">rand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_group</span><span class="o">.</span><span class="n">identity</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">rand</span> <span class="ow">in</span> <span class="n">rels</span> <span class="ow">or</span> <span class="n">rand</span><span class="o">**-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">rels</span> <span class="ow">or</span> <span class="n">rand</span><span class="o">.</span><span class="n">is_identity</span>
                   <span class="ow">or</span> <span class="n">rand</span> <span class="ow">in</span> <span class="n">rels</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">:</span>
                <span class="n">rand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">gen</span><span class="p">,</span> <span class="n">rand</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span> <span class="k">if</span> <span class="n">g</span> <span class="o">!=</span> <span class="n">gen</span><span class="p">]</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">half1</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">mid</span><span class="p">]</span>
        <span class="n">half2</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">mid</span><span class="p">:]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">200</span>
        <span class="n">C</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">C</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">CosetTable</span><span class="o">.</span><span class="n">coset_table_max_limit</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">CosetTable</span><span class="o">.</span><span class="n">coset_table_max_limit</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_enumeration</span><span class="p">(</span><span class="n">half1</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
                <span class="n">half</span> <span class="o">=</span> <span class="n">half1</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">C</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_enumeration</span><span class="p">(</span><span class="n">half2</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
                    <span class="n">half</span> <span class="o">=</span> <span class="n">half2</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">*=</span> <span class="mi">2</span>
                    <span class="k">continue</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">C</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">half</span><span class="p">,</span> <span class="n">C</span>

    <span class="k">def</span> <span class="nf">most_frequent_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="n">rels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relators</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">generator_count</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rels</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">gens</span><span class="p">[</span><span class="n">freqs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">freqs</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">random_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">random</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_group</span><span class="o">.</span><span class="n">identity</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">)</span><span class="o">**</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;relator_based&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the index of subgroup ``H`` in group ``self``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">        &gt;&gt;&gt; from .fp_groups import FpGroup</span>
<span class="sd">        &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = FpGroup(F, [x**5, y**4, y*x*y**3*x**3])</span>
<span class="sd">        &gt;&gt;&gt; f.index([x])</span>
<span class="sd">        4</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: use |G:H| = |G|/|H| (currently H can&#39;t be made into a group)</span>
        <span class="c1"># when we know |G| and |H|</span>

        <span class="k">if</span> <span class="n">H</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_enumeration</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">strategy</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_group</span><span class="o">.</span><span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
            <span class="n">str_form</span> <span class="o">=</span> <span class="s2">&quot;&lt;fp group with </span><span class="si">%s</span><span class="s2"> generators&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_group</span><span class="o">.</span><span class="n">rank</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">str_form</span> <span class="o">=</span> <span class="s2">&quot;&lt;fp group on the generators </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">str_form</span>

    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                           COSET TABLE                                       #</span>
<span class="c1">###############################################################################</span>

<span class="k">class</span> <span class="nc">CosetTable</span><span class="p">(</span><span class="n">DefaultPrinting</span><span class="p">):</span>
    <span class="c1"># coset_table: Mathematically a coset table</span>
    <span class="c1">#               represented using a list of lists</span>
    <span class="c1"># alpha: Mathematically a coset (precisely, a live coset)</span>
    <span class="c1">#       represented by an integer between i with 1 &lt;= i &lt;= n</span>
    <span class="c1">#       α ∈ c</span>
    <span class="c1"># x: Mathematically an element of &quot;A&quot; (set of generators and</span>
    <span class="c1">#   their inverses), represented using &quot;FpGroupElement&quot;</span>
    <span class="c1"># fp_grp: Finitely Presented Group with &lt; X|R &gt; as presentation.</span>
    <span class="c1"># H: subgroup of fp_grp.</span>
    <span class="c1"># NOTE: We start with H as being only a list of words in generators</span>
    <span class="c1">#       of &quot;fp_grp&quot;. Since `.subgroup` method has not been implemented.</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Properties</span>
<span class="sd">    ==========</span>

<span class="sd">    [1] `0 \in \Omega` and `\tau(1) = \epsilon`</span>
<span class="sd">    [2] `\alpha^x = \beta \Leftrightarrow \beta^{x^{-1}} = \alpha`</span>
<span class="sd">    [3] If `\alpha^x = \beta`, then `H \tau(\alpha)x = H \tau(\beta)`</span>
<span class="sd">    [4] `\forall \alpha \in \Omega, 1^{\tau(\alpha)} = \alpha`</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    [1] Holt, D., Eick, B., O&#39;Brien, E.</span>
<span class="sd">    &quot;Handbook of Computational Group Theory&quot;</span>

<span class="sd">    [2] John J. Cannon; Lucien A. Dimino; George Havas; Jane M. Watson</span>
<span class="sd">    Mathematics of Computation, Vol. 27, No. 123. (Jul., 1973), pp. 463-490.</span>
<span class="sd">    &quot;Implementation and Analysis of the Todd-Coxeter Algorithm&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># default limit for the number of cosets allowed in a</span>
    <span class="c1"># coset enumeration.</span>
    <span class="n">coset_table_max_limit</span> <span class="o">=</span> <span class="mi">4096000</span>
    <span class="c1"># maximum size of deduction stack above or equal to</span>
    <span class="c1"># which it is emptied</span>
    <span class="n">max_stack_size</span> <span class="o">=</span> <span class="mi">500</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp_grp</span><span class="p">,</span> <span class="n">subgroup</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">max_cosets</span><span class="p">:</span>
            <span class="n">max_cosets</span> <span class="o">=</span> <span class="n">CosetTable</span><span class="o">.</span><span class="n">coset_table_max_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fp_group</span> <span class="o">=</span> <span class="n">fp_grp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subgroup</span> <span class="o">=</span> <span class="n">subgroup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coset_table_max_limit</span> <span class="o">=</span> <span class="n">max_cosets</span>
        <span class="c1"># &quot;p&quot; is setup independent of Ω and n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># a list of the form `[gen_1, gen_1^{-1}, ... , gen_k, gen_k^{-1}]`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">((</span><span class="n">gen</span><span class="p">,</span> <span class="n">gen</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span> \
                <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fp_group</span><span class="o">.</span><span class="n">generators</span><span class="p">))</span>
        <span class="c1"># the mathematical coset table which is a list of lists</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># used in the coset-table based method of coset enumeration. Each of</span>
        <span class="c1"># the element is called a &quot;deduction&quot; which is the form (α, x) whenever</span>
        <span class="c1"># a value is assigned to α^x during a definition or &quot;deduction process&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omega</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of live cosets. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">coset</span> <span class="k">for</span> <span class="n">coset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">coset</span><span class="p">]</span> <span class="o">==</span> <span class="n">coset</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a shallow copy of Coset Table instance ``self``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fp_group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subgroup</span><span class="p">)</span>
        <span class="n">self_copy</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">perm_rep</span><span class="p">)</span> <span class="k">for</span> <span class="n">perm_rep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">]</span>
        <span class="n">self_copy</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="n">self_copy</span><span class="o">.</span><span class="n">deduction_stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self_copy</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Coset Table on </span><span class="si">%s</span><span class="s2"> with </span><span class="si">%s</span><span class="s2"> as subgroup generators&quot;</span> \
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fp_group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subgroup</span><span class="p">)</span>

    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number `n` represents the length of the sublist containing the</span>
<span class="sd">        live cosets.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Pg. 152 [1]</span>
    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The coset table is called complete if it has no undefined entries</span>
<span class="sd">        on the live cosets; that is, `\alpha^x` is defined for all</span>
<span class="sd">        `\alpha \in \Omega` and `x \in A`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">coset</span><span class="p">]</span> <span class="k">for</span> <span class="n">coset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">])</span>

    <span class="c1"># Pg. 153 [1]</span>
    <span class="k">def</span> <span class="nf">define</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">coset_table_max_limit</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This routine is used in the relator-based strategy of Todd-Coxeter</span>
<span class="sd">        algorithm if some `\alpha^x` is undefined. We check whether there is</span>
<span class="sd">        space available for defining a new coset. If there is enough space</span>
<span class="sd">        then we remedy this by adjoining a new coset `\beta` to `\Omega`</span>
<span class="sd">        (i.e to set of live cosets) and put that equal to `\alpha^x`, then</span>
<span class="sd">        make an assignment satisfying Property[1]. If there is not enough space</span>
<span class="sd">        then we halt the Coset Table creation. The maximum amount of space that</span>
<span class="sd">        can be used by Coset Table can be manipulated using the class variable</span>
<span class="sd">        ``CosetTable.coset_table_max_limit``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        define_c</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">len_table</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len_table</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_table_max_limit</span><span class="p">:</span>
            <span class="c1"># abort the further generation of cosets</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the coset enumeration has defined more than &quot;</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> cosets. Try with a greater value max number of cosets &quot;</span>
                    <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_table_max_limit</span><span class="p">)</span>
        <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
        <span class="c1"># beta is the new coset generated</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">len_table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="n">table</span><span class="p">[</span><span class="n">beta</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="k">def</span> <span class="nf">define_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">coset_table_max_limit</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A variation of ``define`` routine, described on Pg. 165 [1], used in</span>
<span class="sd">        the coset table-based strategy of Todd-Coxeter algorithm. It differs</span>
<span class="sd">        from ``define`` routine in that for each definition it also adds the</span>
<span class="sd">        tuple `(\alpha, x)` to the deduction stack.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        define</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">len_table</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len_table</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_table_max_limit</span><span class="p">:</span>
            <span class="c1"># abort the further generation of cosets</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the coset enumeration has defined more than &quot;</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> cosets. Try with a greater value max number of cosets &quot;</span>
                    <span class="o">%</span> <span class="n">max_cosets</span><span class="p">)</span>
        <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
        <span class="c1"># beta is the new coset generated</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">len_table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="n">table</span><span class="p">[</span><span class="n">beta</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="c1"># append to deduction stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">scan_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A variation of ``scan`` routine, described on pg. 165 of [1], which</span>
<span class="sd">        puts at tuple, whenever a deduction occurs, to deduction stack.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        scan, scan_check, scan_and_fill, scan_and_fill_c</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># α is an integer representing a &quot;coset&quot;</span>
        <span class="c1"># since scanning can be in two cases</span>
        <span class="c1"># 1. for α=0 and w in Y (i.e generating set of H)</span>
        <span class="c1"># 2. α in Ω (set of live cosets), w in R (relators)</span>
        <span class="n">A_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span>
        <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># list of union of generators and their inverses</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coincidence_c</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
            <span class="c1"># we have an incorrect completed scan with coincidence f ~ b</span>
            <span class="c1"># run the &quot;coincidence&quot; routine</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coincidence_c</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="c1"># deduction process</span>
            <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">f</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="c1"># otherwise scan is incomplete and yields no information</span>

    <span class="c1"># α, β coincide, i.e. α, β represent the pair of cosets where</span>
    <span class="c1"># coincidence occurs</span>
    <span class="k">def</span> <span class="nf">coincidence_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A variation of ``coincidence`` routine used in the coset-table based</span>
<span class="sd">        method of coset enumeration. The only difference being on addition of</span>
<span class="sd">        a new coset in coset table(i.e new coset introduction), then it is</span>
<span class="sd">        appended to ``deduction_stack``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        coincidence</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span>
        <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># behaves as a queue</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A_dict</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">gamma</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">delta</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># only line of difference from ``coincidence`` routine</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">delta</span><span class="p">,</span> <span class="n">x</span><span class="o">**-</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rep</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
                    <span class="n">nu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rep</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">table</span><span class="p">[</span><span class="n">mu</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">table</span><span class="p">[</span><span class="n">mu</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]],</span> <span class="n">q</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">table</span><span class="p">[</span><span class="n">nu</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">table</span><span class="p">[</span><span class="n">nu</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]],</span> <span class="n">q</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">mu</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nu</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">nu</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mu</span>

    <span class="k">def</span> <span class="nf">scan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``scan`` performs a scanning process on the input ``word``.</span>
<span class="sd">        It first locates the largest prefix ``s`` of ``word`` for which</span>
<span class="sd">        `\alpha^s` is defined (i.e is not ``None``), ``s`` may be empty. Let</span>
<span class="sd">        ``word=sv``, let ``t`` be the longest suffix of ``v`` for which</span>
<span class="sd">        `\alpha^{t^{-1}}` is defined, and let ``v=ut``. Then three</span>
<span class="sd">        possibilities are there:</span>

<span class="sd">        1. If ``t=v``, then we say that the scan completes, and if, in addition</span>
<span class="sd">        `\alpha^s = \alpha^{t^{-1}}`, then we say that the scan completes</span>
<span class="sd">        correctly.</span>

<span class="sd">        2. It can also happen that scan does not complete, but `|u|=1`; that</span>
<span class="sd">        is, the word ``u`` consists of a single generator `x \in A`. In that</span>
<span class="sd">        case, if `\alpha^s = \beta` and `\alpha^{t^{-1}} = \gamma`, then we can</span>
<span class="sd">        set `\beta^x = \gamma` and `\gamma^{x^{-1}} = \beta`. These assignments</span>
<span class="sd">        are known as deductions and enable the scan to complete correctly.</span>

<span class="sd">        3. See ``coicidence`` routine for explanation of third condition.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>
<span class="sd">        The code for the procedure of scanning `\alpha \in \Omega`</span>
<span class="sd">        under `w \in A*` is defined on pg. 155 [1]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        scan_c, scan_check, scan_and_fill, scan_and_fill_c</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># α is an integer representing a &quot;coset&quot;</span>
        <span class="c1"># since scanning can be in two cases</span>
        <span class="c1"># 1. for α=0 and w in Y (i.e generating set of H)</span>
        <span class="c1"># 2. α in Ω (set of live cosets), w in R (relators)</span>
        <span class="n">A_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span>
        <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coincidence</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
            <span class="c1"># we have an incorrect completed scan with coincidence f ~ b</span>
            <span class="c1"># run the &quot;coincidence&quot; routine</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coincidence</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="c1"># deduction process</span>
            <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="c1"># otherwise scan is incomplete and yields no information</span>

    <span class="c1"># used in the low-index subgroups algorithm</span>
    <span class="k">def</span> <span class="nf">scan_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Another version of ``scan`` routine, described on, it checks whether</span>
<span class="sd">        `\alpha` scans correctly under `word`, it is a straightforward</span>
<span class="sd">        modification of ``scan``. ``scan_check`` returns ``False`` (rather than</span>
<span class="sd">        calling ``coincidence``) if the scan completes incorrectly; otherwise</span>
<span class="sd">        it returns ``True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        scan, scan_c, scan_and_fill, scan_and_fill_c</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># α is an integer representing a &quot;coset&quot;</span>
        <span class="c1"># since scanning can be in two cases</span>
        <span class="c1"># 1. for α=0 and w in Y (i.e generating set of H)</span>
        <span class="c1"># 2. α in Ω (set of live cosets), w in R (relators)</span>
        <span class="n">A_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span>
        <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span> <span class="o">==</span> <span class="n">b</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
            <span class="c1"># we have an incorrect completed scan with coincidence f ~ b</span>
            <span class="c1"># return False, instead of calling coincidence routine</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="c1"># deduction process</span>
            <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">lamda</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input: &#39;k&#39;, &#39;lamda&#39; being the two class representatives to be merged.</span>
<span class="sd">        =====</span>

<span class="sd">        Merge two classes with representatives ``k`` and ``lamda``, described</span>
<span class="sd">        on Pg. 157 [1] (for pseudocode), start by putting ``p[k] = lamda``.</span>
<span class="sd">        It is more efficient to choose the new representative from the larger</span>
<span class="sd">        of the two classes being merged, i.e larger among ``k`` and ``lamda``.</span>
<span class="sd">        procedure ``merge`` performs the merging operation, adds the deleted</span>
<span class="sd">        class representative to the queue ``q``.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>
<span class="sd">        Pg. 86-87 [1] contains a description of this method.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        coincidence, rep</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rep</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rep</span><span class="p">(</span><span class="n">lamda</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">phi</span> <span class="o">!=</span> <span class="n">psi</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span>
            <span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span>
            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input: `k \in [0 \ldots n-1]`, as for ``self`` only array ``p`` is used</span>
<span class="sd">        =====</span>
<span class="sd">        Output: Representative of the class containing ``k``.</span>
<span class="sd">        ======</span>

<span class="sd">        Returns the representative of `\sim` class containing ``k``, it also</span>
<span class="sd">        makes some modification to array ``p`` of ``self`` to ease further</span>
<span class="sd">        computations, described on Pg. 157 [1].</span>

<span class="sd">        The information on classes under `\sim` is stored in array `p` of</span>
<span class="sd">        ``self`` argument, which will always satisfy the property:</span>

<span class="sd">        `p[\alpha] \sim \alpha` and `p[\alpha]=\alpha \iff \alpha=rep(\alpha)`</span>
<span class="sd">        `\forall \in [0 \ldots n-1]`.</span>

<span class="sd">        So, for `\alpha \in [0 \ldots n-1]`, we find `rep(self, \alpha)` by</span>
<span class="sd">        continually replacing `\alpha` by `p[\alpha]` until it becomes</span>
<span class="sd">        constant (i.e satisfies `p[\alpha] = \alpha`):w</span>

<span class="sd">        To increase the efficiency of later ``rep`` calculations, whenever we</span>
<span class="sd">        find `rep(self, \alpha)=\beta`, we set</span>
<span class="sd">        `p[\gamma] = \beta \forall \gamma \in p-chain` from `\alpha` to `\beta`</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>
<span class="sd">        ``rep`` routine is also described on Pg. 85-87 [1] in Atkinson&#39;s</span>
<span class="sd">        algorithm, this results from the fact that ``coincidence`` routine</span>
<span class="sd">        introduces functionality similar to that introduced by the</span>
<span class="sd">        ``minimal_block`` routine on Pg. 85-87 [1].</span>

<span class="sd">        See also</span>
<span class="sd">        ========</span>
<span class="sd">        coincidence, merge</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">lamda</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">lamda</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">rho</span> <span class="o">!=</span> <span class="n">lamda</span><span class="p">:</span>
            <span class="n">lamda</span> <span class="o">=</span> <span class="n">rho</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">lamda</span><span class="p">]</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">mu</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">rho</span> <span class="o">!=</span> <span class="n">lamda</span><span class="p">:</span>
            <span class="n">p</span><span class="p">[</span><span class="n">mu</span><span class="p">]</span> <span class="o">=</span> <span class="n">lamda</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">rho</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">mu</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">lamda</span>

    <span class="c1"># α, β coincide, i.e. α, β represent the pair of cosets</span>
    <span class="c1"># where coincidence occurs</span>
    <span class="k">def</span> <span class="nf">coincidence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The third situation described in ``scan`` routine is handled by this</span>
<span class="sd">        routine, described on Pg. 156-161 [1].</span>

<span class="sd">        The unfortunate situation when the scan completes but not correctly,</span>
<span class="sd">        then ``coincidence`` routine is run. i.e when for some `i` with</span>
<span class="sd">        `1 \le i \le r+1`, we have `w=st` with `s=x_1*x_2 ... x_{i-1}`,</span>
<span class="sd">        `t=x_i*x_{i+1} ... x_r`, and `\beta = \alpha^s` and</span>
<span class="sd">        `\gamma = \alph^{t-1}` are defined but unequal. This means that</span>
<span class="sd">        `\beta` and `\gamma` represent the same coset of `H` in `G`. Described</span>
<span class="sd">        on Pg. 156 [1]. ``rep``</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        scan</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span>
        <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># behaves as a queue</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A_dict</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">gamma</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">delta</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rep</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
                    <span class="n">nu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rep</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">table</span><span class="p">[</span><span class="n">mu</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">table</span><span class="p">[</span><span class="n">mu</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]],</span> <span class="n">q</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">table</span><span class="p">[</span><span class="n">nu</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">table</span><span class="p">[</span><span class="n">nu</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]],</span> <span class="n">q</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">mu</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nu</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">nu</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mu</span>

    <span class="c1"># method used in the HLT strategy</span>
    <span class="k">def</span> <span class="nf">scan_and_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">coset_table_max_limit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A modified version of ``scan`` routine used in the relator-based</span>
<span class="sd">        method of coset enumeration, described on pg. 162-163 [1], which</span>
<span class="sd">        follows the idea that whenever the procedure is called and the scan</span>
<span class="sd">        is incomplete then it makes new definitions to enable the scan to</span>
<span class="sd">        complete; i.e it fills in the gaps in the scan of the relator or</span>
<span class="sd">        subgroup generator.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span>
        <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># loop until it has filled the α row in the table.</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># do the forward scanning</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coincidence</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="c1"># forward scan was incomplete, scan backwards</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coincidence</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">max_cosets</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">scan_and_fill_c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">coset_table_max_limit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A modified version of ``scan`` routine, described on Pg. 165 second</span>
<span class="sd">        para. [1], with modification similar to that of ``scan_anf_fill`` the</span>
<span class="sd">        only difference being it calls the coincidence procedure used in the</span>
<span class="sd">        coset-table based method i.e. the routine ``coincidence_c`` is used.</span>

<span class="sd">        Also See</span>
<span class="sd">        ========</span>
<span class="sd">        scan, scan_and_fill</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span>
        <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># loop until it has filled the α row in the table.</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># do the forward scanning</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coincidence_c</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="c1"># forward scan was incomplete, scan backwards</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coincidence_c</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">table</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">f</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">define_c</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">max_cosets</span><span class="p">)</span>

    <span class="c1"># method used in the HLT strategy</span>
    <span class="k">def</span> <span class="nf">look_ahead</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When combined with the HLT method this is known as HLT+Lookahead</span>
<span class="sd">        method of coset enumeration, described on pg. 164 [1]. Whenever</span>
<span class="sd">        ``define`` aborts due to lack of space available this procedure is</span>
<span class="sd">        executed. This routine helps in recovering space resulting from</span>
<span class="sd">        &quot;coincidence&quot; of cosets.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fp_group</span><span class="o">.</span><span class="n">relators</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="c1"># complete scan all relators under all cosets(obviously live)</span>
        <span class="c1"># without making new definitions</span>
        <span class="k">for</span> <span class="n">beta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">R</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">beta</span><span class="p">:</span>
                    <span class="k">break</span>

    <span class="c1"># Pg. 166</span>
    <span class="k">def</span> <span class="nf">process_deductions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_c_x</span><span class="p">,</span> <span class="n">R_c_x_inv</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Processes the deductions that have been pushed onto ``deduction_stack``,</span>
<span class="sd">        described on Pg. 166 [1] and is used in coset-table based enumeration.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        deduction_stack</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">CosetTable</span><span class="o">.</span><span class="n">max_stack_size</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">look_ahead</span><span class="p">()</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="p">[:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">==</span> <span class="n">alpha</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">R_c_x</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">scan_c</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">:</span>
                            <span class="k">break</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">beta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">p</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span> <span class="o">==</span> <span class="n">beta</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">R_c_x_inv</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scan_c</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">beta</span><span class="p">:</span>
                        <span class="k">break</span>

    <span class="k">def</span> <span class="nf">process_deductions_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R_c_x</span><span class="p">,</span> <span class="n">R_c_x_inv</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A variation of ``process_deductions``, this calls ``scan_check``</span>
<span class="sd">        wherever ``process_deductions`` calls ``scan``, described on Pg. [1].</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        process_deductions</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deduction_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">R_c_x</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_check</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">beta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">R_c_x_inv</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_check</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">switch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Switch the elements `\beta, \gamma \in \Omega` of ``self``, used</span>
<span class="sd">        by the ``standardize`` procedure, described on Pg. 167 [1].</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        standardize</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="n">A_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">gamma</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
            <span class="n">table</span><span class="p">[</span><span class="n">gamma</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">beta</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
            <span class="n">table</span><span class="p">[</span><span class="n">beta</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">z</span>
            <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">==</span> <span class="n">alpha</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">==</span> <span class="n">beta</span><span class="p">:</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">gamma</span>
                    <span class="k">elif</span> <span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">==</span> <span class="n">gamma</span><span class="p">:</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">beta</span>

    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A coset table is standardized if when running through the cosets and</span>
<span class="sd">        within each coset through the generator images (ignoring generator</span>
<span class="sd">        inverses), the cosets appear in order of the integers</span>
<span class="sd">        `0, 1, , \ldots, n`. &quot;Standardize&quot; reorders the elements of `\Omega`</span>
<span class="sd">        such that, if we scan the coset table first by elements of `\Omega`</span>
<span class="sd">        and then by elements of A, then the cosets occur in ascending order.</span>
<span class="sd">        ``standardize()`` is used at the end of an enumeration to permute the</span>
<span class="sd">        cosets so that they occur in some sort of standard order.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>
<span class="sd">        procedure is described on pg. 167-168 [1], it also makes use of the</span>
<span class="sd">        ``switch`` routine to replace by smaller integer value.</span>

<span class="sd">        &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">        &gt;&gt;&gt; from .fp_groups import FpGroup, coset_enumeration_r</span>
<span class="sd">        &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>

<span class="sd">        # Example 5.3 from [1]</span>
<span class="sd">        &gt;&gt;&gt; f = FpGroup(F, [x**2*y**2, x**3*y**5])</span>
<span class="sd">        &gt;&gt;&gt; C = coset_enumeration_r(f, [])</span>
<span class="sd">        &gt;&gt;&gt; C.compress()</span>
<span class="sd">        &gt;&gt;&gt; C.table</span>
<span class="sd">        [[1, 3, 1, 3], [2, 0, 2, 0], [3, 1, 3, 1], [0, 2, 0, 2]]</span>
<span class="sd">        &gt;&gt;&gt; C.standardize()</span>
<span class="sd">        &gt;&gt;&gt; C.table</span>
<span class="sd">        [[1, 2, 1, 2], [3, 0, 3, 0], [0, 3, 0, 3], [2, 1, 2, 1]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="n">A_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span>
        <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">A</span><span class="p">):</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;=</span> <span class="n">gamma</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;</span> <span class="n">gamma</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
                <span class="n">gamma</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">gamma</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
                    <span class="k">return</span>

    <span class="c1"># Compression of a Coset Table</span>
    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the non-live cosets from the coset table, described on</span>
<span class="sd">        pg. 167 [1].</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="n">A_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict</span>
        <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_dict_inv</span>
        <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="n">chi</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">gamma</span> <span class="o">!=</span> <span class="n">alpha</span><span class="p">:</span>
                <span class="c1"># replace α by γ in coset table</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
                    <span class="n">beta</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">gamma</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">beta</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">beta</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">==</span> <span class="n">gamma</span>
        <span class="c1"># all the cosets in the table are live cosets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">gamma</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># delete the useless coloumns</span>
        <span class="k">del</span> <span class="n">table</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">):]</span>
        <span class="c1"># re-define values</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)):</span>
                <span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">chi</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">conjugates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
        <span class="n">R_c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">((</span><span class="n">rel</span><span class="o">.</span><span class="n">cyclic_conjugates</span><span class="p">(),</span> \
                <span class="p">(</span><span class="n">rel</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cyclic_conjugates</span><span class="p">())</span> <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">R</span><span class="p">))</span>
        <span class="n">R_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">conjugate</span> <span class="ow">in</span> <span class="n">R_c</span><span class="p">:</span>
            <span class="n">R_set</span> <span class="o">=</span> <span class="n">R_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">conjugate</span><span class="p">)</span>
        <span class="n">R_c_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">R_set</span> <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">])</span>
            <span class="n">R_c_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">R_set</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R_c_list</span>

<span class="c1">###############################################################################</span>
<span class="c1">#                           COSET ENUMERATION                                 #</span>
<span class="c1">###############################################################################</span>

<span class="c1"># relator-based method</span>
<span class="k">def</span> <span class="nf">coset_enumeration_r</span><span class="p">(</span><span class="n">fp_grp</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is easier of the two implemented methods of coset enumeration.</span>
<span class="sd">    and is often called the HLT method, after Hazelgrove, Leech, Trotter</span>
<span class="sd">    The idea is that we make use of ``scan_and_fill`` makes new definitions</span>
<span class="sd">    whenever the scan is incomplete to enable the scan to complete; this way</span>
<span class="sd">    we fill in the gaps in the scan of the relator or subgroup generator,</span>
<span class="sd">    that&#39;s why the name relator-based method.</span>

<span class="sd">    # TODO: complete the docstring</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    scan_and_fill,</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    [1] Holt, D., Eick, B., O&#39;Brien, E.</span>
<span class="sd">    &quot;Handbook of computational group theory&quot;</span>

<span class="sd">    &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">    &gt;&gt;&gt; from .fp_groups import FpGroup, coset_enumeration_r</span>
<span class="sd">    &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>

<span class="sd">    # Example 5.1 from [1]</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**3, y**3, x**-1*y**-1*x*y])</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_r(f, [x])</span>
<span class="sd">    &gt;&gt;&gt; for i in range(len(C.p)):</span>
<span class="sd">    ...     if C.p[i] == i:</span>
<span class="sd">    ...         print(C.table[i])</span>
<span class="sd">    [0, 0, 1, 2]</span>
<span class="sd">    [1, 1, 2, 0]</span>
<span class="sd">    [2, 2, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; C.p</span>
<span class="sd">    [0, 1, 2, 1, 1]</span>

<span class="sd">    # Example from exercises Q2 [1]</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**2*y**2, y**-1*x*y*x**-3])</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_r(f, [])</span>
<span class="sd">    &gt;&gt;&gt; C.compress(); C.standardize()</span>
<span class="sd">    &gt;&gt;&gt; C.table</span>
<span class="sd">    [[1, 2, 3, 4],</span>
<span class="sd">    [5, 0, 6, 7],</span>
<span class="sd">    [0, 5, 7, 6],</span>
<span class="sd">    [7, 6, 5, 0],</span>
<span class="sd">    [6, 7, 0, 5],</span>
<span class="sd">    [2, 1, 4, 3],</span>
<span class="sd">    [3, 4, 2, 1],</span>
<span class="sd">    [4, 3, 1, 2]]</span>

<span class="sd">    # Example 5.2</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**2, y**3, (x*y)**3])</span>
<span class="sd">    &gt;&gt;&gt; Y = [x*y]</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_r(f, Y)</span>
<span class="sd">    &gt;&gt;&gt; for i in range(len(C.p)):</span>
<span class="sd">    ...     if C.p[i] == i:</span>
<span class="sd">    ...         print(C.table[i])</span>
<span class="sd">    [1, 1, 2, 1]</span>
<span class="sd">    [0, 0, 0, 2]</span>
<span class="sd">    [3, 3, 1, 0]</span>
<span class="sd">    [2, 2, 3, 3]</span>

<span class="sd">    # Example 5.3</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**2*y**2, x**3*y**5])</span>
<span class="sd">    &gt;&gt;&gt; Y = []</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_r(f, Y)</span>
<span class="sd">    &gt;&gt;&gt; for i in range(len(C.p)):</span>
<span class="sd">    ...     if C.p[i] == i:</span>
<span class="sd">    ...         print(C.table[i])</span>
<span class="sd">    [1, 3, 1, 3]</span>
<span class="sd">    [2, 0, 2, 0]</span>
<span class="sd">    [3, 1, 3, 1]</span>
<span class="sd">    [0, 2, 0, 2]</span>

<span class="sd">    # Example 5.4</span>
<span class="sd">    &gt;&gt;&gt; F, a, b, c, d, e = free_group(&quot;a, b, c, d, e&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [a*b*c**-1, b*c*d**-1, c*d*e**-1, d*e*a**-1, e*a*b**-1])</span>
<span class="sd">    &gt;&gt;&gt; Y = [a]</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_r(f, Y)</span>
<span class="sd">    &gt;&gt;&gt; for i in range(len(C.p)):</span>
<span class="sd">    ...     if C.p[i] == i:</span>
<span class="sd">    ...         print(C.table[i])</span>
<span class="sd">    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span>

<span class="sd">    # example of &quot;compress&quot; method</span>
<span class="sd">    &gt;&gt;&gt; C.compress()</span>
<span class="sd">    &gt;&gt;&gt; C.table</span>
<span class="sd">    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]</span>

<span class="sd">    # Exercises Pg. 161, Q2.</span>
<span class="sd">    &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**2*y**2, y**-1*x*y*x**-3])</span>
<span class="sd">    &gt;&gt;&gt; Y = []</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_r(f, Y)</span>
<span class="sd">    &gt;&gt;&gt; C.compress()</span>
<span class="sd">    &gt;&gt;&gt; C.standardize()</span>
<span class="sd">    &gt;&gt;&gt; C.table</span>
<span class="sd">    [[1, 2, 3, 4],</span>
<span class="sd">    [5, 0, 6, 7],</span>
<span class="sd">    [0, 5, 7, 6],</span>
<span class="sd">    [7, 6, 5, 0],</span>
<span class="sd">    [6, 7, 0, 5],</span>
<span class="sd">    [2, 1, 4, 3],</span>
<span class="sd">    [3, 4, 2, 1],</span>
<span class="sd">    [4, 3, 1, 2]]</span>

<span class="sd">    # John J. Cannon; Lucien A. Dimino; George Havas; Jane M. Watson</span>
<span class="sd">    # Mathematics of Computation, Vol. 27, No. 123. (Jul., 1973), pp. 463-490</span>
<span class="sd">    # from 1973chwd.pdf</span>
<span class="sd">    # Table 1. Ex. 1</span>
<span class="sd">    &gt;&gt;&gt; F, r, s, t = free_group(&quot;r, s, t&quot;)</span>
<span class="sd">    &gt;&gt;&gt; E1 = FpGroup(F, [t**-1*r*t*r**-2, r**-1*s*r*s**-2, s**-1*t*s*t**-2])</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_r(E1, [r])</span>
<span class="sd">    &gt;&gt;&gt; for i in range(len(C.p)):</span>
<span class="sd">    ...     if C.p[i] == i:</span>
<span class="sd">    ...         print(C.table[i])</span>
<span class="sd">    [0, 0, 0, 0, 0, 0]</span>

<span class="sd">    Ex. 2</span>
<span class="sd">    &gt;&gt;&gt; F, a, b = free_group(&quot;a, b&quot;)</span>
<span class="sd">    &gt;&gt;&gt; Cox = FpGroup(F, [a**6, b**6, (a*b)**2, (a**2*b**2)**2, (a**3*b**3)**5])</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_r(Cox, [a])</span>
<span class="sd">    &gt;&gt;&gt; index = 0</span>
<span class="sd">    &gt;&gt;&gt; for i in range(len(C.p)):</span>
<span class="sd">    ...     if C.p[i] == i:</span>
<span class="sd">    ...         index += 1</span>
<span class="sd">    &gt;&gt;&gt; index</span>
<span class="sd">    500</span>

<span class="sd">    # Ex. 3</span>
<span class="sd">    &gt;&gt;&gt; F, a, b = free_group(&quot;a, b&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B_2_4 = FpGroup(F, [a**4, b**4, (a*b)**4, (a**-1*b)**4, (a**2*b)**4, \</span>
<span class="sd">            (a*b**2)**4, (a**2*b**2)**4, (a**-1*b*a*b)**4, (a*b**-1*a*b)**4])</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_r(B_2_4, [a])</span>
<span class="sd">    &gt;&gt;&gt; index = 0</span>
<span class="sd">    &gt;&gt;&gt; for i in range(len(C.p)):</span>
<span class="sd">    ...     if C.p[i] == i:</span>
<span class="sd">    ...         index += 1</span>
<span class="sd">    &gt;&gt;&gt; index</span>
<span class="sd">    1024</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1. Initialize a coset table C for &lt; X|R &gt;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">CosetTable</span><span class="p">(</span><span class="n">fp_grp</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="n">max_cosets</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">fp_grp</span><span class="o">.</span><span class="n">relators</span>
    <span class="n">A_dict</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">A_dict</span>
    <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">A_dict_inv</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">p</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
        <span class="n">C</span><span class="o">.</span><span class="n">scan_and_fill</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="n">C</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">==</span> <span class="n">alpha</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">R</span><span class="p">:</span>
                <span class="n">C</span><span class="o">.</span><span class="n">scan_and_fill</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
                <span class="c1"># if α was eliminated during the scan then break</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">==</span> <span class="n">alpha</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A_dict</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">C</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">C</span>


<span class="c1"># Pg. 166</span>
<span class="c1"># coset-table based method</span>
<span class="k">def</span> <span class="nf">coset_enumeration_c</span><span class="p">(</span><span class="n">fp_grp</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">max_cosets</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">    &gt;&gt;&gt; from .fp_groups import FpGroup, coset_enumeration_c</span>
<span class="sd">    &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**3, y**3, x**-1*y**-1*x*y])</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_c(f, [x])</span>
<span class="sd">    &gt;&gt;&gt; C.table</span>
<span class="sd">    [[0, 0, 1, 2], [1, 1, 2, 0], [2, 2, 0, 1]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize a coset table C for &lt; X|R &gt;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">CosetTable</span><span class="p">(</span><span class="n">fp_grp</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">fp_grp</span><span class="o">.</span><span class="n">generators</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">fp_grp</span><span class="o">.</span><span class="n">relators</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">A</span>
    <span class="c1"># replace all the elements by cyclic reductions</span>
    <span class="n">R_cyc_red</span> <span class="o">=</span> <span class="p">[</span><span class="n">rel</span><span class="o">.</span><span class="n">identity_cyclic_reduction</span><span class="p">()</span> <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">R</span><span class="p">]</span>
    <span class="n">R_c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">((</span><span class="n">rel</span><span class="o">.</span><span class="n">cyclic_conjugates</span><span class="p">(),</span> <span class="p">(</span><span class="n">rel</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cyclic_conjugates</span><span class="p">())</span> \
            <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">R_cyc_red</span><span class="p">))</span>
    <span class="n">R_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">conjugate</span> <span class="ow">in</span> <span class="n">R_c</span><span class="p">:</span>
        <span class="n">R_set</span> <span class="o">=</span> <span class="n">R_set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">conjugate</span><span class="p">)</span>
    <span class="c1"># a list of subsets of R_c whose words start with &quot;x&quot;.</span>
    <span class="n">R_c_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">word</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">R_set</span> <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">])</span>
        <span class="n">R_c_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">R_set</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
        <span class="n">C</span><span class="o">.</span><span class="n">scan_and_fill_c</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="n">C</span><span class="o">.</span><span class="n">process_deductions</span><span class="p">(</span><span class="n">R_c_list</span><span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]],</span> <span class="n">R_c_list</span><span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]])</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">==</span> <span class="n">alpha</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">!=</span> <span class="n">alpha</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">C</span><span class="o">.</span><span class="n">define_c</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                    <span class="n">C</span><span class="o">.</span><span class="n">process_deductions</span><span class="p">(</span><span class="n">R_c_list</span><span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]],</span> <span class="n">R_c_list</span><span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]])</span>
        <span class="n">alpha</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">C</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                           LOW INDEX SUBGROUPS                               #</span>
<span class="c1">###############################################################################</span>

<span class="k">def</span> <span class="nf">low_index_subgroups</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the Low Index Subgroups algorithm, i.e find all subgroups of</span>
<span class="sd">    ``G`` upto a given index ``N``. This implements the method described in</span>
<span class="sd">    [Sim94]. This procedure involves a backtrack search over incomplete Coset</span>
<span class="sd">    Tables, rather than over forced coincidences.</span>

<span class="sd">    G: An FpGroup &lt; X|R &gt;</span>
<span class="sd">    N: positive integer, representing the maximun index value for subgroups</span>
<span class="sd">    Y: (an optional argument) specifying a list of subgroup generators, such</span>
<span class="sd">    that each of the resulting subgroup contains the subgroup generated by Y.</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    [1] Holt, D., Eick, B., O&#39;Brien, E.</span>
<span class="sd">    &quot;Handbook of Computational Group Theory&quot;</span>
<span class="sd">    Section 5.4</span>

<span class="sd">    [2] Marston Conder and Peter Dobcsanyi</span>
<span class="sd">    &quot;Applications and Adaptions of the Low Index Subgroups Procedure&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">    &gt;&gt;&gt; from .fp_groups import FpGroup, low_index_subgroups</span>
<span class="sd">    &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**2, y**3, (x*y)**4])</span>
<span class="sd">    &gt;&gt;&gt; L = low_index_subgroups(f, 4)</span>
<span class="sd">    &gt;&gt;&gt; for coset_table in L:</span>
<span class="sd">    ...     print(coset_table.table)</span>
<span class="sd">    [[0, 0, 0, 0]]</span>
<span class="sd">    [[0, 0, 1, 2], [1, 1, 2, 0], [3, 3, 0, 1], [2, 2, 3, 3]]</span>
<span class="sd">    [[0, 0, 1, 2], [2, 2, 2, 0], [1, 1, 0, 1]]</span>
<span class="sd">    [[1, 1, 0, 0], [0, 0, 1, 1]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">CosetTable</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">relators</span>
    <span class="c1"># length chosen for the length of the short relators</span>
    <span class="n">len_short_rel</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="c1"># elements of R2 only checked at the last step for complete</span>
    <span class="c1"># coset tables</span>
    <span class="n">R2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">rel</span> <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">R</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">len_short_rel</span><span class="p">])</span>
    <span class="c1"># elements of R1 are used in inner parts of the process to prune</span>
    <span class="c1"># branches of the search tree,</span>
    <span class="n">R1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">rel</span><span class="o">.</span><span class="n">identity_cyclic_reduction</span><span class="p">()</span> <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">-</span> <span class="n">R2</span><span class="p">])</span>
    <span class="n">R1_c_list</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conjugates</span><span class="p">(</span><span class="n">R1</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">descendant_subgroups</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R1_c_list</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">R2</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">S</span>


<span class="k">def</span> <span class="nf">descendant_subgroups</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R1_c_list</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="n">A_dict</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">A_dict</span>
    <span class="n">A_dict_inv</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">A_dict_inv</span>
    <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span>
        <span class="c1"># if C is complete then it only needs to test</span>
        <span class="c1"># whether the relators in R2 are satisfied</span>
        <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">omega</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">C</span><span class="o">.</span><span class="n">scan_check</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
                <span class="k">return</span>
        <span class="c1"># relators in R2 are satisfied, append the table to list</span>
        <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># find the first undefined entry in Coset Table</span>
        <span class="k">for</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">)),</span> <span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># this is &quot;x&quot; in pseudo-code (using &quot;y&quot; makes it clear)</span>
                <span class="n">undefined_coset</span><span class="p">,</span> <span class="n">undefined_gen</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span>
                <span class="k">break</span>
        <span class="c1"># for filling up the undefine entry we try all possible values</span>
        <span class="c1"># of β ∈ Ω or β = n where β^(undefined_gen^-1) is undefined</span>
        <span class="n">reach</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">omega</span> <span class="o">+</span> <span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">n</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">reach</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">beta</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beta</span> <span class="o">==</span> <span class="n">C</span><span class="o">.</span><span class="n">n</span> <span class="ow">or</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">beta</span><span class="p">][</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">undefined_gen</span><span class="p">]]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">try_descendant</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R1_c_list</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">undefined_coset</span><span class="p">,</span> \
                            <span class="n">undefined_gen</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">try_descendant</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">R1_c_list</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves the problem of trying out each individual possibility</span>
<span class="sd">    for `\alpha^x.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">A_dict</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">A_dict</span>
    <span class="k">if</span> <span class="n">beta</span> <span class="o">==</span> <span class="n">D</span><span class="o">.</span><span class="n">n</span> <span class="ow">and</span> <span class="n">beta</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">D</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">A</span><span class="p">))</span>
        <span class="n">D</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
    <span class="n">D</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">D</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">beta</span>
    <span class="n">D</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">beta</span><span class="p">][</span><span class="n">D</span><span class="o">.</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">alpha</span>
    <span class="n">D</span><span class="o">.</span><span class="n">deduction_stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">D</span><span class="o">.</span><span class="n">process_deductions_check</span><span class="p">(</span><span class="n">R1_c_list</span><span class="p">[</span><span class="n">D</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]],</span> \
            <span class="n">R1_c_list</span><span class="p">[</span><span class="n">D</span><span class="o">.</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]):</span>
        <span class="k">return</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">D</span><span class="o">.</span><span class="n">scan_check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
            <span class="k">return</span>
    <span class="k">if</span> <span class="n">first_in_class</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
        <span class="n">descendant_subgroups</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">R1_c_list</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">first_in_class</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks whether the subgroup ``H=G1`` corresponding to the Coset Table</span>
<span class="sd">    could possibly be the canonical representative of its conjugacy class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    C: CosetTable</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    bool: True/False</span>

<span class="sd">    If this returns False, then no descendant of C can have that property, and</span>
<span class="sd">    so we can abandon C. If it returns True, then we need to process further</span>
<span class="sd">    the node of the search tree corresponding to C, and so we call</span>
<span class="sd">    ``descendant_subgroups`` recursively on C.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">    &gt;&gt;&gt; from .fp_groups import FpGroup, CosetTable, first_in_class</span>
<span class="sd">    &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**2, y**3, (x*y)**4])</span>
<span class="sd">    &gt;&gt;&gt; C = CosetTable(f, [])</span>
<span class="sd">    &gt;&gt;&gt; C.table = [[0, 0, None, None]]</span>
<span class="sd">    &gt;&gt;&gt; first_in_class(C)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; C.table = [[1, 1, 1, None], [0, 0, None, 1]]; C.p = [0, 1]</span>
<span class="sd">    &gt;&gt;&gt; first_in_class(C)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; C.table = [[1, 1, 2, 1], [0, 0, 0, None], [None, None, None, 0]]</span>
<span class="sd">    &gt;&gt;&gt; C.p = [0, 1, 2]</span>
<span class="sd">    &gt;&gt;&gt; first_in_class(C)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; C.table = [[1, 1, 1, 2], [0, 0, 2, 0], [2, None, 0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; first_in_class(C)</span>
<span class="sd">    False</span>

<span class="sd">    # TODO:: Sims points out in [Sim94] that performance can be improved by</span>
<span class="sd">    # remembering some of the information computed by ``first_in_class``. If</span>
<span class="sd">    # the ``continue α`` statement is executed at line 14, then the same thing</span>
<span class="sd">    # will happen for that value of α in any descendant of the table C, and so</span>
<span class="sd">    # the values the values of α for which this occurs could profitably be</span>
<span class="sd">    # stored and passed through to the descendants of C. Of course this would</span>
<span class="sd">    # make the code more complicated.</span>

<span class="sd">    # The code below is taken directly from the function on page 208 of [Sim94]</span>
<span class="sd">    # ν[α]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">n</span>
    <span class="c1"># lamda is the largest numbered point in Ω_c_α which is currently defined</span>
    <span class="n">lamda</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># for α ∈ Ω_c, ν[α] is the point in Ω_c_α corresponding to α</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="c1"># for α ∈ Ω_c_α, μ[α] is the point in Ω_c corresponding to α</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="c1"># mutually ν and μ are the mutually-inverse equivalence maps between</span>
    <span class="c1"># Ω_c_α and Ω_c</span>
    <span class="n">next_alpha</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># For each 0≠α ∈ [0 .. nc-1], we start by constructing the equivalent</span>
    <span class="c1"># standardized coset table C_α corresponding to H_α</span>
    <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="c1"># reset ν to &quot;None&quot; after previous value of α</span>
        <span class="k">for</span> <span class="n">beta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lamda</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">nu</span><span class="p">[</span><span class="n">mu</span><span class="p">[</span><span class="n">beta</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># we only want to reject our current table in favour of a preceding</span>
        <span class="c1"># table in the ordering in which 1 is replaced by α, if the subgroup</span>
        <span class="c1"># G_α corresponding to this preceding table definitely contains the</span>
        <span class="c1"># given subgroup</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Y</span><span class="p">:</span>
            <span class="c1"># TODO: this should support input of a list of general words</span>
            <span class="c1"># not just the words which are in &quot;A&quot; (i.e gen and gen^-1)</span>
            <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">w</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">alpha</span><span class="p">:</span>
                <span class="c1"># continue with α</span>
                <span class="n">next_alpha</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">next_alpha</span><span class="p">:</span>
            <span class="n">next_alpha</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">continue</span>
        <span class="c1"># try α as the new point 0 in Ω_C_α</span>
        <span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">nu</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># compare corresponding entries in C and C_α</span>
        <span class="n">lamda</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">beta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">beta</span><span class="p">][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">mu</span><span class="p">[</span><span class="n">beta</span><span class="p">]][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
                <span class="c1"># if either of the entries is undefined,</span>
                <span class="c1"># we move with next α</span>
                <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">delta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># continue with α</span>
                    <span class="n">next_alpha</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">nu</span><span class="p">[</span><span class="n">delta</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># delta becomes the next point in Ω_C_α</span>
                    <span class="n">lamda</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">nu</span><span class="p">[</span><span class="n">delta</span><span class="p">]</span> <span class="o">=</span> <span class="n">lamda</span>
                    <span class="n">mu</span><span class="p">[</span><span class="n">lamda</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span>
                <span class="k">if</span> <span class="n">nu</span><span class="p">[</span><span class="n">delta</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">gamma</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">nu</span><span class="p">[</span><span class="n">delta</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">gamma</span><span class="p">:</span>
                    <span class="c1"># continue with α</span>
                    <span class="n">next_alpha</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">next_alpha</span><span class="p">:</span>
                <span class="n">next_alpha</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                           SUBGROUP PRESENTATIONS                            #</span>
<span class="c1">###############################################################################</span>

<span class="c1"># Pg 175 [1]</span>
<span class="k">def</span> <span class="nf">define_schreier_generators</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">fp_group</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">generators</span>
    <span class="n">C</span><span class="o">.</span><span class="n">P</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">):</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">beta</span> <span class="o">==</span> <span class="n">gamma</span><span class="p">:</span>
            <span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;&lt;identity&gt;&quot;</span>
            <span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">beta</span><span class="p">][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict_inv</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;&lt;identity&gt;&quot;</span>
            <span class="n">gamma</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span> <span class="ow">and</span> <span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_alpha_x</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_alpha_x</span><span class="p">)</span>
            <span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span> <span class="n">y_alpha_x</span>
    <span class="n">grp_gens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">free_group</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_schreier_free_group</span> <span class="o">=</span> <span class="n">grp_gens</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span> <span class="o">=</span> <span class="n">grp_gens</span>
    <span class="c1"># replace all elements of P by, free group elements</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">)),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">))):</span>
        <span class="c1"># if equals &quot;&lt;identity&gt;&quot;, replace by identity element</span>
        <span class="k">if</span> <span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&lt;identity&gt;&quot;</span><span class="p">:</span>
            <span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_free_group</span><span class="o">.</span><span class="n">identity</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span><span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span>
            <span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">beta</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">**-</span><span class="mi">1</span>


<span class="k">def</span> <span class="nf">reidemeister_relators</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">fp_group</span><span class="o">.</span><span class="n">relators</span>
    <span class="n">rels</span> <span class="o">=</span> <span class="p">[</span><span class="n">rewrite</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">coset</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">R</span> <span class="k">for</span> <span class="n">coset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">identity</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_free_group</span><span class="o">.</span><span class="n">identity</span>
    <span class="n">order_1_gens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rels</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># remove all the order 1 generators from relators</span>
    <span class="n">rels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">rel</span><span class="p">:</span> <span class="n">rel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">order_1_gens</span><span class="p">,</span> <span class="n">rels</span><span class="p">))</span>

    <span class="c1"># replace order 1 generators by identity element in reidemeister relators</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rels</span><span class="p">)):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">rels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">order_1_gens</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">eliminate_word</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">identity</span><span class="p">)</span>
        <span class="n">rels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>

    <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">order_1_gens</span><span class="p">]</span>

    <span class="c1"># Tietze transformation 1 i.e TT_1</span>
    <span class="c1"># remove cyclic conjugate elements from relators</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">rels</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">rels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">rels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">is_cyclic_conjugate</span><span class="p">(</span><span class="n">rels</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                <span class="k">del</span> <span class="n">rels</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span> <span class="o">=</span> <span class="n">rels</span>


<span class="k">def</span> <span class="nf">rewrite</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    C: CosetTable</span>
<span class="sd">    α: A live coset</span>
<span class="sd">    w: A word in `A*`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    ρ(τ(α), w)</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from .fp_groups import FpGroup, CosetTable, define_schreier_generators, rewrite</span>
<span class="sd">    &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">    &gt;&gt;&gt; F, x, y = free_group(&quot;x ,y&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**2, y**3, (x*y)**6])</span>
<span class="sd">    &gt;&gt;&gt; C = CosetTable(f, [])</span>
<span class="sd">    &gt;&gt;&gt; C.table = [[1, 1, 2, 3], [0, 0, 4, 5], [4, 4, 3, 0], [5, 5, 0, 2], [2, 2, 5, 1], [3, 3, 1, 4]]</span>
<span class="sd">    &gt;&gt;&gt; C.p = [0, 1, 2, 3, 4, 5]</span>
<span class="sd">    &gt;&gt;&gt; define_schreier_generators(C)</span>
<span class="sd">    &gt;&gt;&gt; rewrite(C, 0, (x*y)**6)</span>
<span class="sd">    x_4*y_2*x_3*x_1*x_2*y_4*x_5</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_free_group</span><span class="o">.</span><span class="n">identity</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)):</span>
        <span class="n">x_i</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">P</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x_i</span><span class="p">]]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">alpha</span><span class="p">][</span><span class="n">C</span><span class="o">.</span><span class="n">A_dict</span><span class="p">[</span><span class="n">x_i</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">v</span>


<span class="c1"># Pg 350, section 2.5.1 from [2]</span>
<span class="k">def</span> <span class="nf">elimination_technique_1</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="n">rels</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span>
    <span class="c1"># the shorter relators are examined first so that generators selected for</span>
    <span class="c1"># elimination will have shorter strings as equivalent</span>
    <span class="n">rels</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">gens</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span>
    <span class="n">redundant_gens</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">redundant_rels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">used_gens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="c1"># examine each relator in relator list for any generator occuring exactly</span>
    <span class="c1"># once</span>
    <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">rels</span><span class="p">:</span>
        <span class="c1"># don&#39;t look for a redundant generator in a relator which</span>
        <span class="c1"># depends on previously found ones</span>
        <span class="n">contained_gens</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">contains_generators</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">g</span> <span class="ow">in</span> <span class="n">contained_gens</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">redundant_gens</span><span class="p">]):</span>
            <span class="k">continue</span>
        <span class="n">contained_gens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">contained_gens</span><span class="p">)</span>
        <span class="n">contained_gens</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">contained_gens</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rel</span><span class="o">.</span><span class="n">generator_count</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">gen</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_gens</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">exponent_sum</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
                <span class="n">gen_index</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">gen</span><span class="o">**</span><span class="n">k</span><span class="p">)</span>
                <span class="n">bk</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">subword</span><span class="p">(</span><span class="n">gen_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel</span><span class="p">))</span>
                <span class="n">fw</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">subword</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gen_index</span><span class="p">)</span>
                <span class="n">chi</span> <span class="o">=</span> <span class="p">(</span><span class="n">bk</span><span class="o">*</span><span class="n">fw</span><span class="p">)</span><span class="o">.</span><span class="n">identity_cyclic_reduction</span><span class="p">()</span>
                <span class="n">redundant_gens</span><span class="p">[</span><span class="n">gen</span><span class="p">]</span> <span class="o">=</span> <span class="n">chi</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
                <span class="n">used_gens</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">chi</span><span class="o">.</span><span class="n">contains_generators</span><span class="p">())</span>
                <span class="n">redundant_rels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">)</span>
                <span class="k">break</span>
    <span class="n">rels</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rels</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">redundant_rels</span><span class="p">]</span>
    <span class="c1"># eliminate the redundant generators from remaining relators</span>
    <span class="n">rels</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">eliminate_words</span><span class="p">(</span><span class="n">redundant_gens</span><span class="p">,</span> <span class="n">_all</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">identity_cyclic_reduction</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rels</span><span class="p">]</span>
    <span class="n">rels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">rels</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">_schreier_free_group</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span> <span class="k">if</span> <span class="n">g</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">redundant_gens</span><span class="p">]</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span> <span class="o">=</span> <span class="n">rels</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span> <span class="o">=</span> <span class="n">gens</span>

<span class="c1"># Pg 350, section 2.5.2 from [2]</span>
<span class="k">def</span> <span class="nf">elimination_technique_2</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This technique eliminates one generator at a time. Heuristically this</span>
<span class="sd">    seems superior in that we may select for elimination the generator with</span>
<span class="sd">    shortest equivalent string at each stage.</span>

<span class="sd">    &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">    &gt;&gt;&gt; from .fp_groups import FpGroup, coset_enumeration_r, \</span>
<span class="sd">            reidemeister_relators, define_schreier_generators, elimination_technique_2</span>
<span class="sd">    &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**3, y**5, (x*y)**2]); H = [x*y, x**-1*y**-1*x*y*x]</span>
<span class="sd">    &gt;&gt;&gt; C = coset_enumeration_r(f, H)</span>
<span class="sd">    &gt;&gt;&gt; C.compress(); C.standardize()</span>
<span class="sd">    &gt;&gt;&gt; define_schreier_generators(C)</span>
<span class="sd">    &gt;&gt;&gt; reidemeister_relators(C)</span>
<span class="sd">    &gt;&gt;&gt; elimination_technique_2(C)</span>
<span class="sd">    ([y_1, y_2], [y_2**-3, y_2*y_1*y_2*y_1*y_2*y_1, y_1**2])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rels</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span>
    <span class="n">rels</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">gens</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">rels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">gen</span> <span class="o">=</span> <span class="n">gens</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rel</span><span class="o">.</span><span class="n">generator_count</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">exponent_sum</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
                <span class="n">gen_index</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">gen</span><span class="o">**</span><span class="n">k</span><span class="p">)</span>
                <span class="n">bk</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">subword</span><span class="p">(</span><span class="n">gen_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel</span><span class="p">))</span>
                <span class="n">fw</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">subword</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gen_index</span><span class="p">)</span>
                <span class="n">rep_by</span> <span class="o">=</span> <span class="p">(</span><span class="n">bk</span><span class="o">*</span><span class="n">fw</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">rels</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="k">del</span> <span class="n">gens</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rels</span><span class="p">)):</span>
                    <span class="n">rels</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">rels</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">eliminate_word</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">rep_by</span><span class="p">)</span>
                <span class="k">break</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span> <span class="o">=</span> <span class="n">rels</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span> <span class="o">=</span> <span class="n">gens</span>
    <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span>

<span class="k">def</span> <span class="nf">simplify_presentation</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Relies upon ``_simplification_technique_1`` for its functioning. &quot;&quot;&quot;</span>
    <span class="n">rels</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span>
    <span class="n">group</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_free_group</span>

    <span class="n">rels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">_simplification_technique_1</span><span class="p">(</span><span class="n">rels</span><span class="p">)))</span>
    <span class="n">rels</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">rels</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">identity_cyclic_reduction</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rels</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">_schreier_free_group</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span> <span class="o">=</span> <span class="n">rels</span>

<span class="k">def</span> <span class="nf">_simplification_technique_1</span><span class="p">(</span><span class="n">rels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    All relators are checked to see if they are of the form `gen^n`. If any</span>
<span class="sd">    such relators are found then all other relators are processed for strings</span>
<span class="sd">    in the `gen` known order.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">    &gt;&gt;&gt; from .fp_groups import _simplification_technique_1</span>
<span class="sd">    &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>
<span class="sd">    &gt;&gt;&gt; w1 = [x**2*y**4, x**3]</span>
<span class="sd">    &gt;&gt;&gt; _simplification_technique_1(w1)</span>
<span class="sd">    [x**-1*y**4, x**3]</span>

<span class="sd">    &gt;&gt;&gt; w2 = [x**2*y**-4*x**5, x**3, x**2*y**8, y**5]</span>
<span class="sd">    &gt;&gt;&gt; _simplification_technique_1(w2)</span>
<span class="sd">    [x**-1*y*x**-1, x**3, x**-1*y**-2, y**5]</span>

<span class="sd">    &gt;&gt;&gt; w3 = [x**6*y**4, x**4]</span>
<span class="sd">    &gt;&gt;&gt; _simplification_technique_1(w3)</span>
<span class="sd">    [x**2*y**4, x**4]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">gcd</span>

    <span class="n">rels</span> <span class="o">=</span> <span class="n">rels</span><span class="p">[:]</span>
    <span class="c1"># dictionary with &quot;gen: n&quot; where gen^n is one of the relators</span>
    <span class="n">exps</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rels</span><span class="p">)):</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">rels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rel</span><span class="o">.</span><span class="n">number_syllables</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rel</span><span class="o">.</span><span class="n">array_form</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">rel</span><span class="o">.</span><span class="n">array_form</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**-</span><span class="mi">1</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">**-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">exps</span><span class="p">:</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">exps</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="o">.</span><span class="n">array_form</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">exps</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">**</span><span class="n">exp</span>

    <span class="n">one_syllables_words</span> <span class="o">=</span> <span class="n">exps</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="c1"># decrease some of the exponents in relators, making use of the single</span>
    <span class="c1"># syllable relators</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rels</span><span class="p">)):</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">rels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">one_syllables_words</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">eliminate_words</span><span class="p">(</span><span class="n">one_syllables_words</span><span class="p">,</span> <span class="n">_all</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># if rels[i] contains g**n where abs(n) is greater than half of the power p</span>
        <span class="c1"># of g in exps, g**n can be replaced by g**(n-p) (or g**(p-n) if n&lt;0)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">rel</span><span class="o">.</span><span class="n">contains_generators</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">exps</span><span class="p">:</span>
                <span class="n">exp</span> <span class="o">=</span> <span class="n">exps</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="o">.</span><span class="n">array_form</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">max_exp</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
                <span class="n">rel</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">eliminate_word</span><span class="p">(</span><span class="n">g</span><span class="o">**</span><span class="p">(</span><span class="n">max_exp</span><span class="p">),</span> <span class="n">g</span><span class="o">**</span><span class="p">(</span><span class="n">max_exp</span><span class="o">-</span><span class="n">exp</span><span class="p">),</span> <span class="n">_all</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">rel</span> <span class="o">=</span> <span class="n">rel</span><span class="o">.</span><span class="n">eliminate_word</span><span class="p">(</span><span class="n">g</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">max_exp</span><span class="p">),</span> <span class="n">g</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">max_exp</span><span class="o">-</span><span class="n">exp</span><span class="p">)),</span> <span class="n">_all</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">rels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel</span>
    <span class="n">rels</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">identity_cyclic_reduction</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rels</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">rels</span>


<span class="k">def</span> <span class="nf">reidemeister_presentation</span><span class="p">(</span><span class="n">fp_grp</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fp_group: A finitely presented group, an instance of FpGroup</span>
<span class="sd">    H: A subgroup whose presentation is to be found, given as a list</span>
<span class="sd">    of words in generators of `fp_grp`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from .free_groups import free_group</span>
<span class="sd">    &gt;&gt;&gt; from .fp_groups import FpGroup, reidemeister_presentation</span>
<span class="sd">    &gt;&gt;&gt; F, x, y = free_group(&quot;x, y&quot;)</span>

<span class="sd">    Example 5.6 Pg. 177 from [1]</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**3, y**5, (x*y)**2])</span>
<span class="sd">    &gt;&gt;&gt; H = [x*y, x**-1*y**-1*x*y*x]</span>
<span class="sd">    &gt;&gt;&gt; reidemeister_presentation(f, H)</span>
<span class="sd">    ((y_1, y_2), (y_1**2, y_2**3, y_2*y_1*y_2*y_1*y_2*y_1))</span>

<span class="sd">    Example 5.8 Pg. 183 from [1]</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**3, y**3, (x*y)**3])</span>
<span class="sd">    &gt;&gt;&gt; H = [x*y, x*y**-1]</span>
<span class="sd">    &gt;&gt;&gt; reidemeister_presentation(f, H)</span>
<span class="sd">    ((x_0, y_0), (x_0**3, y_0**3, x_0*y_0*x_0*y_0*x_0*y_0))</span>

<span class="sd">    Exercises Q2. Pg 187 from [1]</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**2*y**2, y**-1*x*y*x**-3])</span>
<span class="sd">    &gt;&gt;&gt; H = [x]</span>
<span class="sd">    &gt;&gt;&gt; reidemeister_presentation(f, H)</span>
<span class="sd">    ((x_0,), (x_0**4,))</span>

<span class="sd">    Example 5.9 Pg. 183 from [1]</span>
<span class="sd">    &gt;&gt;&gt; f = FpGroup(F, [x**3*y**-3, (x*y)**3, (x*y**-1)**2])</span>
<span class="sd">    &gt;&gt;&gt; H = [x]</span>
<span class="sd">    &gt;&gt;&gt; reidemeister_presentation(f, H)</span>
<span class="sd">    ((x_0,), (x_0**6,))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">C</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">coset_enumeration_r</span><span class="p">(</span><span class="n">fp_grp</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
    <span class="n">C</span><span class="o">.</span><span class="n">compress</span><span class="p">();</span> <span class="n">C</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span>
    <span class="n">define_schreier_generators</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">reidemeister_relators</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
    <span class="n">prev_gens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">prev_rels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">prev_rels</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span><span class="p">):</span>
        <span class="n">prev_rels</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">prev_gens</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span><span class="p">):</span>
            <span class="n">prev_gens</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span>
            <span class="n">elimination_technique_1</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">simplify_presentation</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

    <span class="n">syms</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">array_form</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">free_group</span><span class="p">(</span><span class="n">syms</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">subs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">generators</span><span class="p">))</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">generators</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span><span class="p">)):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">identity</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
            <span class="n">rel</span> <span class="o">=</span> <span class="n">rel</span><span class="o">*</span><span class="n">subs</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">**</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel</span>

    <span class="n">C</span><span class="o">.</span><span class="n">schreier_generators</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">_schreier_generators</span><span class="p">)</span>
    <span class="n">C</span><span class="o">.</span><span class="n">reidemeister_relators</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">_reidemeister_relators</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">schreier_generators</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">reidemeister_relators</span>


<span class="n">FpGroupElement</span> <span class="o">=</span> <span class="n">FreeGroupElement</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">modelparameters 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modelparameters.sympy.combinatorics.fp_groups</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Johan Hake, Henrik Finsberg.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>