
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>modelparameters.sympy.plotting.experimental_lambdify &#8212; modelparameters 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/nature.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">modelparameters 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modelparameters.sympy.plotting.experimental_lambdify</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for modelparameters.sympy.plotting.experimental_lambdify</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; rewrite of lambdify - This stuff is not stable at all.</span>

<span class="sd">It is for internal use in the new plotting module.</span>
<span class="sd">It may (will! see the Q&#39;n&#39;A in the source) be rewritten.</span>

<span class="sd">It&#39;s completely self contained. Especially it does not use lambdarepr.</span>

<span class="sd">It does not aim to replace the current lambdify. Most importantly it will never</span>
<span class="sd">ever support anything else than sympy expressions (no Matrices, dictionaries</span>
<span class="sd">and so on).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">zoo</span><span class="p">,</span> <span class="n">oo</span>
<span class="kn">from</span> <span class="nn">..core.compatibility</span> <span class="kn">import</span> <span class="n">exec_</span>
<span class="kn">from</span> <span class="nn">..utilities.iterables</span> <span class="kn">import</span> <span class="n">numbered_symbols</span>

<span class="c1">#  We parse the expression string into a tree that identifies functions. Then</span>
<span class="c1"># we translate the names of the functions and we translate also some strings</span>
<span class="c1"># that are not names of functions (all this according to translation</span>
<span class="c1"># dictionaries).</span>
<span class="c1">#  If the translation goes to another module (like numpy) the</span>
<span class="c1"># module is imported and &#39;func&#39; is translated to &#39;module.func&#39;.</span>
<span class="c1">#  If a function can not be translated, the inner nodes of that part of the</span>
<span class="c1"># tree are not translated. So if we have Integral(sqrt(x)), sqrt is not</span>
<span class="c1"># translated to np.sqrt and the Integral does not crash.</span>
<span class="c1">#  A namespace for all this is generated by crawling the (func, args) tree of</span>
<span class="c1"># the expression. The creation of this namespace involves many ugly</span>
<span class="c1"># workarounds.</span>
<span class="c1">#  The namespace consists of all the names needed for the sympy expression and</span>
<span class="c1"># all the name of modules used for translation. Those modules are imported only</span>
<span class="c1"># as a name (import numpy as np) in order to keep the namespace small and</span>
<span class="c1"># manageable.</span>

<span class="c1">#  Please, if there is a bug, do not try to fix it here! Rewrite this by using</span>
<span class="c1"># the method proposed in the last Q&#39;n&#39;A below. That way the new function will</span>
<span class="c1"># work just as well, be just as simple, but it wont need any new workarounds.</span>
<span class="c1">#  If you insist on fixing it here, look at the workarounds in the function</span>
<span class="c1"># sympy_expression_namespace and in lambdify.</span>

<span class="c1"># Q: Why are you not using python abstract syntax tree?</span>
<span class="c1"># A: Because it is more complicated and not much more powerful in this case.</span>

<span class="c1"># Q: What if I have Symbol(&#39;sin&#39;) or g=Function(&#39;f&#39;)?</span>
<span class="c1"># A: You will break the algorithm. We should use srepr to defend against this?</span>
<span class="c1">#  The problem with Symbol(&#39;sin&#39;) is that it will be printed as &#39;sin&#39;. The</span>
<span class="c1"># parser will distinguish it from the function &#39;sin&#39; because functions are</span>
<span class="c1"># detected thanks to the opening parenthesis, but the lambda expression won&#39;t</span>
<span class="c1"># understand the difference if we have also the sin function.</span>
<span class="c1"># The solution (complicated) is to use srepr and maybe ast.</span>
<span class="c1">#  The problem with the g=Function(&#39;f&#39;) is that it will be printed as &#39;f&#39; but in</span>
<span class="c1"># the global namespace we have only &#39;g&#39;. But as the same printer is used in the</span>
<span class="c1"># constructor of the namespace there will be no problem.</span>

<span class="c1"># Q: What if some of the printers are not printing as expected?</span>
<span class="c1"># A: The algorithm wont work. You must use srepr for those cases. But even</span>
<span class="c1"># srepr may not print well. All problems with printers should be considered</span>
<span class="c1"># bugs.</span>

<span class="c1"># Q: What about _imp_ functions?</span>
<span class="c1"># A: Those are taken care for by evalf. A special case treatment will work</span>
<span class="c1"># faster but it&#39;s not worth the code complexity.</span>

<span class="c1"># Q: Will ast fix all possible problems?</span>
<span class="c1"># A: No. You will always have to use some printer. Even srepr may not work in</span>
<span class="c1"># some cases. But if the printer does not work, that should be considered a</span>
<span class="c1"># bug.</span>

<span class="c1"># Q: Is there same way to fix all possible problems?</span>
<span class="c1"># A: Probably by constructing our strings ourself by traversing the (func,</span>
<span class="c1"># args) tree and creating the namespace at the same time. That actually sounds</span>
<span class="c1"># good.</span>

<span class="kn">from</span> <span class="nn">..external</span> <span class="kn">import</span> <span class="n">import_module</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="c1">#TODO debuging output</span>


<div class="viewcode-block" id="vectorized_lambdify"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.vectorized_lambdify">[docs]</a><span class="k">class</span> <span class="nc">vectorized_lambdify</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return a sufficiently smart, vectorized and lambdified function.</span>

<span class="sd">    Returns only reals.</span>

<span class="sd">    This function uses experimental_lambdify to created a lambdified</span>
<span class="sd">    expression ready to be used with numpy. Many of the functions in sympy</span>
<span class="sd">    are not implemented in numpy so in some cases we resort to python cmath or</span>
<span class="sd">    even to evalf.</span>

<span class="sd">    The following translations are tried:</span>
<span class="sd">      only numpy complex</span>
<span class="sd">      - on errors raised by sympy trying to work with ndarray:</span>
<span class="sd">          only python cmath and then vectorize complex128</span>

<span class="sd">    When using python cmath there is no need for evalf or float/complex</span>
<span class="sd">    because python cmath calls those.</span>

<span class="sd">    This function never tries to mix numpy directly with evalf because numpy</span>
<span class="sd">    does not understand sympy Float. If this is needed one can use the</span>
<span class="sd">    float_wrap_evalf/complex_wrap_evalf options of experimental_lambdify or</span>
<span class="sd">    better one can be explicit about the dtypes that numpy works with.</span>
<span class="sd">    Check numpy bug http://projects.scipy.org/numpy/ticket/1013 to know what</span>
<span class="sd">    types of errors to expect.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span> <span class="o">=</span> <span class="n">experimental_lambdify</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">use_np</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vector_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failure</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">np</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
        <span class="n">np_old_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">temp_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_func</span><span class="p">(</span><span class="o">*</span><span class="n">temp_args</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">results</span><span class="p">),</span>
                                <span class="n">results</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1">#DEBUG: print &#39;Error&#39;, type(e), e</span>
            <span class="k">if</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span>
                 <span class="ow">and</span> <span class="s1">&#39;unhashable type: </span><span class="se">\&#39;</span><span class="s1">numpy.ndarray</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span>
                 <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;Invalid limits given:&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                      <span class="ow">or</span> <span class="s1">&#39;negative dimensions are not allowed&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># XXX</span>
                      <span class="ow">or</span> <span class="s1">&#39;sequence too large; must be smaller than 32&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)))):</span>  <span class="c1"># XXX</span>
                <span class="c1"># Almost all functions were translated to numpy, but some were</span>
                <span class="c1"># left as sympy functions. They recieved an ndarray as an</span>
                <span class="c1"># argument and failed.</span>
                <span class="c1">#   sin(ndarray(...)) raises &quot;unhashable type&quot;</span>
                <span class="c1">#   Integral(x, (x, 0, ndarray(...))) raises &quot;Invalid limits&quot;</span>
                <span class="c1">#   other ugly exceptions that are not well understood (marked with XXX)</span>
                <span class="c1"># TODO: Cleanup the ugly special cases marked with xxx above.</span>
                <span class="c1"># Solution: use cmath and vectorize the final lambda.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span> <span class="o">=</span> <span class="n">experimental_lambdify</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">use_python_cmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vector_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">])</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">results</span><span class="p">),</span>
                                <span class="n">results</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Complete failure. One last try with no translations, only</span>
                <span class="c1"># wrapping in complex((...).evalf()) and returning the real</span>
                <span class="c1"># part.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failure</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">failure</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span> <span class="o">=</span> <span class="n">experimental_lambdify</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">use_evalf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">complex_wrap_evalf</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vector_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">])</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">results</span><span class="p">),</span>
                            <span class="n">results</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The evaluation of the expression is&#39;</span>
                            <span class="s1">&#39; problematic. We are trying a failback method&#39;</span>
                            <span class="s1">&#39; that may still work. Please report this as a bug.&#39;</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">np_old_err</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="lambdify"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.lambdify">[docs]</a><span class="k">class</span> <span class="nc">lambdify</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the lambdified function.</span>

<span class="sd">    This function uses experimental_lambdify to create a lambdified</span>
<span class="sd">    expression. It uses cmath to lambdify the expression. If the function</span>
<span class="sd">    is not implemented in python cmath, python cmath calls evalf on those</span>
<span class="sd">    functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span> <span class="o">=</span> <span class="n">experimental_lambdify</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">use_evalf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">use_python_cmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failure</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#The result can be sympy.Float. Hence wrap it with complex type.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">real</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># The exceptions raised by sympy, cmath are not consistent and</span>
            <span class="c1"># hence it is not possible to specify all the exceptions that</span>
            <span class="c1"># are to be caught. Presently there are no cases for which the code</span>
            <span class="c1"># reaches this block other than ZeroDivisionError and complex</span>
            <span class="c1"># comparision. Also the exception is caught only once. If the</span>
            <span class="c1"># exception repeats itself,</span>
            <span class="c1"># then it is not caught and the corresponding error is raised.</span>
            <span class="c1"># XXX: Remove catching all exceptions once the plotting module</span>
            <span class="c1"># is heavily tested.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="ne">ZeroDivisionError</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;no ordering relation is&#39;</span>
                                               <span class="s1">&#39; defined for complex numbers&#39;</span>
                                               <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;unorderable &#39;</span>
                                               <span class="s1">&#39;types&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;&#39;&gt;&#39; not &quot;</span>
                                               <span class="s2">&quot;supported between instances of&quot;</span>
                                               <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span> <span class="o">=</span> <span class="n">experimental_lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span>
                                                         <span class="n">use_evalf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                         <span class="n">use_python_math</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failure</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="c1">#Failure</span>
                <span class="c1">#Try wrapping it with complex(..).evalf()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">failure</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span> <span class="o">=</span> <span class="n">experimental_lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span>
                                                    <span class="n">use_evalf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                    <span class="n">complex_wrap_evalf</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The evaluation of the expression is&#39;</span>
                        <span class="s1">&#39; problematic. We are trying a failback method&#39;</span>
                        <span class="s1">&#39; that may still work. Please report this as a bug.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="experimental_lambdify"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.experimental_lambdify">[docs]</a><span class="k">def</span> <span class="nf">experimental_lambdify</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">Lambdifier</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">l</span></div>


<div class="viewcode-block" id="Lambdifier"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.Lambdifier">[docs]</a><span class="k">class</span> <span class="nc">Lambdifier</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">print_lambda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_evalf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">float_wrap_evalf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">complex_wrap_evalf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">use_np</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_python_math</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_python_cmath</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">use_interval</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">print_lambda</span> <span class="o">=</span> <span class="n">print_lambda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_evalf</span> <span class="o">=</span> <span class="n">use_evalf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">float_wrap_evalf</span> <span class="o">=</span> <span class="n">float_wrap_evalf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complex_wrap_evalf</span> <span class="o">=</span> <span class="n">complex_wrap_evalf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_np</span> <span class="o">=</span> <span class="n">use_np</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_python_math</span> <span class="o">=</span> <span class="n">use_python_math</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_python_cmath</span> <span class="o">=</span> <span class="n">use_python_cmath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_interval</span> <span class="o">=</span> <span class="n">use_interval</span>

        <span class="c1"># Constructing the argument string</span>
        <span class="c1"># - check</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The arguments must be Symbols.&#39;</span><span class="p">)</span>
        <span class="c1"># - use numbered symbols</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="n">exclude</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
        <span class="n">newargs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">newargs</span><span class="p">)))</span>
        <span class="n">argstr</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">newargs</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">syms</span><span class="p">,</span> <span class="n">newargs</span><span class="p">,</span> <span class="n">args</span>

        <span class="c1"># Constructing the translation dictionaries and making the translation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dict_str</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_fun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dict_fun</span><span class="p">()</span>
        <span class="n">exprstr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="c1"># the &amp; and | operators don&#39;t work on tuples, see discussion #12108</span>
        <span class="n">exprstr</span> <span class="o">=</span> <span class="n">exprstr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &amp; &quot;</span><span class="p">,</span><span class="s2">&quot; and &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; | &quot;</span><span class="p">,</span><span class="s2">&quot; or &quot;</span><span class="p">)</span>

        <span class="n">newexpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree2str_translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">str2tree</span><span class="p">(</span><span class="n">exprstr</span><span class="p">))</span>

        <span class="c1"># Constructing the namespaces</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sympy_atoms_namespace</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sympy_expression_namespace</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="c1"># XXX Workaround</span>
        <span class="c1"># Ugly workaround because Pow(a,Half) prints as sqrt(a)</span>
        <span class="c1"># and sympy_expression_namespace can not catch it.</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sqrt</span>
        <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;sqrt&#39;</span><span class="p">:</span> <span class="n">sqrt</span><span class="p">})</span>
        <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;Eq&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">})</span>
        <span class="c1"># End workaround.</span>
        <span class="k">if</span> <span class="n">use_python_math</span><span class="p">:</span>
            <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;math&#39;</span><span class="p">:</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;math&#39;</span><span class="p">)})</span>
        <span class="k">if</span> <span class="n">use_python_cmath</span><span class="p">:</span>
            <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;cmath&#39;</span><span class="p">:</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;cmath&#39;</span><span class="p">)})</span>
        <span class="k">if</span> <span class="n">use_np</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;np&#39;</span><span class="p">:</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)})</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="s1">&#39;experimental_lambdify failed to import numpy.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_interval</span><span class="p">:</span>
            <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;imath&#39;</span><span class="p">:</span> <span class="nb">__import__</span><span class="p">(</span>
                <span class="s1">&#39;sympy.plotting.intervalmath&#39;</span><span class="p">,</span> <span class="n">fromlist</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;intervalmath&#39;</span><span class="p">])})</span>
            <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;math&#39;</span><span class="p">:</span> <span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;math&#39;</span><span class="p">)})</span>

        <span class="c1"># Construct the lambda</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_lambda</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">newexpr</span><span class="p">)</span>
        <span class="n">eval_str</span> <span class="o">=</span> <span class="s1">&#39;lambda </span><span class="si">%s</span><span class="s1"> : ( </span><span class="si">%s</span><span class="s1"> )&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">argstr</span><span class="p">,</span> <span class="n">newexpr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval_str</span> <span class="o">=</span> <span class="n">eval_str</span>
        <span class="n">exec_</span><span class="p">(</span><span class="s2">&quot;from __future__ import division; MYNEWLAMBDA = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">eval_str</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span> <span class="o">=</span> <span class="n">namespace</span><span class="p">[</span><span class="s1">&#39;MYNEWLAMBDA&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambda_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


    <span class="c1">##############################################################################</span>
    <span class="c1"># Dicts for translating from sympy to other modules</span>
    <span class="c1">##############################################################################</span>
    <span class="c1">###</span>
    <span class="c1"># builtins</span>
    <span class="c1">###</span>
    <span class="c1"># Functions with different names in builtins</span>
    <span class="n">builtin_functions_different</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Min&#39;</span><span class="p">:</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Max&#39;</span><span class="p">:</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Abs&#39;</span><span class="p">:</span> <span class="s1">&#39;abs&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Strings that should be translated</span>
    <span class="n">builtin_not_functions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="s1">&#39;1j&#39;</span><span class="p">,</span>
<span class="c1">#        &#39;oo&#39;: &#39;1e400&#39;,</span>
    <span class="p">}</span>

    <span class="c1">###</span>
    <span class="c1"># numpy</span>
    <span class="c1">###</span>

    <span class="c1"># Functions that are the same in numpy</span>
    <span class="n">numpy_functions_same</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;sin&#39;</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">,</span> <span class="s1">&#39;tan&#39;</span><span class="p">,</span> <span class="s1">&#39;sinh&#39;</span><span class="p">,</span> <span class="s1">&#39;cosh&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;exp&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span>
        <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span> <span class="s1">&#39;conjugate&#39;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># Functions with different names in numpy</span>
    <span class="n">numpy_functions_different</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;acos&quot;</span><span class="p">:</span> <span class="s2">&quot;arccos&quot;</span><span class="p">,</span>
        <span class="s2">&quot;acosh&quot;</span><span class="p">:</span> <span class="s2">&quot;arccosh&quot;</span><span class="p">,</span>
        <span class="s2">&quot;arg&quot;</span><span class="p">:</span> <span class="s2">&quot;angle&quot;</span><span class="p">,</span>
        <span class="s2">&quot;asin&quot;</span><span class="p">:</span> <span class="s2">&quot;arcsin&quot;</span><span class="p">,</span>
        <span class="s2">&quot;asinh&quot;</span><span class="p">:</span> <span class="s2">&quot;arcsinh&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atan&quot;</span><span class="p">:</span> <span class="s2">&quot;arctan&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atan2&quot;</span><span class="p">:</span> <span class="s2">&quot;arctan2&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atanh&quot;</span><span class="p">:</span> <span class="s2">&quot;arctanh&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ceiling&quot;</span><span class="p">:</span> <span class="s2">&quot;ceil&quot;</span><span class="p">,</span>
        <span class="s2">&quot;im&quot;</span><span class="p">:</span> <span class="s2">&quot;imag&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ln&quot;</span><span class="p">:</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Max&quot;</span><span class="p">:</span> <span class="s2">&quot;amax&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Min&quot;</span><span class="p">:</span> <span class="s2">&quot;amin&quot;</span><span class="p">,</span>
        <span class="s2">&quot;re&quot;</span><span class="p">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Abs&quot;</span><span class="p">:</span> <span class="s2">&quot;abs&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Strings that should be translated</span>
    <span class="n">numpy_not_functions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;pi&#39;</span><span class="p">:</span> <span class="s1">&#39;np.pi&#39;</span><span class="p">,</span>
        <span class="s1">&#39;oo&#39;</span><span class="p">:</span> <span class="s1">&#39;np.inf&#39;</span><span class="p">,</span>
        <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="s1">&#39;np.e&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">###</span>
    <span class="c1"># python math</span>
    <span class="c1">###</span>

    <span class="c1"># Functions that are the same in math</span>
    <span class="n">math_functions_same</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;sin&#39;</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">,</span> <span class="s1">&#39;tan&#39;</span><span class="p">,</span> <span class="s1">&#39;asin&#39;</span><span class="p">,</span> <span class="s1">&#39;acos&#39;</span><span class="p">,</span> <span class="s1">&#39;atan&#39;</span><span class="p">,</span> <span class="s1">&#39;atan2&#39;</span><span class="p">,</span>
        <span class="s1">&#39;sinh&#39;</span><span class="p">,</span> <span class="s1">&#39;cosh&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;asinh&#39;</span><span class="p">,</span> <span class="s1">&#39;acosh&#39;</span><span class="p">,</span> <span class="s1">&#39;atanh&#39;</span><span class="p">,</span>
        <span class="s1">&#39;exp&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;erf&#39;</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span> <span class="s1">&#39;factorial&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># Functions with different names in math</span>
    <span class="n">math_functions_different</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;ceiling&#39;</span><span class="p">:</span> <span class="s1">&#39;ceil&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ln&#39;</span><span class="p">:</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span>
        <span class="s1">&#39;loggamma&#39;</span><span class="p">:</span> <span class="s1">&#39;lgamma&#39;</span>
    <span class="p">}</span>

    <span class="c1"># Strings that should be translated</span>
    <span class="n">math_not_functions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;pi&#39;</span><span class="p">:</span> <span class="s1">&#39;math.pi&#39;</span><span class="p">,</span>
        <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="s1">&#39;math.e&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">###</span>
    <span class="c1"># python cmath</span>
    <span class="c1">###</span>

    <span class="c1"># Functions that are the same in cmath</span>
    <span class="n">cmath_functions_same</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;sin&#39;</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">,</span> <span class="s1">&#39;tan&#39;</span><span class="p">,</span> <span class="s1">&#39;asin&#39;</span><span class="p">,</span> <span class="s1">&#39;acos&#39;</span><span class="p">,</span> <span class="s1">&#39;atan&#39;</span><span class="p">,</span>
        <span class="s1">&#39;sinh&#39;</span><span class="p">,</span> <span class="s1">&#39;cosh&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;asinh&#39;</span><span class="p">,</span> <span class="s1">&#39;acosh&#39;</span><span class="p">,</span> <span class="s1">&#39;atanh&#39;</span><span class="p">,</span>
        <span class="s1">&#39;exp&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># Functions with different names in cmath</span>
    <span class="n">cmath_functions_different</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;ln&#39;</span><span class="p">:</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span>
        <span class="s1">&#39;arg&#39;</span><span class="p">:</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Strings that should be translated</span>
    <span class="n">cmath_not_functions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;pi&#39;</span><span class="p">:</span> <span class="s1">&#39;cmath.pi&#39;</span><span class="p">,</span>
        <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="s1">&#39;cmath.e&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">###</span>
    <span class="c1"># intervalmath</span>
    <span class="c1">###</span>

    <span class="n">interval_not_functions</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;pi&#39;</span><span class="p">:</span> <span class="s1">&#39;math.pi&#39;</span><span class="p">,</span>
        <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="s1">&#39;math.e&#39;</span>
    <span class="p">}</span>

    <span class="n">interval_functions_same</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;sin&#39;</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">,</span> <span class="s1">&#39;exp&#39;</span><span class="p">,</span> <span class="s1">&#39;tan&#39;</span><span class="p">,</span> <span class="s1">&#39;atan&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span>
        <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;cosh&#39;</span><span class="p">,</span> <span class="s1">&#39;sinh&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span>
        <span class="s1">&#39;acos&#39;</span><span class="p">,</span> <span class="s1">&#39;asin&#39;</span><span class="p">,</span> <span class="s1">&#39;acosh&#39;</span><span class="p">,</span> <span class="s1">&#39;asinh&#39;</span><span class="p">,</span> <span class="s1">&#39;atanh&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Abs&#39;</span><span class="p">,</span> <span class="s1">&#39;And&#39;</span><span class="p">,</span> <span class="s1">&#39;Or&#39;</span>
    <span class="p">]</span>

    <span class="n">interval_functions_different</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Min&#39;</span><span class="p">:</span> <span class="s1">&#39;imin&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Max&#39;</span><span class="p">:</span> <span class="s1">&#39;imax&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ceiling&#39;</span><span class="p">:</span> <span class="s1">&#39;ceil&#39;</span><span class="p">,</span>

    <span class="p">}</span>

    <span class="c1">###</span>
    <span class="c1"># mpmath, etc</span>
    <span class="c1">###</span>
    <span class="c1">#TODO</span>

    <span class="c1">###</span>
    <span class="c1"># Create the final ordered tuples of dictionaries</span>
    <span class="c1">###</span>

    <span class="c1"># For strings</span>
<div class="viewcode-block" id="Lambdifier.get_dict_str"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.Lambdifier.get_dict_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_dict_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dict_str</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">builtin_not_functions</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_np</span><span class="p">:</span>
            <span class="n">dict_str</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numpy_not_functions</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_python_math</span><span class="p">:</span>
            <span class="n">dict_str</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">math_not_functions</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_python_cmath</span><span class="p">:</span>
            <span class="n">dict_str</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cmath_not_functions</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_interval</span><span class="p">:</span>
            <span class="n">dict_str</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval_not_functions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dict_str</span></div>

    <span class="c1"># For functions</span>
<div class="viewcode-block" id="Lambdifier.get_dict_fun"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.Lambdifier.get_dict_fun">[docs]</a>    <span class="k">def</span> <span class="nf">get_dict_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dict_fun</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">builtin_functions_different</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_np</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_functions_same</span><span class="p">:</span>
                <span class="n">dict_fun</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;np.&#39;</span> <span class="o">+</span> <span class="n">s</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_functions_different</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">dict_fun</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;np.&#39;</span> <span class="o">+</span> <span class="n">v</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_python_math</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">math_functions_same</span><span class="p">:</span>
                <span class="n">dict_fun</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;math.&#39;</span> <span class="o">+</span> <span class="n">s</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">math_functions_different</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">dict_fun</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;math.&#39;</span> <span class="o">+</span> <span class="n">v</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_python_cmath</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmath_functions_same</span><span class="p">:</span>
                <span class="n">dict_fun</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cmath.&#39;</span> <span class="o">+</span> <span class="n">s</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmath_functions_different</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">dict_fun</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cmath.&#39;</span> <span class="o">+</span> <span class="n">v</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_interval</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_functions_same</span><span class="p">:</span>
                <span class="n">dict_fun</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;imath.&#39;</span> <span class="o">+</span> <span class="n">s</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_functions_different</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">dict_fun</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;imath.&#39;</span> <span class="o">+</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">dict_fun</span></div>

    <span class="c1">##############################################################################</span>
    <span class="c1"># The translator functions, tree parsers, etc.</span>
    <span class="c1">##############################################################################</span>

<div class="viewcode-block" id="Lambdifier.str2tree"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.Lambdifier.str2tree">[docs]</a>    <span class="k">def</span> <span class="nf">str2tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprstr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts an expression string to a tree.</span>

<span class="sd">        Functions are represented by (&#39;func_name(&#39;, tree_of_arguments).</span>
<span class="sd">        Other expressions are (head_string, mid_tree, tail_str).</span>
<span class="sd">        Expressions that do not contain functions are directly returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from ..abc import x, y, z</span>
<span class="sd">        &gt;&gt;&gt; from .. import Integral, sin</span>
<span class="sd">        &gt;&gt;&gt; from .experimental_lambdify import Lambdifier</span>
<span class="sd">        &gt;&gt;&gt; str2tree = Lambdifier([x], x).str2tree</span>

<span class="sd">        &gt;&gt;&gt; str2tree(str(Integral(x, (x, 1, y))))</span>
<span class="sd">        (&#39;&#39;, (&#39;Integral(&#39;, &#39;x, (x, 1, y)&#39;), &#39;)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; str2tree(str(x+y))</span>
<span class="sd">        &#39;x + y&#39;</span>
<span class="sd">        &gt;&gt;&gt; str2tree(str(x+y*sin(z)+1))</span>
<span class="sd">        (&#39;x + y*&#39;, (&#39;sin(&#39;, &#39;z&#39;), &#39;) + 1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; str2tree(&#39;sin(y*(y + 1.1) + (sin(y)))&#39;)</span>
<span class="sd">        (&#39;&#39;, (&#39;sin(&#39;, (&#39;y*(y + 1.1) + (&#39;, (&#39;sin(&#39;, &#39;y&#39;), &#39;))&#39;)), &#39;)&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#matches the first &#39;function_name(&#39;</span>
        <span class="n">first_par</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+\()&#39;</span><span class="p">,</span> <span class="n">exprstr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">first_par</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exprstr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">first_par</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">first_par</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">exprstr</span><span class="p">[:</span><span class="n">start</span><span class="p">]</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">exprstr</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="n">exprstr</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tail</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">func_tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">str2tree</span><span class="p">(</span><span class="n">tail</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">str2tree</span><span class="p">(</span><span class="n">tail</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_tail</span><span class="p">),</span> <span class="n">tail</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lambdifier.tree2str"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.Lambdifier.tree2str">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tree2str</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a tree to string without translations.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from ..abc import x, y, z</span>
<span class="sd">        &gt;&gt;&gt; from .. import Integral, sin</span>
<span class="sd">        &gt;&gt;&gt; from .experimental_lambdify import Lambdifier</span>
<span class="sd">        &gt;&gt;&gt; str2tree = Lambdifier([x], x).str2tree</span>
<span class="sd">        &gt;&gt;&gt; tree2str = Lambdifier([x], x).tree2str</span>

<span class="sd">        &gt;&gt;&gt; tree2str(str2tree(str(x+y*sin(z)+1)))</span>
<span class="sd">        &#39;x + y*sin(z) + 1&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tree</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">tree2str</span><span class="p">,</span> <span class="n">tree</span><span class="p">))</span></div>

<div class="viewcode-block" id="Lambdifier.tree2str_translate"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.Lambdifier.tree2str_translate">[docs]</a>    <span class="k">def</span> <span class="nf">tree2str_translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a tree to string with translations.</span>

<span class="sd">        Function names are translated by translate_func.</span>
<span class="sd">        Other strings are translated by translate_str.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate_str</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate_func</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">tree2str_translate</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">])</span></div>

<div class="viewcode-block" id="Lambdifier.translate_str"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.Lambdifier.translate_str">[docs]</a>    <span class="k">def</span> <span class="nf">translate_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Translate substrings of estr using in order the dictionaries in</span>
<span class="sd">        dict_tuple_str.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">repl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_str</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">estr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">estr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">estr</span></div>

<div class="viewcode-block" id="Lambdifier.translate_func"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.Lambdifier.translate_func">[docs]</a>    <span class="k">def</span> <span class="nf">translate_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">argtree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Translate function names and the tree of arguments.</span>

<span class="sd">        If the function name is not in the dictionaries of dict_tuple_fun then the</span>
<span class="sd">        function is surrounded by a float((...).evalf()).</span>

<span class="sd">        The use of float is necessary as np.&lt;function&gt;(sympy.Float(..)) raises an</span>
<span class="sd">        error.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">func_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_fun</span><span class="p">:</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_fun</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span>
            <span class="n">argstr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree2str_translate</span><span class="p">(</span><span class="n">argtree</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_name</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="n">argstr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">template</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)).evalf(&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_evalf</span> <span class="k">else</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_wrap_evalf</span><span class="p">:</span>
                <span class="n">template</span> <span class="o">=</span> <span class="s1">&#39;float(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">template</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_wrap_evalf</span><span class="p">:</span>
                <span class="n">template</span> <span class="o">=</span> <span class="s1">&#39;complex(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">template</span>

            <span class="c1"># Wrapping should only happen on the outermost expression, which</span>
            <span class="c1"># is the only thing we know will be a number.</span>
            <span class="n">float_wrap_evalf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_wrap_evalf</span>
            <span class="n">complex_wrap_evalf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_wrap_evalf</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">float_wrap_evalf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">complex_wrap_evalf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">ret</span> <span class="o">=</span>  <span class="n">template</span> <span class="o">%</span> <span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree2str_translate</span><span class="p">(</span><span class="n">argtree</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">float_wrap_evalf</span> <span class="o">=</span> <span class="n">float_wrap_evalf</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">complex_wrap_evalf</span> <span class="o">=</span> <span class="n">complex_wrap_evalf</span>
            <span class="k">return</span> <span class="n">ret</span></div>

    <span class="c1">##############################################################################</span>
    <span class="c1"># The namespace constructors</span>
    <span class="c1">##############################################################################</span>

<div class="viewcode-block" id="Lambdifier.sympy_expression_namespace"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.Lambdifier.sympy_expression_namespace">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sympy_expression_namespace</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Traverses the (func, args) tree of an expression and creates a sympy</span>
<span class="sd">        namespace. All other modules are imported only as a module name. That way</span>
<span class="sd">        the namespace is not poluted and rests quite small. It probably causes much</span>
<span class="sd">        more variable lookups and so it takes more time, but there are no tests on</span>
<span class="sd">        that for the moment.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">funcname</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
            <span class="c1"># XXX Workaround</span>
            <span class="c1"># Here we add an ugly workaround because str(func(x))</span>
            <span class="c1"># is not always the same as str(func). Eg</span>
            <span class="c1"># &gt;&gt;&gt; str(Integral(x))</span>
            <span class="c1"># &quot;Integral(x)&quot;</span>
            <span class="c1"># &gt;&gt;&gt; str(Integral)</span>
            <span class="c1"># &quot;&lt;class &#39;sympy.integrals.integrals.Integral&#39;&gt;&quot;</span>
            <span class="c1"># &gt;&gt;&gt; str(sqrt(x))</span>
            <span class="c1"># &quot;sqrt(x)&quot;</span>
            <span class="c1"># &gt;&gt;&gt; str(sqrt)</span>
            <span class="c1"># &quot;&lt;function sqrt at 0x3d92de8&gt;&quot;</span>
            <span class="c1"># &gt;&gt;&gt; str(sin(x))</span>
            <span class="c1"># &quot;sin(x)&quot;</span>
            <span class="c1"># &gt;&gt;&gt; str(sin)</span>
            <span class="c1"># &quot;sin&quot;</span>
            <span class="c1"># Either one of those can be used but not all at the same time.</span>
            <span class="c1"># The code considers the sin example as the right one.</span>
            <span class="n">regexlist</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">r</span><span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">sympy[\w.]*?.([\w]*)</span><span class="se">\&#39;</span><span class="s1">&gt;$&#39;</span><span class="p">,</span>
                <span class="c1"># the example Integral</span>
                <span class="sa">r</span><span class="s1">&#39;&lt;function ([\w]*) at 0x[\w]*&gt;$&#39;</span><span class="p">,</span>    <span class="c1"># the example sqrt</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">regexlist</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">funcname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">funcname</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># End of the workaround</span>
            <span class="c1"># XXX debug: print funcname</span>
            <span class="n">args_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">I</span><span class="p">,</span> <span class="n">zoo</span><span class="p">,</span> <span class="n">oo</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">args_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">sympy_expression_namespace</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="n">args_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">funcname</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">})</span>
            <span class="k">return</span> <span class="n">args_dict</span></div>

<div class="viewcode-block" id="Lambdifier.sympy_atoms_namespace"><a class="viewcode-back" href="../../../../modelparameters.sympy.plotting.html#modelparameters.sympy.plotting.experimental_lambdify.Lambdifier.sympy_atoms_namespace">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sympy_atoms_namespace</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For no real reason this function is separated from</span>
<span class="sd">        sympy_expression_namespace. It can be moved to it.&quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">NumberSymbol</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">zoo</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="c1"># XXX debug: print &#39;atom:&#39; + str(a)</span>
            <span class="n">d</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="n">d</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">modelparameters 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modelparameters.sympy.plotting.experimental_lambdify</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Johan Hake, Henrik Finsberg.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>