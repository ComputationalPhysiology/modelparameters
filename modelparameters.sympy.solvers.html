
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>modelparameters.sympy.solvers package &#8212; modelparameters 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="modelparameters.sympy.stats package" href="modelparameters.sympy.stats.html" />
    <link rel="prev" title="modelparameters.sympy.simplify package" href="modelparameters.sympy.simplify.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="modelparameters.sympy.stats.html" title="modelparameters.sympy.stats package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modelparameters.sympy.simplify.html" title="modelparameters.sympy.simplify package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">modelparameters 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modelparameters.html" >modelparameters package</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modelparameters.sympy.html" accesskey="U">modelparameters.sympy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modelparameters.sympy.solvers package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="modelparameters-sympy-solvers-package">
<h1>modelparameters.sympy.solvers package<a class="headerlink" href="#modelparameters-sympy-solvers-package" title="Permalink to this headline">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-modelparameters.sympy.solvers.bivariate">
<span id="modelparameters-sympy-solvers-bivariate-module"></span><h2>modelparameters.sympy.solvers.bivariate module<a class="headerlink" href="#module-modelparameters.sympy.solvers.bivariate" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.bivariate.bivariate_type">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.bivariate.</span></span><span class="sig-name descname"><span class="pre">bivariate_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/bivariate.html#bivariate_type"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.bivariate.bivariate_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an expression, f, 3 tests will be done to see what type
of composite bivariate it might be, options for u(x, y) are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">*</span><span class="n">y</span>
<span class="n">x</span><span class="o">+</span><span class="n">y</span>
<span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">x</span>
<span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">y</span>
</pre></div>
</div>
<p>If it matches one of these types, <code class="docutils literal notranslate"><span class="pre">u(x,</span> <span class="pre">y)</span></code>, <code class="docutils literal notranslate"><span class="pre">P(u)</span></code> and dummy
variable <code class="docutils literal notranslate"><span class="pre">u</span></code> will be returned. Solving <code class="docutils literal notranslate"><span class="pre">P(u)</span></code> for <code class="docutils literal notranslate"><span class="pre">u</span></code> and
equating the solutions to <code class="docutils literal notranslate"><span class="pre">u(x,</span> <span class="pre">y)</span></code> and then solving for <code class="docutils literal notranslate"><span class="pre">x</span></code> or
<code class="docutils literal notranslate"><span class="pre">y</span></code> is equivalent to solving the original expression for <code class="docutils literal notranslate"><span class="pre">x</span></code> or
<code class="docutils literal notranslate"><span class="pre">y</span></code>. If <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> represent two functions in the same
variable, e.g. <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">g(t)</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">h(t)</span></code>, then if <code class="docutils literal notranslate"><span class="pre">u(x,</span> <span class="pre">y)</span> <span class="pre">-</span> <span class="pre">p</span></code>
can be solved for <code class="docutils literal notranslate"><span class="pre">t</span></code> then these represent the solutions to
<code class="docutils literal notranslate"><span class="pre">P(u)</span> <span class="pre">=</span> <span class="pre">0</span></code> when <code class="docutils literal notranslate"><span class="pre">p</span></code> are the solutions of <code class="docutils literal notranslate"><span class="pre">P(u)</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
<p>Only positive values of <code class="docutils literal notranslate"><span class="pre">u</span></code> are considered.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solvers</span> <span class="kn">import</span> <span class="n">solve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.bivariate</span> <span class="kn">import</span> <span class="n">bivariate_type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bivariate_type</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">(x + y, _u**2 - 3, _u)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uxy</span><span class="p">,</span> <span class="n">pu</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">usol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">pu</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span> <span class="n">usol</span>
<span class="go">[sqrt(3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">solve</span><span class="p">(</span><span class="n">uxy</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solve</span><span class="p">(</span><span class="n">pu</span><span class="p">,</span> <span class="n">u</span><span class="p">)]</span>
<span class="go">[[{x: -y + sqrt(3)}]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">_</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-modelparameters.sympy.solvers.decompogen">
<span id="modelparameters-sympy-solvers-decompogen-module"></span><h2>modelparameters.sympy.solvers.decompogen module<a class="headerlink" href="#module-modelparameters.sympy.solvers.decompogen" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.decompogen.compogen">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.decompogen.</span></span><span class="sig-name descname"><span class="pre">compogen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/decompogen.html#compogen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.decompogen.compogen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the composition of functions.
Given a list of functions <code class="docutils literal notranslate"><span class="pre">g_s</span></code>, returns their composition <code class="docutils literal notranslate"><span class="pre">f</span></code>,
where:</p>
<blockquote>
<div><p>f = g_1 o g_2 o .. o g_n</p>
</div></blockquote>
<p>Note: This is a General composition function. It also composes Polynomials.
For only Polynomial composition see <code class="docutils literal notranslate"><span class="pre">compose</span></code> in polys.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.decompogen</span> <span class="kn">import</span> <span class="n">compogen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compogen</span><span class="p">([</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">sin(cos(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compogen</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">sin(x)**2 + sin(x) + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compogen</span><span class="p">([</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">sqrt(6*x**2 - 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compogen</span><span class="p">([</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">sin(sqrt(cos(x**2 + 1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compogen</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">-x**2 - x + (x**2 + x)**2 - 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.decompogen.decompogen">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.decompogen.</span></span><span class="sig-name descname"><span class="pre">decompogen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/decompogen.html#decompogen"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.decompogen.decompogen" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes General functional decomposition of <code class="docutils literal notranslate"><span class="pre">f</span></code>.
Given an expression <code class="docutils literal notranslate"><span class="pre">f</span></code>, returns a list <code class="docutils literal notranslate"><span class="pre">[f_1,</span> <span class="pre">f_2,</span> <span class="pre">...,</span> <span class="pre">f_n]</span></code>,
where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">f_1</span> <span class="n">o</span> <span class="n">f_2</span> <span class="n">o</span> <span class="o">...</span> <span class="n">f_n</span> <span class="o">=</span> <span class="n">f_1</span><span class="p">(</span><span class="n">f_2</span><span class="p">(</span><span class="o">...</span> <span class="n">f_n</span><span class="p">))</span>
</pre></div>
</div>
<p>Note: This is a General decomposition function. It also decomposes
Polynomials. For only Polynomial decomposition see <code class="docutils literal notranslate"><span class="pre">decompose</span></code> in polys.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.decompogen</span> <span class="kn">import</span> <span class="n">decompogen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decompogen</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[sin(x), cos(x)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decompogen</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[x**2 + x + 1, sin(x)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decompogen</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[sqrt(x), 6*x**2 - 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decompogen</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[sin(x), sqrt(x), cos(x), x**2 + 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decompogen</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[x**2 - x - 1, x**2 + x]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-modelparameters.sympy.solvers.deutils">
<span id="modelparameters-sympy-solvers-deutils-module"></span><h2>modelparameters.sympy.solvers.deutils module<a class="headerlink" href="#module-modelparameters.sympy.solvers.deutils" title="Permalink to this headline">¶</a></h2>
<p>Utility functions for classifying and solving
ordinary and partial differential equations.</p>
<section id="contains">
<h3>Contains<a class="headerlink" href="#contains" title="Permalink to this headline">¶</a></h3>
<p>_preprocess
ode_order
_desolve</p>
<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.deutils.ode_order">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.deutils.</span></span><span class="sig-name descname"><span class="pre">ode_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/deutils.html#ode_order"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.deutils.ode_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order of a given differential
equation with respect to func.</p>
<p>This function is implemented recursively.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.deutils</span> <span class="kn">import</span> <span class="n">ode_order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="module-modelparameters.sympy.solvers.diophantine">
<span id="modelparameters-sympy-solvers-diophantine-module"></span><h2>modelparameters.sympy.solvers.diophantine module<a class="headerlink" href="#module-modelparameters.sympy.solvers.diophantine" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.diophantine.classify_diop">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.diophantine.</span></span><span class="sig-name descname"><span class="pre">classify_diop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/diophantine.html#classify_diop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.diophantine.classify_diop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.diophantine.diophantine">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.diophantine.</span></span><span class="sig-name descname"><span class="pre">diophantine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">syms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/diophantine.html#diophantine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.diophantine.diophantine" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify the solution procedure of diophantine equation <code class="docutils literal notranslate"><span class="pre">eq</span></code> by
converting it into a product of terms which should equal zero.</p>
<p>For example, when solving, <cite>x^2 - y^2 = 0</cite> this is treated as
<cite>(x + y)(x - y) = 0</cite> and <cite>x + y = 0</cite> and <cite>x - y = 0</cite> are solved
independently and combined. Each term is solved by calling
<code class="docutils literal notranslate"><span class="pre">diop_solve()</span></code>.</p>
<p>Output of <code class="docutils literal notranslate"><span class="pre">diophantine()</span></code> is a set of tuples. The elements of the
tuple are the solutions for each variable in the equation and
are arranged according to the alphabetic ordering of the variables.
e.g. For an equation with two variables, <cite>a</cite> and <cite>b</cite>, the first
element of the tuple is the solution for <cite>a</cite> and the second for <cite>b</cite>.</p>
<p><code class="docutils literal notranslate"><span class="pre">diophantine(eq,</span> <span class="pre">t,</span> <span class="pre">syms)</span></code>: Solve the diophantine
equation <code class="docutils literal notranslate"><span class="pre">eq</span></code>.
<code class="docutils literal notranslate"><span class="pre">t</span></code> is the optional parameter to be used by <code class="docutils literal notranslate"><span class="pre">diop_solve()</span></code>.
<code class="docutils literal notranslate"><span class="pre">syms</span></code> is an optional list of symbols which determines the
order of the elements in the returned tuple.</p>
<p>By default, only the base solution is returned. If <code class="docutils literal notranslate"><span class="pre">permute</span></code> is set to
True then permutations of the base solution and/or permutations of the
signs of the values will be returned when applicable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.diophantine</span> <span class="kn">import</span> <span class="n">diophantine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">a</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diophantine</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">{(2, 3)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diophantine</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">permute</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">eq</span></code> should be an expression which is assumed to be zero.
<code class="docutils literal notranslate"><span class="pre">t</span></code> is the parameter to be used in the solution.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diophantine</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">{(t_0, -t_0), (t_0, t_0)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">diophantine</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">))</span>
<span class="go">{(0, n1, n2), (t_0, t_1, 2*t_0 + 3*t_1)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diophantine</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">{(0, n1), (3*t_0 - 4, -t_0)}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diop_solve</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.utilities.iterables.permute_signs</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.utilities.iterables.signed_permutations</span></code></p>
</div>
</dd></dl>

</section>
<section id="module-modelparameters.sympy.solvers.inequalities">
<span id="modelparameters-sympy-solvers-inequalities-module"></span><h2>modelparameters.sympy.solvers.inequalities module<a class="headerlink" href="#module-modelparameters.sympy.solvers.inequalities" title="Permalink to this headline">¶</a></h2>
<p>Tools for solving inequalities and systems of inequalities.</p>
<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.inequalities.reduce_abs_inequalities">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.inequalities.</span></span><span class="sig-name descname"><span class="pre">reduce_abs_inequalities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exprs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gen</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/inequalities.html#reduce_abs_inequalities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.inequalities.reduce_abs_inequalities" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce a system of inequalities with nested absolute values.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Abs</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.inequalities</span> <span class="kn">import</span> <span class="n">reduce_abs_inequalities</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reduce_abs_inequalities</span><span class="p">([(</span><span class="n">Abs</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">(</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">25</span><span class="p">)</span> <span class="o">-</span> <span class="mi">13</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">)],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(-2/3 &lt; x) &amp; (x &lt; 4) &amp; (((-oo &lt; x) &amp; (x &lt; -38)) | ((-12 &lt; x) &amp; (x &lt; oo)))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reduce_abs_inequalities</span><span class="p">([(</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">Abs</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">)],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(1/2 &lt; x) &amp; (x &lt; 4)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.inequalities.reduce_abs_inequality" title="modelparameters.sympy.solvers.inequalities.reduce_abs_inequality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_abs_inequality</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.inequalities.reduce_abs_inequality">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.inequalities.</span></span><span class="sig-name descname"><span class="pre">reduce_abs_inequality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gen</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/inequalities.html#reduce_abs_inequality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.inequalities.reduce_abs_inequality" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce an inequality with nested absolute values.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Abs</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.inequalities</span> <span class="kn">import</span> <span class="n">reduce_abs_inequality</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reduce_abs_inequality</span><span class="p">(</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(2 &lt; x) &amp; (x &lt; 8)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reduce_abs_inequality</span><span class="p">(</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">13</span><span class="p">,</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(-19/3 &lt; x) &amp; (x &lt; 7/3)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.inequalities.reduce_abs_inequalities" title="modelparameters.sympy.solvers.inequalities.reduce_abs_inequalities"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_abs_inequalities</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.inequalities.reduce_inequalities">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.inequalities.</span></span><span class="sig-name descname"><span class="pre">reduce_inequalities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequalities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/inequalities.html#reduce_inequalities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.inequalities.reduce_inequalities" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce a system of inequalities with rational coefficients.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sympify</span> <span class="k">as</span> <span class="n">S</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.inequalities</span> <span class="kn">import</span> <span class="n">reduce_inequalities</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reduce_inequalities</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[])</span>
<span class="go">(-3 &lt;= x) &amp; (x &lt; oo)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reduce_inequalities</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="go">x &gt;= -2*y + 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.inequalities.reduce_rational_inequalities">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.inequalities.</span></span><span class="sig-name descname"><span class="pre">reduce_rational_inequalities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exprs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relational</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/inequalities.html#reduce_rational_inequalities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.inequalities.reduce_rational_inequalities" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce a system of rational inequalities with rational coefficients.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.inequalities</span> <span class="kn">import</span> <span class="n">reduce_rational_inequalities</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reduce_rational_inequalities</span><span class="p">([[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Eq(x, 0)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reduce_rational_inequalities</span><span class="p">([[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(-2 &lt; x) &amp; (x &lt; oo)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reduce_rational_inequalities</span><span class="p">([[(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)]],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(-2 &lt; x) &amp; (x &lt; oo)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reduce_rational_inequalities</span><span class="p">([[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Eq(x, -2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.inequalities.solve_poly_inequalities">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.inequalities.</span></span><span class="sig-name descname"><span class="pre">solve_poly_inequalities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polys</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/inequalities.html#solve_poly_inequalities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.inequalities.solve_poly_inequalities" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve polynomial inequalities with rational coefficients.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.inequalities</span> <span class="kn">import</span> <span class="n">solve_poly_inequalities</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..polys</span> <span class="kn">import</span> <span class="n">Poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_poly_inequalities</span><span class="p">(((</span>
<span class="gp">... </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">),</span> <span class="p">(</span>
<span class="gp">... </span><span class="n">Poly</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)))</span>
<span class="go">Union(Interval.open(-oo, -sqrt(3)), Interval.open(-1, 1), Interval.open(sqrt(3), oo))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.inequalities.solve_poly_inequality">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.inequalities.</span></span><span class="sig-name descname"><span class="pre">solve_poly_inequality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rel</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/inequalities.html#solve_poly_inequality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.inequalities.solve_poly_inequality" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a polynomial inequality with rational coefficients.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.inequalities</span> <span class="kn">import</span> <span class="n">solve_poly_inequality</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_poly_inequality</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">),</span> <span class="s1">&#39;==&#39;</span><span class="p">)</span>
<span class="go">[{0}]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_poly_inequality</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">),</span> <span class="s1">&#39;!=&#39;</span><span class="p">)</span>
<span class="go">[Interval.open(-oo, -1), Interval.open(-1, 1), Interval.open(1, oo)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_poly_inequality</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">),</span> <span class="s1">&#39;==&#39;</span><span class="p">)</span>
<span class="go">[{-1}, {1}]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.inequalities.solve_poly_inequalities" title="modelparameters.sympy.solvers.inequalities.solve_poly_inequalities"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_poly_inequalities</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.inequalities.solve_rational_inequalities">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.inequalities.</span></span><span class="sig-name descname"><span class="pre">solve_rational_inequalities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eqs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/inequalities.html#solve_rational_inequalities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.inequalities.solve_rational_inequalities" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a system of rational inequalities with rational coefficients.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.inequalities</span> <span class="kn">import</span> <span class="n">solve_rational_inequalities</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_rational_inequalities</span><span class="p">([[</span>
<span class="gp">... </span><span class="p">((</span><span class="n">Poly</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">((</span><span class="n">Poly</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">)]])</span>
<span class="go">{1}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_rational_inequalities</span><span class="p">([[</span>
<span class="gp">... </span><span class="p">((</span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="s1">&#39;!=&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">((</span><span class="n">Poly</span><span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Poly</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">)]])</span>
<span class="go">Union(Interval.open(-oo, 0), Interval.Lopen(0, 1))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.inequalities.solve_poly_inequality" title="modelparameters.sympy.solvers.inequalities.solve_poly_inequality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_poly_inequality</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.inequalities.solve_univariate_inequality">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.inequalities.</span></span><span class="sig-name descname"><span class="pre">solve_univariate_inequality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relational</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">S.Reals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/inequalities.html#solve_univariate_inequality"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.inequalities.solve_univariate_inequality" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a real univariate inequality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<a class="reference internal" href="modelparameters.sympy.core.html#modelparameters.sympy.core.relational.Relational" title="modelparameters.sympy.core.relational.Relational"><em>Relational</em></a>) – The target inequality</p></li>
<li><p><strong>gen</strong> (<a class="reference internal" href="modelparameters.sympy.core.html#modelparameters.sympy.core.symbol.Symbol" title="modelparameters.sympy.core.symbol.Symbol"><em>Symbol</em></a>) – The variable for which the inequality is solved</p></li>
<li><p><strong>relational</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a>) – A Relational type output is expected or not</p></li>
<li><p><strong>domain</strong> (<a class="reference internal" href="modelparameters.sympy.sets.html#modelparameters.sympy.sets.sets.Set" title="modelparameters.sympy.sets.sets.Set"><em>Set</em></a>) – The domain over which the equation is solved</p></li>
<li><p><strong>continuous</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><em>bool</em></a>) – True if expr is known to be continuous over the given domain
(and so continuous_domain() doesn’t need to be called on it)</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.10)"><strong>NotImplementedError</strong></a> – The solution of the inequality cannot be determined due to limitation
    in <cite>solvify</cite>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Currently, we cannot solve all the inequalities due to limitations in
<cite>solvify</cite>. Also, the solution returned for trigonometric inequalities
are restricted in its periodic interval.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">solvify</span></code></dt><dd><p>solver returning solveset solutions with solve’s output API</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.inequalities</span> <span class="kn">import</span> <span class="n">solve_univariate_inequality</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_univariate_inequality</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">((2 &lt;= x) &amp; (x &lt; oo)) | ((x &lt;= -2) &amp; (-oo &lt; x))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_univariate_inequality</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">relational</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Union(Interval(-oo, -2), Interval(2, oo))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">domain</span> <span class="o">=</span> <span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_univariate_inequality</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>
<span class="go">Interval(2, oo)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_univariate_inequality</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">relational</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Interval.open(0, pi)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-modelparameters.sympy.solvers.ode">
<span id="modelparameters-sympy-solvers-ode-module"></span><h2>modelparameters.sympy.solvers.ode module<a class="headerlink" href="#module-modelparameters.sympy.solvers.ode" title="Permalink to this headline">¶</a></h2>
<p>This module contains <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> and different helper
functions that it uses.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> solves ordinary differential equations.
See the docstring on the various functions for their uses.  Note that partial
differential equations support is in <code class="docutils literal notranslate"><span class="pre">pde.py</span></code>.  Note that hint functions
have docstrings describing their various methods, but they are intended for
internal use.  Use <code class="docutils literal notranslate"><span class="pre">dsolve(ode,</span> <span class="pre">func,</span> <span class="pre">hint=hint)</span></code> to solve an ODE using a
specific hint.  See also the docstring on
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>.</p>
<p><strong>Functions in this module</strong></p>
<blockquote>
<div><p>These are the user functions in this module:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> - Solves ODEs.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code> - Classifies ODEs into
possible hints for <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">checkodesol()</span></code> - Checks if an equation is the
solution to an ODE.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">homogeneous_order()</span></code> - Returns the
homogeneous order of an expression.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">infinitesimals()</span></code> - Returns the infinitesimals
of the Lie group of point transformations of an ODE, such that it is
invariant.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_checkinfsol()</span></code> - Checks if the given infinitesimals
are the actual infinitesimals of a first order ODE.</p></li>
</ul>
<p>These are the non-solver helper functions that are for internal use.  The
user should use the various options to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> to obtain the functionality provided
by these functions:</p>
<ul class="simple">
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code> - Does all forms of ODE
simplification.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_sol_simplicity()</span></code> - A key function for
comparing solutions by simplicity.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code> - Simplifies arbitrary
constants.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">constant_renumber()</span></code> - Renumber arbitrary
constants.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">_handle_Integral()</span></code> - Evaluate unevaluated
Integrals.</p></li>
</ul>
<p>See also the docstrings of these functions.</p>
</div></blockquote>
<p><strong>Currently implemented solver methods</strong></p>
<p>The following methods are implemented for solving ordinary differential
equations.  See the docstrings of the various hint functions for more
information on each (run <code class="docutils literal notranslate"><span class="pre">help(ode)</span></code>):</p>
<blockquote>
<div><ul class="simple">
<li><p>1st order separable differential equations.</p></li>
<li><p>1st order differential equations whose coefficients or <cite>dx</cite> and <cite>dy</cite> are
functions homogeneous of the same order.</p></li>
<li><p>1st order exact differential equations.</p></li>
<li><p>1st order linear differential equations.</p></li>
<li><p>1st order Bernoulli differential equations.</p></li>
<li><p>Power series solutions for first order differential equations.</p></li>
<li><p>Lie Group method of solving first order differential equations.</p></li>
<li><p>2nd order Liouville differential equations.</p></li>
<li><p>Power series solutions for second order differential equations
at ordinary and regular singular points.</p></li>
<li><p><cite>n</cite>th order linear homogeneous differential equation with constant
coefficients.</p></li>
<li><p><cite>n</cite>th order linear inhomogeneous differential equation with constant
coefficients using the method of undetermined coefficients.</p></li>
<li><p><cite>n</cite>th order linear inhomogeneous differential equation with constant
coefficients using the method of variation of parameters.</p></li>
</ul>
</div></blockquote>
<p><strong>Philosophy behind this module</strong></p>
<p>This module is designed to make it easy to add new ODE solving methods without
having to mess with the solving code for other methods.  The idea is that
there is a <code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code> function, which takes in
an ODE and tells you what hints, if any, will solve the ODE.  It does this
without attempting to solve the ODE, so it is fast.  Each solving method is a
hint, and it has its own function, named <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;</span></code>.  That function takes
in the ODE and any match expression gathered by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code> and returns a solved result.  If
this result has any integrals in it, the hint function will return an
unevaluated <code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code> class.
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>, which is the user wrapper function
around all of this, will then call <code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code> on
the result, which, among other things, will attempt to solve the equation for
the dependent variable (the function we are solving for), simplify the
arbitrary constants in the expression, and evaluate any integrals, if the hint
allows it.</p>
<p><strong>How to add new solution methods</strong></p>
<p>If you have an ODE that you want <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> to be
able to solve, try to avoid adding special case code here.  Instead, try
finding a general method that will solve your ODE, as well as others.  This
way, the <code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code> module will become more robust, and
unhindered by special case hacks.  WolphramAlpha and Maple’s
DETools[odeadvisor] function are two resources you can use to classify a
specific ODE.  It is also better for a method to work with an <cite>n</cite>th order ODE
instead of only with specific orders, if possible.</p>
<p>To add a new method, there are a few things that you need to do.  First, you
need a hint name for your method.  Try to name your hint so that it is
unambiguous with all other methods, including ones that may not be implemented
yet.  If your method uses integrals, also include a <code class="docutils literal notranslate"><span class="pre">hint_Integral</span></code> hint.
If there is more than one way to solve ODEs with your method, include a hint
for each one, as well as a <code class="docutils literal notranslate"><span class="pre">&lt;hint&gt;_best</span></code> hint.  Your <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;_best()</span></code>
function should choose the best using min with <code class="docutils literal notranslate"><span class="pre">ode_sol_simplicity</span></code> as the
key argument.  See
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_best()</span></code>, for example.
The function that uses your method will be called <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;()</span></code>, so the
hint must only use characters that are allowed in a Python function name
(alphanumeric characters and the underscore ‘<code class="docutils literal notranslate"><span class="pre">_</span></code>’ character).  Include a
function for every hint, except for <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hints
(<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> takes care of those automatically).
Hint names should be all lowercase, unless a word is commonly capitalized
(such as Integral or Bernoulli).  If you have a hint that you do not want to
run with <code class="docutils literal notranslate"><span class="pre">all_Integral</span></code> that doesn’t have an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> counterpart (such
as a best hint that would defeat the purpose of <code class="docutils literal notranslate"><span class="pre">all_Integral</span></code>), you will
need to remove it manually in the <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> code.
See also the <code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code> docstring for
guidelines on writing a hint name.</p>
<p>Determine <em>in general</em> how the solutions returned by your method compare with
other methods that can potentially solve the same ODEs.  Then, put your hints
in the <code class="xref py py-data docutils literal notranslate"><span class="pre">allhints</span></code> tuple in the order that they
should be called.  The ordering of this tuple determines which hints are
default.  Note that exceptions are ok, because it is easy for the user to
choose individual hints with <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>.  In
general, <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> variants should go at the end of the list, and
<code class="docutils literal notranslate"><span class="pre">_best</span></code> variants should go before the various hints they apply to.  For
example, the <code class="docutils literal notranslate"><span class="pre">undetermined_coefficients</span></code> hint comes before the
<code class="docutils literal notranslate"><span class="pre">variation_of_parameters</span></code> hint because, even though variation of parameters
is more general than undetermined coefficients, undetermined coefficients
generally returns cleaner results for the ODEs that it can solve than
variation of parameters does, and it does not require integration, so it is
much faster.</p>
<p>Next, you need to have a match expression or a function that matches the type
of the ODE, which you should put in <code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code>
(if the match function is more than just a few lines, like
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_undetermined_coefficients_match()</span></code>, it should go
outside of <code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code>).  It should match the
ODE without solving for it as much as possible, so that
<code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code> remains fast and is not hindered by
bugs in solving code.  Be sure to consider corner cases.  For example, if your
solution method involves dividing by something, make sure you exclude the case
where that division will be 0.</p>
<p>In most cases, the matching of the ODE will also give you the various parts
that you need to solve it.  You should put that in a dictionary (<code class="docutils literal notranslate"><span class="pre">.match()</span></code>
will do this for you), and add that as <code class="docutils literal notranslate"><span class="pre">matching_hints['hint']</span> <span class="pre">=</span> <span class="pre">matchdict</span></code>
in the relevant part of <code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code>.
<code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code> will then send this to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>, which will send it to your function as
the <code class="docutils literal notranslate"><span class="pre">match</span></code> argument.  Your function should be named <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;(eq,</span> <span class="pre">func,</span>
<span class="pre">order,</span> <span class="pre">match)`.</span>&#160; <span class="pre">If</span> <span class="pre">you</span> <span class="pre">need</span> <span class="pre">to</span> <span class="pre">send</span> <span class="pre">more</span> <span class="pre">information,</span> <span class="pre">put</span> <span class="pre">it</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">``match</span></code>
dictionary.  For example, if you had to substitute in a dummy variable in
<code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code> to match the ODE, you will need to
pass it to your function using the <cite>match</cite> dict to access it.  You can access
the independent variable using <code class="docutils literal notranslate"><span class="pre">func.args[0]</span></code>, and the dependent variable
(the function you are trying to solve for) as <code class="docutils literal notranslate"><span class="pre">func.func</span></code>.  If, while trying
to solve the ODE, you find that you cannot, raise <code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> will catch this error with the <code class="docutils literal notranslate"><span class="pre">all</span></code>
meta-hint, rather than causing the whole routine to fail.</p>
<p>Add a docstring to your function that describes the method employed.  Like
with anything else in SymPy, you will need to add a doctest to the docstring,
in addition to real tests in <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code>.  Try to maintain consistency
with the other hint functions’ docstrings.  Add your method to the list at the
top of this docstring.  Also, add your method to <code class="docutils literal notranslate"><span class="pre">ode.rst</span></code> in the
<code class="docutils literal notranslate"><span class="pre">docs/src</span></code> directory, so that the Sphinx docs will pull its docstring into
the main SymPy documentation.  Be sure to make the Sphinx documentation by
running <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">html</span></code> from within the doc directory to verify that the
docstring formats correctly.</p>
<p>If your solution method involves integrating, use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Integral()</span></code> instead of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code>.  This allows the user to bypass
hard/slow integration by using the <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> variant of your hint.  In
most cases, calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.core.basic.Basic.doit()</span></code> will integrate your
solution.  If this is not the case, you will need to write special code in
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_handle_Integral()</span></code>.  Arbitrary constants should be
symbols named <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code>, and so on.  All solution methods should return
an equality instance.  If you need an arbitrary number of arbitrary constants,
you can use <code class="docutils literal notranslate"><span class="pre">constants</span> <span class="pre">=</span> <span class="pre">numbered_symbols(prefix='C',</span> <span class="pre">cls=Symbol,</span> <span class="pre">start=1)</span></code>.
If it is possible to solve for the dependent function in a general way, do so.
Otherwise, do as best as you can, but do not call solve in your
<code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;()</span></code> function.  <code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code> will attempt
to solve the solution for you, so you do not need to do that.  Lastly, if your
ODE has a common simplification that can be applied to your solutions, you can
add a special case in <code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code> for it.  For
example, solutions returned from the <code class="docutils literal notranslate"><span class="pre">1st_homogeneous_coeff</span></code> hints often
have many <code class="xref py py-meth docutils literal notranslate"><span class="pre">log()</span></code> terms, so
<code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code> calls
<code class="xref py py-meth docutils literal notranslate"><span class="pre">logcombine()</span></code> on them (it also helps to write
the arbitrary constant as <code class="docutils literal notranslate"><span class="pre">log(C1)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">C1</span></code> in this case).  Also
consider common ways that you can rearrange your solution to have
<code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code> take better advantage of it.  It is
better to put simplification in <code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code> than in
your method, because it can then be turned off with the simplify flag in
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>.  If you have any extraneous
simplification in your function, be sure to only run it using <code class="docutils literal notranslate"><span class="pre">if</span>
<span class="pre">match.get('simplify',</span> <span class="pre">True):</span></code>, especially if it can be slow or if it can
reduce the domain of the solution.</p>
<p>Finally, as with every contribution to SymPy, your method will need to be
tested.  Add a test for each method in <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code>.  Follow the
conventions there, i.e., test the solver using <code class="docutils literal notranslate"><span class="pre">dsolve(eq,</span> <span class="pre">f(x),</span>
<span class="pre">hint=your_hint)</span></code>, and also test the solution using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">checkodesol()</span></code> (you can put these in a separate
tests and skip/XFAIL if it runs too slow/doesn’t work).  Be sure to call your
hint specifically in <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>, that way the test
won’t be broken simply by the introduction of another matching hint.  If your
method works for higher order (&gt;1) ODEs, you will need to run <code class="docutils literal notranslate"><span class="pre">sol</span> <span class="pre">=</span>
<span class="pre">constant_renumber(sol,</span> <span class="pre">'C',</span> <span class="pre">1,</span> <span class="pre">order)</span></code> for each solution, where <code class="docutils literal notranslate"><span class="pre">order</span></code> is
the order of the ODE.  This is because <code class="docutils literal notranslate"><span class="pre">constant_renumber</span></code> renumbers the
arbitrary constants by printing order, which is platform dependent.  Try to
test every corner case of your solver, including a range of orders if it is a
<cite>n</cite>th order solver, but if your solver is slow, such as if it involves hard
integration, try to keep the test run time down.</p>
<p>Feel free to refactor existing hints to avoid duplicating code or creating
inconsistencies.  If you can show that your method exactly duplicates an
existing method, including in the simplicity and speed of obtaining the
solutions, then you can remove the old, less general method.  The existing
code is tested extensively in <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code>, so if anything is broken, one
of those tests will surely fail.</p>
<dl class="py data">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.allhints">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">allhints</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">('separable',</span> <span class="pre">'1st_exact',</span> <span class="pre">'1st_linear',</span> <span class="pre">'Bernoulli',</span> <span class="pre">'Riccati_special_minus2',</span> <span class="pre">'1st_homogeneous_coeff_best',</span> <span class="pre">'1st_homogeneous_coeff_subs_indep_div_dep',</span> <span class="pre">'1st_homogeneous_coeff_subs_dep_div_indep',</span> <span class="pre">'almost_linear',</span> <span class="pre">'linear_coefficients',</span> <span class="pre">'separable_reduced',</span> <span class="pre">'1st_power_series',</span> <span class="pre">'lie_group',</span> <span class="pre">'nth_linear_constant_coeff_homogeneous',</span> <span class="pre">'nth_linear_euler_eq_homogeneous',</span> <span class="pre">'nth_linear_constant_coeff_undetermined_coefficients',</span> <span class="pre">'nth_linear_euler_eq_nonhomogeneous_undetermined_coefficients',</span> <span class="pre">'nth_linear_constant_coeff_variation_of_parameters',</span> <span class="pre">'nth_linear_euler_eq_nonhomogeneous_variation_of_parameters',</span> <span class="pre">'Liouville',</span> <span class="pre">'2nd_power_series_ordinary',</span> <span class="pre">'2nd_power_series_regular',</span> <span class="pre">'separable_Integral',</span> <span class="pre">'1st_exact_Integral',</span> <span class="pre">'1st_linear_Integral',</span> <span class="pre">'Bernoulli_Integral',</span> <span class="pre">'1st_homogeneous_coeff_subs_indep_div_dep_Integral',</span> <span class="pre">'1st_homogeneous_coeff_subs_dep_div_indep_Integral',</span> <span class="pre">'almost_linear_Integral',</span> <span class="pre">'linear_coefficients_Integral',</span> <span class="pre">'separable_reduced_Integral',</span> <span class="pre">'nth_linear_constant_coeff_variation_of_parameters_Integral',</span> <span class="pre">'nth_linear_euler_eq_nonhomogeneous_variation_of_parameters_Integral',</span> <span class="pre">'Liouville_Integral')</span></em><a class="headerlink" href="#modelparameters.sympy.solvers.ode.allhints" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a list of hints in the order that they should be preferred by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code>. In general, hints earlier in the
list should produce simpler solutions than those later in the list (for
ODEs that fit both).  For now, the order of this list is based on empirical
observations by the developers of SymPy.</p>
<p>The hint used by <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> for a specific ODE
can be overridden (see the docstring).</p>
<p>In general, <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hints are grouped at the end of the list, unless
there is a method that returns an unevaluable integral most of the time
(which go near the end of the list anyway).  <code class="docutils literal notranslate"><span class="pre">default</span></code>, <code class="docutils literal notranslate"><span class="pre">all</span></code>,
<code class="docutils literal notranslate"><span class="pre">best</span></code>, and <code class="docutils literal notranslate"><span class="pre">all_Integral</span></code> meta-hints should not be included in this
list, but <code class="docutils literal notranslate"><span class="pre">_best</span></code> and <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hints should be included.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.check_linear_2eq_order1">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">check_linear_2eq_order1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_coef</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#check_linear_2eq_order1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.check_linear_2eq_order1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.check_linear_2eq_order2">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">check_linear_2eq_order2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_coef</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#check_linear_2eq_order2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.check_linear_2eq_order2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.check_linear_3eq_order1">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">check_linear_3eq_order1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_coef</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#check_linear_3eq_order1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.check_linear_3eq_order1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.check_linear_neq_order1">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">check_linear_neq_order1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_coef</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#check_linear_neq_order1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.check_linear_neq_order1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.check_nonlinear_2eq_order1">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">check_nonlinear_2eq_order1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_coef</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#check_nonlinear_2eq_order1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.check_nonlinear_2eq_order1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.check_nonlinear_2eq_order2">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">check_nonlinear_2eq_order2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_coef</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#check_nonlinear_2eq_order2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.check_nonlinear_2eq_order2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.check_nonlinear_3eq_order1">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">check_nonlinear_3eq_order1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_coef</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#check_nonlinear_3eq_order1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.check_nonlinear_3eq_order1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.check_nonlinear_3eq_order2">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">check_nonlinear_3eq_order2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_coef</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#check_nonlinear_3eq_order2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.check_nonlinear_3eq_order2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.checkinfsol">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">checkinfsol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infinitesimals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#checkinfsol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.checkinfsol" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to check if the given infinitesimals are the
actual infinitesimals of the given first order differential equation.
This method is specific to the Lie Group Solver of ODEs.</p>
<p>As of now, it simply checks, by substituting the infinitesimals in the
partial differential equation.</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \eta}{\partial x} + \left(\frac{\partial \eta}{\partial y}
- \frac{\partial \xi}{\partial x}\right)*h
- \frac{\partial \xi}{\partial y}*h^{2}
- \xi\frac{\partial h}{\partial x} - \eta\frac{\partial h}{\partial y} = 0\]</div>
<p>where <cite>eta</cite>, and <cite>xi</cite> are the infinitesimals and <cite>h(x,y) = frac{dy}{dx}</cite></p>
<p>The infinitesimals should be given in the form of a list of dicts
<code class="docutils literal notranslate"><span class="pre">[{xi(x,</span> <span class="pre">y):</span> <span class="pre">inf,</span> <span class="pre">eta(x,</span> <span class="pre">y):</span> <span class="pre">inf}]</span></code>, corresponding to the
output of the function infinitesimals. It returns a list
of values of the form <code class="docutils literal notranslate"><span class="pre">[(True/False,</span> <span class="pre">sol)]</span></code> where <code class="docutils literal notranslate"><span class="pre">sol</span></code> is the value
obtained after substituting the infinitesimals in the PDE. If it
is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then <code class="docutils literal notranslate"><span class="pre">sol</span></code> would be 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.checkodesol">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">checkodesol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solve_for_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#checkodesol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.checkodesol" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes <code class="docutils literal notranslate"><span class="pre">sol</span></code> into <code class="docutils literal notranslate"><span class="pre">ode</span></code> and checks that the result is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>This only works when <code class="docutils literal notranslate"><span class="pre">func</span></code> is one function, like <cite>f(x)</cite>.  <code class="docutils literal notranslate"><span class="pre">sol</span></code> can
be a single solution or a list of solutions.  Each solution may be an
<code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code> that the solution satisfies,
e.g. <code class="docutils literal notranslate"><span class="pre">Eq(f(x),</span> <span class="pre">C1),</span> <span class="pre">Eq(f(x)</span> <span class="pre">+</span> <span class="pre">C1,</span> <span class="pre">0)</span></code>; or simply an
<code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">-</span> <span class="pre">C1</span></code>. In most cases it
will not be necessary to explicitly identify the function, but if the
function cannot be inferred from the original equation it can be supplied
through the <code class="docutils literal notranslate"><span class="pre">func</span></code> argument.</p>
<p>If a sequence of solutions is passed, the same sort of container will be
used to return the result for each solution.</p>
<p>It tries the following methods, in order, until it finds zero equivalence:</p>
<ol class="arabic simple">
<li><p>Substitute the solution for <cite>f</cite> in the original equation.  This only
works if <code class="docutils literal notranslate"><span class="pre">ode</span></code> is solved for <cite>f</cite>.  It will attempt to solve it first
unless <code class="docutils literal notranslate"><span class="pre">solve_for_func</span> <span class="pre">==</span> <span class="pre">False</span></code>.</p></li>
<li><p>Take <cite>n</cite> derivatives of the solution, where <cite>n</cite> is the order of
<code class="docutils literal notranslate"><span class="pre">ode</span></code>, and check to see if that is equal to the solution.  This only
works on exact ODEs.</p></li>
<li><p>Take the 1st, 2nd, …, <cite>n</cite>th derivatives of the solution, each time
solving for the derivative of <cite>f</cite> of that order (this will always be
possible because <cite>f</cite> is a linear operator). Then back substitute each
derivative into <code class="docutils literal notranslate"><span class="pre">ode</span></code> in reverse order.</p></li>
</ol>
<p>This function returns a tuple.  The first item in the tuple is <code class="docutils literal notranslate"><span class="pre">True</span></code> if
the substitution results in <code class="docutils literal notranslate"><span class="pre">0</span></code>, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise. The second
item in the tuple is what the substitution results in.  It should always
be <code class="docutils literal notranslate"><span class="pre">0</span></code> if the first item is <code class="docutils literal notranslate"><span class="pre">True</span></code>. Note that sometimes this function
will <code class="docutils literal notranslate"><span class="pre">False</span></code>, but with an expression that is identically equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>,
instead of returning <code class="docutils literal notranslate"><span class="pre">True</span></code>.  This is because
<code class="xref py py-meth docutils literal notranslate"><span class="pre">simplify()</span></code> cannot reduce the expression
to <code class="docutils literal notranslate"><span class="pre">0</span></code>.  If an expression returned by this function vanishes
identically, then <code class="docutils literal notranslate"><span class="pre">sol</span></code> really is a solution to <code class="docutils literal notranslate"><span class="pre">ode</span></code>.</p>
<p>If this function seems to hang, it is probably because of a hard
simplification.</p>
<p>To use this function to test, test the first item of the tuple.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">checkodesol</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">(True, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(False, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.checksysodesol">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">checksysodesol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#checksysodesol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.checksysodesol" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes corresponding <code class="docutils literal notranslate"><span class="pre">sols</span></code> for each functions into each <code class="docutils literal notranslate"><span class="pre">eqs</span></code> and
checks that the result of substitutions for each equation is <code class="docutils literal notranslate"><span class="pre">0</span></code>. The
equations and solutions passed can be any iterable.</p>
<p>This only works when each <code class="docutils literal notranslate"><span class="pre">sols</span></code> have one function only, like <cite>x(t)</cite> or <cite>y(t)</cite>.
For each function, <code class="docutils literal notranslate"><span class="pre">sols</span></code> can have a single solution or a list of solutions.
In most cases it will not be necessary to explicitly identify the function,
but if the function cannot be inferred from the original equation it
can be supplied through the <code class="docutils literal notranslate"><span class="pre">func</span></code> argument.</p>
<p>When a sequence of equations is passed, the same sequence is used to return
the result for each equation with each function substitued with corresponding
solutions.</p>
<p>It tries the following method to find zero equivalence for each equation:</p>
<p>Substitute the solutions for functions, like <cite>x(t)</cite> and <cite>y(t)</cite> into the
original equations containing those functions.
This function returns a tuple.  The first item in the tuple is <code class="docutils literal notranslate"><span class="pre">True</span></code> if
the substitution results for each equation is <code class="docutils literal notranslate"><span class="pre">0</span></code>, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.
The second item in the tuple is what the substitution results in.  Each element
of the <code class="docutils literal notranslate"><span class="pre">list</span></code> should always be <code class="docutils literal notranslate"><span class="pre">0</span></code> corresponding to each equation if the
first item is <code class="docutils literal notranslate"><span class="pre">True</span></code>. Note that sometimes this function may return <code class="docutils literal notranslate"><span class="pre">False</span></code>,
but with an expression that is identically equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>, instead of returning
<code class="docutils literal notranslate"><span class="pre">True</span></code>.  This is because <code class="xref py py-meth docutils literal notranslate"><span class="pre">simplify()</span></code> cannot
reduce the expression to <code class="docutils literal notranslate"><span class="pre">0</span></code>.  If an expression returned by each function
vanishes identically, then <code class="docutils literal notranslate"><span class="pre">sols</span></code> really is a solution to <code class="docutils literal notranslate"><span class="pre">eqs</span></code>.</p>
<p>If this function seems to hang, it is probably because of a difficult simplification.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">checksysodesol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;C1:3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y&#39;</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">17</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">12</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">C1</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">S</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span><span class="n">Eq</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">C1</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">C2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">S</span><span class="p">(</span><span class="mi">46</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checksysodesol</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">(True, [0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">t</span><span class="p">)))),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">t</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">t</span><span class="p">)))),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">t</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checksysodesol</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">(True, [0, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.classify_ode">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">classify_ode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#classify_ode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.classify_ode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of possible <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>
classifications for an ODE.</p>
<p>The tuple is ordered so that first item is the classification that
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> uses to solve the ODE by default.  In
general, classifications at the near the beginning of the list will
produce better solutions faster than those near the end, thought there are
always exceptions.  To make <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> use a
different classification, use <code class="docutils literal notranslate"><span class="pre">dsolve(ODE,</span> <span class="pre">func,</span>
<span class="pre">hint=&lt;classification&gt;)</span></code>.  See also the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> docstring for different meta-hints
you can use.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dict</span></code> is true, <code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code> will
return a dictionary of <code class="docutils literal notranslate"><span class="pre">hint:match</span></code> expression terms. This is intended
for internal use by <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>.  Note that
because dictionaries are ordered arbitrarily, this will most likely not be
in the same order as the tuple.</p>
<p>You can get help on different hints by executing
<code class="docutils literal notranslate"><span class="pre">help(ode.ode_hintname)</span></code>, where <code class="docutils literal notranslate"><span class="pre">hintname</span></code> is the name of the hint
without <code class="docutils literal notranslate"><span class="pre">_Integral</span></code>.</p>
<p>See <code class="xref py py-data docutils literal notranslate"><span class="pre">allhints</span></code> or the
<code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code> docstring for a list of all supported hints
that can be returned from <code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code>.</p>
<p class="rubric">Notes</p>
<p>These are remarks on hint names.</p>
<p><code class="docutils literal notranslate"><span class="pre">_Integral</span></code></p>
<blockquote>
<div><p>If a classification has <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> at the end, it will return the
expression with an unevaluated <code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code>
class in it.  Note that a hint may do this anyway if
<code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code> cannot do the integral,
though just using an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> will do so much faster.  Indeed, an
<code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint will always be faster than its corresponding hint
without <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> because
<code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code> is an expensive routine.
If <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> hangs, it is probably because
<code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code> is hanging on a tough or
impossible integral.  Try using an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint or
<code class="docutils literal notranslate"><span class="pre">all_Integral</span></code> to get it return something.</p>
<p>Note that some hints do not have <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> counterparts.  This is
because <code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code> is not used in solving
the ODE for those method. For example, <cite>n</cite>th order linear homogeneous
ODEs with constant coefficients do not require integration to solve,
so there is no <code class="docutils literal notranslate"><span class="pre">nth_linear_homogeneous_constant_coeff_Integrate</span></code>
hint. You can easily evaluate any unevaluated
<code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code>s in an expression by doing
<code class="docutils literal notranslate"><span class="pre">expr.doit()</span></code>.</p>
</div></blockquote>
<p>Ordinals</p>
<blockquote>
<div><p>Some hints contain an ordinal such as <code class="docutils literal notranslate"><span class="pre">1st_linear</span></code>.  This is to help
differentiate them from other hints, as well as from other methods
that may not be implemented yet. If a hint has <code class="docutils literal notranslate"><span class="pre">nth</span></code> in it, such as
the <code class="docutils literal notranslate"><span class="pre">nth_linear</span></code> hints, this means that the method used to applies
to ODEs of any order.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">indep</span></code> and <code class="docutils literal notranslate"><span class="pre">dep</span></code></p>
<blockquote>
<div><p>Some hints contain the words <code class="docutils literal notranslate"><span class="pre">indep</span></code> or <code class="docutils literal notranslate"><span class="pre">dep</span></code>.  These reference
the independent variable and the dependent function, respectively. For
example, if an ODE is in terms of <cite>f(x)</cite>, then <code class="docutils literal notranslate"><span class="pre">indep</span></code> will refer to
<cite>x</cite> and <code class="docutils literal notranslate"><span class="pre">dep</span></code> will refer to <cite>f</cite>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">subs</span></code></p>
<blockquote>
<div><p>If a hints has the word <code class="docutils literal notranslate"><span class="pre">subs</span></code> in it, it means the the ODE is solved
by substituting the expression given after the word <code class="docutils literal notranslate"><span class="pre">subs</span></code> for a
single dummy variable.  This is usually in terms of <code class="docutils literal notranslate"><span class="pre">indep</span></code> and
<code class="docutils literal notranslate"><span class="pre">dep</span></code> as above.  The substituted expression will be written only in
characters allowed for names of Python objects, meaning operators will
be spelled out.  For example, <code class="docutils literal notranslate"><span class="pre">indep</span></code>/<code class="docutils literal notranslate"><span class="pre">dep</span></code> will be written as
<code class="docutils literal notranslate"><span class="pre">indep_div_dep</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">coeff</span></code></p>
<blockquote>
<div><p>The word <code class="docutils literal notranslate"><span class="pre">coeff</span></code> in a hint refers to the coefficients of something
in the ODE, usually of the derivative terms.  See the docstring for
the individual methods for more info (<code class="docutils literal notranslate"><span class="pre">help(ode)</span></code>).  This is
contrast to <code class="docutils literal notranslate"><span class="pre">coefficients</span></code>, as in <code class="docutils literal notranslate"><span class="pre">undetermined_coefficients</span></code>,
which refers to the common name of a method.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">_best</span></code></p>
<blockquote>
<div><p>Methods that have more than one fundamental way to solve will have a
hint for each sub-method and a <code class="docutils literal notranslate"><span class="pre">_best</span></code> meta-classification. This
will evaluate all hints and return the best, using the same
considerations as the normal <code class="docutils literal notranslate"><span class="pre">best</span></code> meta-hint.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">classify_ode</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">(&#39;separable&#39;, &#39;1st_linear&#39;, &#39;1st_homogeneous_coeff_best&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;,</span>
<span class="go">&#39;1st_power_series&#39;, &#39;lie_group&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_homogeneous&#39;,</span>
<span class="go">&#39;separable_Integral&#39;, &#39;1st_linear_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.classify_sysode">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">classify_sysode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">funcs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#classify_sysode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.classify_sysode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of parameter names and values that define the system
of ordinary differential equations in <code class="docutils literal notranslate"><span class="pre">eq</span></code>.
The parameters are further used in
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> for solving that system.</p>
<p>The parameter names and values are:</p>
<p>‘is_linear’ (boolean), which tells whether the given system is linear.
Note that “linear” here refers to the operator: terms such as <code class="docutils literal notranslate"><span class="pre">x*diff(x,t)</span></code> are
nonlinear, whereas terms like <code class="docutils literal notranslate"><span class="pre">sin(t)*diff(x,t)</span></code> are still linear operators.</p>
<p>‘func’ (list) contains the :py:class:<a href="#id1"><span class="problematic" id="id2">`</span></a>~sympy.core.function.Function`s that
appear with a derivative in the ODE, i.e. those that we are trying to solve
the ODE for.</p>
<p>‘order’ (dict) with the maximum derivative for each element of the ‘func’
parameter.</p>
<p>‘func_coeff’ (dict) with the coefficient for each triple <code class="docutils literal notranslate"><span class="pre">(equation</span> <span class="pre">number,</span>
<span class="pre">function,</span> <span class="pre">order)`</span></code>. The coefficients are those subexpressions that do not
appear in ‘func’, and hence can be considered constant for purposes of ODE
solving.</p>
<p>‘eq’ (list) with the equations from <code class="docutils literal notranslate"><span class="pre">eq</span></code>, sympified and transformed into
expressions (we are solving for these expressions to be zero).</p>
<p>‘no_of_equations’ (int) is the number of equations (same as <code class="docutils literal notranslate"><span class="pre">len(eq)</span></code>).</p>
<p>‘type_of_equation’ (string) is an internal classification of the type of
ODE.</p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode-toc1.htm">http://eqworld.ipmnet.ru/en/solutions/sysode/sode-toc1.htm</a>
-A. D. Polyanin and A. V. Manzhirov, Handbook of Mathematics for Engineers and Scientists</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">classify_sysode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;f, x, y&#39;</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;k, l, m, n&#39;</span><span class="p">,</span> <span class="n">Integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span> <span class="p">;</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="p">;</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">x1</span><span class="p">,</span> <span class="mi">12</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y1</span><span class="p">,</span> <span class="mi">11</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_sysode</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">{&#39;eq&#39;: [-12*x(t) + 6*y(t) + 5*Derivative(x(t), t), -11*x(t) - 3*y(t) + 2*Derivative(y(t), t)],</span>
<span class="go">&#39;func&#39;: [x(t), y(t)], &#39;func_coeff&#39;: {(0, x(t), 0): -12, (0, x(t), 1): 5, (0, y(t), 0): 6,</span>
<span class="go">(0, y(t), 1): 0, (1, x(t), 0): -11, (1, x(t), 1): 0, (1, y(t), 0): -3, (1, y(t), 1): 2},</span>
<span class="go">&#39;is_linear&#39;: True, &#39;no_of_equation&#39;: 2, &#39;order&#39;: {x(t): 1, y(t): 1}, &#39;type_of_equation&#39;: &#39;type1&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="mi">5</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="o">-</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_sysode</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">{&#39;eq&#39;: [-t**2*y(t) - 5*t*x(t) + Derivative(x(t), t), t**2*x(t) - 5*t*y(t) + Derivative(y(t), t)],</span>
<span class="go">&#39;func&#39;: [x(t), y(t)], &#39;func_coeff&#39;: {(0, x(t), 0): -5*t, (0, x(t), 1): 1, (0, y(t), 0): -t**2,</span>
<span class="go">(0, y(t), 1): 0, (1, x(t), 0): t**2, (1, x(t), 1): 0, (1, y(t), 0): -5*t, (1, y(t), 1): 1},</span>
<span class="go">&#39;is_linear&#39;: True, &#39;no_of_equation&#39;: 2, &#39;order&#39;: {x(t): 1, y(t): 1}, &#39;type_of_equation&#39;: &#39;type4&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.constant_renumber">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">constant_renumber</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">startnumber</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endnumber</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#constant_renumber"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.constant_renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Renumber arbitrary constants in <code class="docutils literal notranslate"><span class="pre">expr</span></code> to have numbers 1 through <cite>N</cite>
where <cite>N</cite> is <code class="docutils literal notranslate"><span class="pre">endnumber</span> <span class="pre">-</span> <span class="pre">startnumber</span> <span class="pre">+</span> <span class="pre">1</span></code> at most.
In the process, this reorders expression terms in a standard way.</p>
<p>This is a simple function that goes through and renumbers any
<code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code> with a name in the form <code class="docutils literal notranslate"><span class="pre">symbolname</span>
<span class="pre">+</span> <span class="pre">num</span></code> where <code class="docutils literal notranslate"><span class="pre">num</span></code> is in the range from <code class="docutils literal notranslate"><span class="pre">startnumber</span></code> to
<code class="docutils literal notranslate"><span class="pre">endnumber</span></code>.</p>
<p>Symbols are renumbered based on <code class="docutils literal notranslate"><span class="pre">.sort_key()</span></code>, so they should be
numbered roughly in the order that they appear in the final, printed
expression.  Note that this ordering is based in part on hashes, so it can
produce different results on different machines.</p>
<p>The structure of this function is very similar to that of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">constant_renumber</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">C4</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,C:5&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Only constants in the given range (inclusive) are renumbered;
the renumbering always starts from 1:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C1</span> <span class="o">+</span> <span class="n">C3</span> <span class="o">+</span> <span class="n">C4</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">C1 + C2 + C4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="n">C1</span> <span class="o">+</span> <span class="n">C3</span> <span class="o">+</span> <span class="n">C4</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">C0 + 2*C1 + C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">C1</span> <span class="o">+</span> <span class="n">C2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">C1 + 3*C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">                2</span>
<span class="go">C1*x + C2 + C3*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">                2</span>
<span class="go">C1 + C2*x + C3*x</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.constantsimp">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">constantsimp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constants</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#constantsimp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.constantsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies an expression with arbitrary constants in it.</p>
<p>This function is written specifically to work with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>, and is not intended for general use.</p>
<p>Simplification is done by “absorbing” the arbitrary constants into other
arbitrary constants, numbers, and symbols that they are not independent
of.</p>
<p>The symbols must all have the same name with numbers after it, for
example, <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code>, <code class="docutils literal notranslate"><span class="pre">C3</span></code>.  The <code class="docutils literal notranslate"><span class="pre">symbolname</span></code> here would be
‘<code class="docutils literal notranslate"><span class="pre">C</span></code>’, the <code class="docutils literal notranslate"><span class="pre">startnumber</span></code> would be 1, and the <code class="docutils literal notranslate"><span class="pre">endnumber</span></code> would be 3.
If the arbitrary constants are independent of the variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, then the
independent symbol would be <code class="docutils literal notranslate"><span class="pre">x</span></code>.  There is no need to specify the
dependent function, such as <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>, because it already has the
independent symbol, <code class="docutils literal notranslate"><span class="pre">x</span></code>, in it.</p>
<p>Because terms are “absorbed” into arbitrary constants and because
constants are renumbered after simplifying, the arbitrary constants in
expr are not necessarily equal to the ones of the same name in the
returned result.</p>
<p>If two or more arbitrary constants are added, multiplied, or raised to the
power of each other, they are first absorbed together into a single
arbitrary constant.  Then the new constant is combined into other terms if
necessary.</p>
<p>Absorption of constants is done with limited assistance:</p>
<ol class="arabic simple">
<li><p>terms of <code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code>s are collected to try join
constants so <cite>e^x (C_1 cos(x) + C_2 cos(x))</cite> will simplify to <cite>e^x
C_1 cos(x)</cite>;</p></li>
<li><p>powers with exponents that are <code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code>s are
expanded so <cite>e^{C_1 + x}</cite> will be simplified to <cite>C_1 e^x</cite>.</p></li>
</ol>
<p>Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">constant_renumber()</span></code> to renumber constants
after simplification or else arbitrary numbers on constants may appear,
e.g. <cite>C_1 + C_3 x</cite>.</p>
<p>In rare cases, a single constant can be “simplified” into two constants.
Every differential equation solution should have as many arbitrary
constants as the order of the differential equation.  The result here will
be technically correct, but it may, for example, have <cite>C_1</cite> and <cite>C_2</cite> in
an expression, when <cite>C_1</cite> is actually equal to <cite>C_2</cite>.  Use your discretion
in such situations, and also take advantage of the ability to use hints in
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">constantsimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;C1, C2, C3, x, y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1 + x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span><span class="o">*</span><span class="n">C2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">C2</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1 + C3*x</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.dsolve">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">dsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#dsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.dsolve" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Solves any (supported) kind of ordinary differential equation and
system of ordinary differential equations.</p>
<p>It is classified under this when number of equation in <code class="docutils literal notranslate"><span class="pre">eq</span></code> is one.
<strong>Usage</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">dsolve(eq,</span> <span class="pre">f(x),</span> <span class="pre">hint)</span></code> -&gt; Solve ordinary differential equation
<code class="docutils literal notranslate"><span class="pre">eq</span></code> for function <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>, using method <code class="docutils literal notranslate"><span class="pre">hint</span></code>.</p>
</div></blockquote>
<p><strong>Details</strong></p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">eq</span></code> can be any supported ordinary differential equation (see the</dt><dd><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code> docstring for supported methods).
This can either be an <code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code>,
or an expression, which is assumed to be equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f(x)</span></code> is a function of one variable whose derivatives in that</dt><dd><p>variable make up the ordinary differential equation <code class="docutils literal notranslate"><span class="pre">eq</span></code>.  In
many cases it is not necessary to provide this; it will be
autodetected (and an error raised if it couldn’t be detected).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hint</span></code> is the solving method that you want dsolve to use.  Use</dt><dd><p><code class="docutils literal notranslate"><span class="pre">classify_ode(eq,</span> <span class="pre">f(x))</span></code> to get all of the possible hints for an
ODE.  The default hint, <code class="docutils literal notranslate"><span class="pre">default</span></code>, will use whatever hint is
returned first by <code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code>.  See
Hints below for more options that you can use for hint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">simplify</span></code> enables simplification by</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code>.  See its docstring for more
information.  Turn this off, for example, to disable solving of
solutions for <code class="docutils literal notranslate"><span class="pre">func</span></code> or simplification of arbitrary constants.
It will still integrate with this hint. Note that the solution may
contain more arbitrary constants than the order of the ODE with
this option enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xi</span></code> and <code class="docutils literal notranslate"><span class="pre">eta</span></code> are the infinitesimal functions of an ordinary</dt><dd><p>differential equation. They are the infinitesimals of the Lie group
of point transformations for which the differential equation is
invariant. The user can specify values for the infinitesimals. If
nothing is specified, <code class="docutils literal notranslate"><span class="pre">xi</span></code> and <code class="docutils literal notranslate"><span class="pre">eta</span></code> are calculated using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">infinitesimals()</span></code> with the help of various
heuristics.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ics</span></code> is the set of boundary conditions for the differential equation.</dt><dd><p>It should be given in the form of <code class="docutils literal notranslate"><span class="pre">{f(x0):</span> <span class="pre">x1,</span> <span class="pre">f(x).diff(x).subs(x,</span> <span class="pre">x2):</span>
<span class="pre">x3}</span></code> and so on. For now initial conditions are implemented only for
power series solutions of first-order differential equations which should
be given in the form of <code class="docutils literal notranslate"><span class="pre">{f(x0):</span> <span class="pre">x1}</span></code> (See issue 4720). If nothing is
specified for this case <code class="docutils literal notranslate"><span class="pre">f(0)</span></code> is assumed to be <code class="docutils literal notranslate"><span class="pre">C0</span></code> and the power
series solution is calculated about 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x0</span></code> is the point about which the power series solution of a differential</dt><dd><p>equation is to be evaluated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> gives the exponent of the dependent variable up to which the power series</dt><dd><p>solution of a differential equation is to be evaluated.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote>
<div><p>Aside from the various solving methods, there are also some meta-hints
that you can pass to <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">default</span></code>:</dt><dd><p>This uses whatever hint is returned first by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code>. This is the
default argument to <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">all</span></code>:</dt><dd><p>To make <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> apply all
relevant classification hints, use <code class="docutils literal notranslate"><span class="pre">dsolve(ODE,</span> <span class="pre">func,</span>
<span class="pre">hint=&quot;all&quot;)</span></code>.  This will return a dictionary of
<code class="docutils literal notranslate"><span class="pre">hint:solution</span></code> terms.  If a hint causes dsolve to raise the
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>, value of that hint’s key will be the
exception object raised.  The dictionary will also include
some special keys:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">order</span></code>: The order of the ODE.  See also
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_order()</span></code> in
<code class="docutils literal notranslate"><span class="pre">deutils.py</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">best</span></code>: The simplest hint; what would be returned by
<code class="docutils literal notranslate"><span class="pre">best</span></code> below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">best_hint</span></code>: The hint that would produce the solution
given by <code class="docutils literal notranslate"><span class="pre">best</span></code>.  If more than one hint produces the best
solution, the first one in the tuple returned by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code> is chosen.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default</span></code>: The solution that would be returned by default.
This is the one produced by the hint that appears first in
the tuple returned by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code>.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">all_Integral</span></code>:</dt><dd><p>This is the same as <code class="docutils literal notranslate"><span class="pre">all</span></code>, except if a hint also has a
corresponding <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint, it only returns the
<code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint.  This is useful if <code class="docutils literal notranslate"><span class="pre">all</span></code> causes
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> to hang because of a
difficult or impossible integral.  This meta-hint will also be
much faster than <code class="docutils literal notranslate"><span class="pre">all</span></code>, because
<code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code> is an expensive
routine.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">best</span></code>:</dt><dd><p>To have <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> try all methods
and return the simplest one.  This takes into account whether
the solution is solvable in the function, whether it contains
any Integral classes (i.e.  unevaluatable integrals), and
which one is the shortest in size.</p>
</dd>
</dl>
<p>See also the <code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code> docstring for
more info on hints, and the <code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code> docstring for
a list of all supported hints.</p>
</div></blockquote>
<p><strong>Tips</strong></p>
<blockquote>
<div><ul>
<li><p>You can declare the derivative of an unknown function this way:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span> <span class="c1"># x is the independent variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># f is a function of x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># f_ will be the derivative of f with respect to x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>See <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code> for many tests, which serves also as a set of
examples for how to use <code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>.</p></li>
<li><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> always returns an
<code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code> class (except for the
case when the hint is <code class="docutils literal notranslate"><span class="pre">all</span></code> or <code class="docutils literal notranslate"><span class="pre">all_Integral</span></code>).  If possible, it
solves the solution explicitly for the function being solved for.
Otherwise, it returns an implicit solution.</p></li>
<li><p>Arbitrary constants are symbols named <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code>, and so on.</p></li>
<li><p>Because all solutions should be mathematically equivalent, some
hints may return the exact same result for an ODE. Often, though,
two different hints will return the same solution formatted
differently.  The two should be equivalent. Also note that sometimes
the values of the arbitrary constants in two different solutions may
not be the same, because one constant may have “absorbed” other
constants into it.</p></li>
<li><p>Do <code class="docutils literal notranslate"><span class="pre">help(ode.ode_&lt;hintname&gt;)</span></code> to get help more information on a
specific hint, where <code class="docutils literal notranslate"><span class="pre">&lt;hintname&gt;</span></code> is the name of a hint without
<code class="docutils literal notranslate"><span class="pre">_Integral</span></code>.</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<dl>
<dt><strong>Usage</strong></dt><dd><blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">dsolve(eq,</span> <span class="pre">func)</span></code> -&gt; Solve a system of ordinary differential
equations <code class="docutils literal notranslate"><span class="pre">eq</span></code> for <code class="docutils literal notranslate"><span class="pre">func</span></code> being list of functions including
<cite>x(t)</cite>, <cite>y(t)</cite>, <cite>z(t)</cite> where number of functions in the list depends
upon the number of equations provided in <code class="docutils literal notranslate"><span class="pre">eq</span></code>.</p>
</div></blockquote>
<p><strong>Details</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">eq</span></code> can be any supported system of ordinary differential equations
This can either be an <code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code>,
or an expression, which is assumed to be equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">func</span></code> holds <code class="docutils literal notranslate"><span class="pre">x(t)</span></code> and <code class="docutils literal notranslate"><span class="pre">y(t)</span></code> being functions of one variable which
together with some of their derivatives make up the system of ordinary
differential equation <code class="docutils literal notranslate"><span class="pre">eq</span></code>. It is not necessary to provide this; it
will be autodetected (and an error raised if it couldn’t be detected).</p>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote>
<div><p>The hints are formed by parameters returned by classify_sysode, combining
them give hints name used later for forming method name.</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">Eq(f(x), C1*sin(3*x) + C2*cos(3*x))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -acos(C1/cos(x)) + 2*pi), Eq(f(x), acos(C1/cos(x)))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -acos(C1/sqrt(-cos(x)**2)) + 2*pi), Eq(f(x), acos(C1/sqrt(-cos(x)**2)))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y&#39;</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="mi">12</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="mi">21</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[Eq(x(t), C1*x0 + C2*x0*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0**2, t)),</span>
<span class="go">Eq(y(t), C1*y0 + C2(y0*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0**2, t) +</span>
<span class="go">exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">{Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t))), Eq(y(t), -1/(C1 - cos(t)))}</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.get_numbered_constants">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">get_numbered_constants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#get_numbered_constants"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.get_numbered_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of constants that do not occur
in eq already.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.homogeneous_order">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">homogeneous_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#homogeneous_order"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.homogeneous_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order <cite>n</cite> if <cite>g</cite> is homogeneous and <code class="docutils literal notranslate"><span class="pre">None</span></code> if it is not
homogeneous.</p>
<p>Determines if a function is homogeneous and if so of what order.  A
function <cite>f(x, y, cdots)</cite> is homogeneous of order <cite>n</cite> if <cite>f(t x, t y,
cdots) = t^n f(x, y, cdots)</cite>.</p>
<p>If the function is of two variables, <cite>F(x, y)</cite>, then <cite>f</cite> being homogeneous
of any order is equivalent to being able to rewrite <cite>F(x, y)</cite> as <cite>G(x/y)</cite>
or <cite>H(y/x)</cite>.  This fact is used to solve 1st order ordinary differential
equations whose coefficients are homogeneous of the same order (see the
docstrings of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code>).</p>
<p>Symbols can be functions, but every argument of the function must be a
symbol, and the arguments of the function that appear in the expression
must match those given in the list of symbols.  If a declared function
appears with different arguments than given in the list of symbols,
<code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">homogeneous_order</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.infinitesimals">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">infinitesimals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#infinitesimals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.infinitesimals" title="Permalink to this definition">¶</a></dt>
<dd><p>The infinitesimal functions of an ordinary differential equation, <cite>xi(x,y)</cite>
and <cite>eta(x,y)</cite>, are the infinitesimals of the Lie group of point transformations
for which the differential equation is invariant. So, the ODE <cite>y’=f(x,y)</cite>
would admit a Lie group <cite>x^*=X(x,y;varepsilon)=x+varepsilonxi(x,y)</cite>,
<cite>y^*=Y(x,y;varepsilon)=y+varepsiloneta(x,y)</cite> such that <cite>(y^*)’=f(x^*, y^*)</cite>.
A change of coordinates, to <cite>r(x,y)</cite> and <cite>s(x,y)</cite>, can be performed so this Lie group
becomes the translation group, <cite>r^*=r</cite> and <cite>s^*=s+varepsilon</cite>.
They are tangents to the coordinate curves of the new system.</p>
<p>Consider the transformation <cite>(x, y) to (X, Y)</cite> such that the
differential equation remains invariant. <cite>xi</cite> and <cite>eta</cite> are the tangents to
the transformed coordinates <cite>X</cite> and <cite>Y</cite>, at <cite>varepsilon=0</cite>.</p>
<div class="math notranslate nohighlight">
\[\left(\frac{\partial X(x,y;\varepsilon)}{\partial\varepsilon
  }\right)|_{\varepsilon=0} = \xi,
\left(\frac{\partial Y(x,y;\varepsilon)}{\partial\varepsilon
  }\right)|_{\varepsilon=0} = \eta,\]</div>
<p>The infinitesimals can be found by solving the following PDE:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;xi&#39;</span><span class="p">,</span> <span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># dy/dx = h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">h</span>
<span class="gp">... </span><span class="o">-</span> <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">xi</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">/d               d           \                     d              2       d</span>
<span class="go">|--(eta(x, y)) - --(xi(x, y))|*h(x, y) - eta(x, y)*--(h(x, y)) - h (x, y)*--(x</span>
<span class="go">\dy              dx          /                     dy                     dy</span>

<span class="go">                    d             d</span>
<span class="go">i(x, y)) - xi(x, y)*--(h(x, y)) + --(eta(x, y)) = 0</span>
<span class="go">                    dx            dx</span>
</pre></div>
</div>
<p>Solving the above mentioned PDE is not trivial, and can be solved only by
making intelligent assumptions for <cite>xi</cite> and <cite>eta</cite> (heuristics). Once an
infinitesimal is found, the attempt to find more heuristics stops. This is done to
optimise the speed of solving the differential equation. If a list of all the
infinitesimals is needed, <code class="docutils literal notranslate"><span class="pre">hint</span></code> should be flagged as <code class="docutils literal notranslate"><span class="pre">all</span></code>, which gives
the complete list of infinitesimals. If the infinitesimals for a particular
heuristic needs to be found, it can be passed as a flag to <code class="docutils literal notranslate"><span class="pre">hint</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">infinitesimals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">infinitesimals</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[{eta(x, f(x)): exp(x**3/3), xi(x, f(x)): 0}]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Solving differential equations by Symmetry Groups,
John Starrett, pp. 1 - pp. 14</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.lie_heuristic_abaco1_product">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_abaco1_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#lie_heuristic_abaco1_product"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.lie_heuristic_abaco1_product" title="Permalink to this definition">¶</a></dt>
<dd><p>The second heuristic uses the following two assumptions on <cite>xi</cite> and <cite>eta</cite></p>
<div class="math notranslate nohighlight">
\[\eta = 0, \xi = f(x)*g(y)\]</div>
<div class="math notranslate nohighlight">
\[\eta = f(x)*g(y), \xi = 0\]</div>
<p>The first assumption of this heuristic holds good if
<cite>frac{1}{h^{2}}frac{partial^2}{partial x partial y}log(h)</cite> is
separable in <cite>x</cite> and <cite>y</cite>, then the separated factors containing <cite>x</cite>
is <cite>f(x)</cite>, and <cite>g(y)</cite> is obtained by</p>
<div class="math notranslate nohighlight">
\[e^{\int f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\,dy}\]</div>
<p>provided <cite>ffrac{partial}{partial x}left(frac{1}{f*h}right)</cite> is a function
of <cite>y</cite> only.</p>
<p>The second assumption holds good if <cite>frac{dy}{dx} = h(x, y)</cite> is rewritten as
<cite>frac{dy}{dx} = frac{1}{h(y, x)}</cite> and the same properties of the first assumption
satisifes. After obtaining <cite>f(x)</cite> and <cite>g(y)</cite>, the coordinates are again
interchanged, to get <cite>eta</cite> as <cite>f(x)*g(y)</cite></p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 7 - pp. 8</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.lie_heuristic_abaco1_simple">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_abaco1_simple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#lie_heuristic_abaco1_simple"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.lie_heuristic_abaco1_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>The first heuristic uses the following four sets of
assumptions on <cite>xi</cite> and <cite>eta</cite></p>
<div class="math notranslate nohighlight">
\[\xi = 0, \eta = f(x)\]</div>
<div class="math notranslate nohighlight">
\[\xi = 0, \eta = f(y)\]</div>
<div class="math notranslate nohighlight">
\[\xi = f(x), \eta = 0\]</div>
<div class="math notranslate nohighlight">
\[\xi = f(y), \eta = 0\]</div>
<p>The success of this heuristic is determined by algebraic factorisation.
For the first assumption <cite>xi = 0</cite> and <cite>eta</cite> to be a function of <cite>x</cite>, the PDE</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \eta}{\partial x} + (\frac{\partial \eta}{\partial y}
- \frac{\partial \xi}{\partial x})*h
- \frac{\partial \xi}{\partial y}*h^{2}
- \xi*\frac{\partial h}{\partial x} - \eta*\frac{\partial h}{\partial y} = 0\]</div>
<p>reduces to <cite>f’(x) - ffrac{partial h}{partial y} = 0</cite>
If <cite>frac{partial h}{partial y}</cite> is a function of <cite>x</cite>, then this can usually
be integrated easily. A similar idea is applied to the other 3 assumptions as well.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
Solving of First Order ODEs Using Symmetry Methods, pp. 8</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.lie_heuristic_abaco2_similar">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_abaco2_similar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#lie_heuristic_abaco2_similar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.lie_heuristic_abaco2_similar" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic uses the following two assumptions on <cite>xi</cite> and <cite>eta</cite></p>
<div class="math notranslate nohighlight">
\[\eta = g(x), \xi = f(x)\]</div>
<div class="math notranslate nohighlight">
\[\eta = f(y), \xi = g(y)\]</div>
<p>For the first assumption,</p>
<ol class="arabic">
<li><p>First <cite>frac{frac{partial h}{partial y}}{frac{partial^{2} h}{
partial yy}}</cite> is calculated. Let us say this value is A</p></li>
<li><p>If this is constant, then <cite>h</cite> is matched to the form <cite>A(x) + B(x)e^{
frac{y}{C}}</cite> then, <cite>frac{e^{int frac{A(x)}{C} ,dx}}{B(x)}</cite> gives <cite>f(x)</cite>
and <cite>A(x)*f(x)</cite> gives <cite>g(x)</cite></p></li>
<li><p>Otherwise <cite>frac{frac{partial A}{partial X}}{frac{partial A}{
partial Y}} = gamma</cite> is calculated. If</p>
<p>a] <cite>gamma</cite> is a function of <cite>x</cite> alone</p>
<p>b] <cite>frac{gammafrac{partial h}{partial y} - gamma’(x) - frac{
partial h}{partial x}}{h + gamma} = G</cite> is a function of <cite>x</cite> alone.
then, <cite>e^{int G ,dx}</cite> gives <cite>f(x)</cite> and <cite>-gamma*f(x)</cite> gives <cite>g(x)</cite></p>
</li>
</ol>
<p>The second assumption holds good if <cite>frac{dy}{dx} = h(x, y)</cite> is rewritten as
<cite>frac{dy}{dx} = frac{1}{h(y, x)}</cite> and the same properties of the first assumption
satisifes. After obtaining <cite>f(x)</cite> and <cite>g(x)</cite>, the coordinates are again
interchanged, to get <cite>xi</cite> as <cite>f(x^*)</cite> and <cite>eta</cite> as <cite>g(y^*)</cite></p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.lie_heuristic_abaco2_unique_general">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_abaco2_unique_general</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#lie_heuristic_abaco2_unique_general"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.lie_heuristic_abaco2_unique_general" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic finds if infinitesimals of the form <cite>eta = f(x)</cite>, <cite>xi = g(y)</cite>
without making any assumptions on <cite>h</cite>.</p>
<p>The complete sequence of steps is given in the paper mentioned below.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.lie_heuristic_abaco2_unique_unknown">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_abaco2_unique_unknown</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#lie_heuristic_abaco2_unique_unknown"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.lie_heuristic_abaco2_unique_unknown" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic assumes the presence of unknown functions or known functions
with non-integer powers.</p>
<ol class="arabic">
<li><p>A list of all functions and non-integer powers containing x and y</p></li>
<li><p>Loop over each element <cite>f</cite> in the list, find <cite>frac{frac{partial f}{partial x}}{
frac{partial f}{partial x}} = R</cite></p>
<p>If it is separable in <cite>x</cite> and <cite>y</cite>, let <cite>X</cite> be the factors containing <cite>x</cite>. Then</p>
<dl class="simple">
<dt>a] Check if <cite>xi = X</cite> and <cite>eta = -frac{X}{R}</cite> satisfy the PDE. If yes, then return</dt><dd><p><cite>xi</cite> and <cite>eta</cite></p>
</dd>
<dt>b] Check if <cite>xi = frac{-R}{X}</cite> and <cite>eta = -frac{1}{X}</cite> satisfy the PDE.</dt><dd><p>If yes, then return <cite>xi</cite> and <cite>eta</cite></p>
</dd>
</dl>
<p>If not, then check if</p>
<p>a] <span class="math notranslate nohighlight">\(\xi = -R,\eta = 1\)</span></p>
<p>b] <span class="math notranslate nohighlight">\(\xi = 1, \eta = -\frac{1}{R}\)</span></p>
<p>are solutions.</p>
</li>
</ol>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.lie_heuristic_bivariate">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_bivariate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#lie_heuristic_bivariate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.lie_heuristic_bivariate" title="Permalink to this definition">¶</a></dt>
<dd><p>The third heuristic assumes the infinitesimals <cite>xi</cite> and <cite>eta</cite>
to be bi-variate polynomials in <cite>x</cite> and <cite>y</cite>. The assumption made here
for the logic below is that <cite>h</cite> is a rational function in <cite>x</cite> and <cite>y</cite>
though that may not be necessary for the infinitesimals to be
bivariate polynomials. The coefficients of the infinitesimals
are found out by substituting them in the PDE and grouping similar terms
that are polynomials and since they form a linear system, solve and check
for non trivial solutions. The degree of the assumed bivariates
are increased till a certain maximum value.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Lie Groups and Differential Equations
pp. 327 - pp. 329</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.lie_heuristic_chi">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_chi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#lie_heuristic_chi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.lie_heuristic_chi" title="Permalink to this definition">¶</a></dt>
<dd><p>The aim of the fourth heuristic is to find the function <cite>chi(x, y)</cite>
that satisifies the PDE <cite>frac{dchi}{dx} + hfrac{dchi}{dx}
- frac{partial h}{partial y}chi = 0</cite>.</p>
<p>This assumes <cite>chi</cite> to be a bivariate polynomial in <cite>x</cite> and <cite>y</cite>. By intution,
<cite>h</cite> should be a rational function in <cite>x</cite> and <cite>y</cite>. The method used here is
to substitute a general binomial for <cite>chi</cite> up to a certain maximum degree
is reached. The coefficients of the polynomials, are calculated by by collecting
terms of the same order in <cite>x</cite> and <cite>y</cite>.</p>
<p>After finding <cite>chi</cite>, the next step is to use <cite>eta = xi*h + chi</cite>, to
determine <cite>xi</cite> and <cite>eta</cite>. This can be done by dividing <cite>chi</cite> by <cite>h</cite>
which would give <cite>-xi</cite> as the quotient and <cite>eta</cite> as the remainder.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
Solving of First Order ODEs Using Symmetry Methods, pp. 8</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.lie_heuristic_function_sum">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_function_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#lie_heuristic_function_sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.lie_heuristic_function_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic uses the following two assumptions on <cite>xi</cite> and <cite>eta</cite></p>
<div class="math notranslate nohighlight">
\[\eta = 0, \xi = f(x) + g(y)\]</div>
<div class="math notranslate nohighlight">
\[\eta = f(x) + g(y), \xi = 0\]</div>
<p>The first assumption of this heuristic holds good if</p>
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial y}[(h\frac{\partial^{2}}{
\partial x^{2}}(h^{-1}))^{-1}]\]</div>
<p>is separable in <cite>x</cite> and <cite>y</cite>,</p>
<ol class="arabic simple">
<li><p>The separated factors containing <cite>y</cite> is <cite>frac{partial g}{partial y}</cite>.
From this <cite>g(y)</cite> can be determined.</p></li>
<li><p>The separated factors containing <cite>x</cite> is <cite>f’’(x)</cite>.</p></li>
<li><p><cite>hfrac{partial^{2}}{partial x^{2}}(h^{-1})</cite> equals
<cite>frac{f’’(x)}{f(x) + g(y)}</cite>. From this <cite>f(x)</cite> can be determined.</p></li>
</ol>
<p>The second assumption holds good if <cite>frac{dy}{dx} = h(x, y)</cite> is rewritten as
<cite>frac{dy}{dx} = frac{1}{h(y, x)}</cite> and the same properties of the first
assumption satisifes. After obtaining <cite>f(x)</cite> and <cite>g(y)</cite>, the coordinates
are again interchanged, to get <cite>eta</cite> as <cite>f(x) + g(y)</cite>.</p>
<p>For both assumptions, the constant factors are separated among <cite>g(y)</cite>
and <cite>f’’(x)</cite>, such that <cite>f’’(x)</cite> obtained from 3] is the same as that
obtained from 2]. If not possible, then this heuristic fails.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 7 - pp. 8</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.lie_heuristic_linear">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#lie_heuristic_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.lie_heuristic_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic assumes</p>
<ol class="arabic simple">
<li><p><cite>xi = ax + by + c</cite> and</p></li>
<li><p><cite>eta = fx + gy + h</cite></p></li>
</ol>
<p>After substituting the following assumptions in the determining PDE, it
reduces to</p>
<div class="math notranslate nohighlight">
\[f + (g - a)h - bh^{2} - (ax + by + c)\frac{\partial h}{\partial x}
- (fx + gy + c)\frac{\partial h}{\partial y}\]</div>
<p>Solving the reduced PDE obtained, using the method of characteristics, becomes
impractical. The method followed is grouping similar terms and solving the system
of linear equations obtained. The difference between the bivariate heuristic is that
<cite>h</cite> need not be a rational function in this case.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_1st_exact">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_1st_exact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_1st_exact"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_1st_exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 1st order exact ordinary differential equations.</p>
<p>A 1st order differential equation is called exact if it is the total
differential of a function. That is, the differential equation</p>
<div class="math notranslate nohighlight">
\[P(x, y) \,\partial{}x + Q(x, y) \,\partial{}y = 0\]</div>
<p>is exact if there is some function <cite>F(x, y)</cite> such that <cite>P(x, y) =
partial{}F/partial{}x</cite> and <cite>Q(x, y) = partial{}F/partial{}y</cite>.  It can
be shown that a necessary and sufficient condition for a first order ODE
to be exact is that <cite>partial{}P/partial{}y = partial{}Q/partial{}x</cite>.
Then, the solution will be as given below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y,t,x0,y0,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">Integral</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">Integral</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y</span><span class="p">))),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">            x                y</span>
<span class="go">            /                /</span>
<span class="go">           |                |</span>
<span class="go">F(x, y) =  |  P(t, y) dt +  |  Q(x0, t) dt = C1</span>
<span class="go">           |                |</span>
<span class="go">          /                /</span>
<span class="go">          x0               y0</span>
</pre></div>
</div>
<p>Where the first partials of <cite>P</cite> and <cite>Q</cite> exist and are continuous in a
simply connected region.</p>
<p>A note: SymPy currently has no way to represent inert substitution on an
expression, so the hint <code class="docutils literal notranslate"><span class="pre">1st_exact_Integral</span></code> will return an integral
with <cite>dy</cite>.  This is supposed to represent the function that you are
solving for.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">Eq(x*cos(f(x)) + f(x)**3/3, C1)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Exact_differential_equation">http://en.wikipedia.org/wiki/Exact_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 73</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_1st_homogeneous_coeff_best">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_1st_homogeneous_coeff_best</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_best"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the best solution to an ODE from the two hints
<code class="docutils literal notranslate"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></code> and
<code class="docutils literal notranslate"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></code>.</p>
<p>This is as determined by <code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_sol_simplicity()</span></code>.</p>
<p>See the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code>
and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code>
docstrings for more information on these hints.  Note that there is no
<code class="docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_best_Integral</span></code> hint.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_best&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                         /    2    \</span>
<span class="go">                         | 3*x     |</span>
<span class="go">                      log|----- + 1|</span>
<span class="go">                         | 2       |</span>
<span class="go">                         \f (x)    /</span>
<span class="go">log(f(x)) = log(C1) - --------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_subs_dep_div_indep"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution <cite>u_1 = frac{text{&lt;dependent
variable&gt;}}{text{&lt;independent variable&gt;}}</cite>.</p>
<p>This is a differential equation</p>
<div class="math notranslate nohighlight">
\[P(x, y) + Q(x, y) dy/dx = 0\]</div>
<p>such that <cite>P</cite> and <cite>Q</cite> are homogeneous and of the same order.  A function
<cite>F(x, y)</cite> is homogeneous of order <cite>n</cite> if <cite>F(x t, y t) = t^n F(x, y)</cite>.
Equivalently, <cite>F(x, y)</cite> can be rewritten as <cite>G(y/x)</cite> or <cite>H(x/y)</cite>.  See
also the docstring of <code class="xref py py-meth docutils literal notranslate"><span class="pre">homogeneous_order()</span></code>.</p>
<p>If the coefficients <cite>P</cite> and <cite>Q</cite> in the differential equation above are
homogeneous functions of the same order, then it can be shown that the
substitution <cite>y = u_1 x</cite> (i.e. <cite>u_1 = y/x</cite>) will turn the differential
equation into an equation separable in the variables <cite>x</cite> and <cite>u</cite>.  If
<cite>h(u_1)</cite> is the function that results from making the substitution <cite>u_1 =
f(x)/x</cite> on <cite>P(x, f(x))</cite> and <cite>g(u_2)</cite> is the function that results from the
substitution on <cite>Q(x, f(x))</cite> in the differential equation <cite>P(x, f(x)) +
Q(x, f(x)) f’(x) = 0</cite>, then the general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> /f(x)\    /f(x)\ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \ x  /    \ x  / dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;</span><span class="p">))</span>
<span class="go">               f(x)</span>
<span class="go">               ----</span>
<span class="go">                x</span>
<span class="go">                 /</span>
<span class="go">                |</span>
<span class="go">                |       -h(u1)</span>
<span class="go">log(x) = C1 +   |  ---------------- d(u1)</span>
<span class="go">                |  u1*h(u1) + g(u1)</span>
<span class="go">                |</span>
<span class="go">               /</span>
</pre></div>
</div>
<p>Where <cite>u_1 h(u_1) + g(u_1) ne 0</cite> and <cite>x ne 0</cite>.</p>
<p>See also the docstrings of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_best()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                      /          3   \</span>
<span class="go">                      |3*f(x)   f (x)|</span>
<span class="go">                   log|------ + -----|</span>
<span class="go">                      |  x         3 |</span>
<span class="go">                      \           x  /</span>
<span class="go">log(x) = log(C1) - -------------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_subs_indep_div_dep"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution <cite>u_2 = frac{text{&lt;independent
variable&gt;}}{text{&lt;dependent variable&gt;}}</cite>.</p>
<p>This is a differential equation</p>
<div class="math notranslate nohighlight">
\[P(x, y) + Q(x, y) dy/dx = 0\]</div>
<p>such that <cite>P</cite> and <cite>Q</cite> are homogeneous and of the same order.  A function
<cite>F(x, y)</cite> is homogeneous of order <cite>n</cite> if <cite>F(x t, y t) = t^n F(x, y)</cite>.
Equivalently, <cite>F(x, y)</cite> can be rewritten as <cite>G(y/x)</cite> or <cite>H(x/y)</cite>.  See
also the docstring of <code class="xref py py-meth docutils literal notranslate"><span class="pre">homogeneous_order()</span></code>.</p>
<p>If the coefficients <cite>P</cite> and <cite>Q</cite> in the differential equation above are
homogeneous functions of the same order, then it can be shown that the
substitution <cite>x = u_2 y</cite> (i.e. <cite>u_2 = x/y</cite>) will turn the differential
equation into an equation separable in the variables <cite>y</cite> and <cite>u_2</cite>.  If
<cite>h(u_2)</cite> is the function that results from making the substitution <cite>u_2 =
x/f(x)</cite> on <cite>P(x, f(x))</cite> and <cite>g(u_2)</cite> is the function that results from the
substitution on <cite>Q(x, f(x))</cite> in the differential equation <cite>P(x, f(x)) +
Q(x, f(x)) f’(x) = 0</cite>, then the general solution is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> / x  \    / x  \ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \f(x)/    \f(x)/ dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">))</span>
<span class="go">             x</span>
<span class="go">            ----</span>
<span class="go">            f(x)</span>
<span class="go">              /</span>
<span class="go">             |</span>
<span class="go">             |       -g(u2)</span>
<span class="go">             |  ---------------- d(u2)</span>
<span class="go">             |  u2*g(u2) + h(u2)</span>
<span class="go">             |</span>
<span class="go">            /</span>

<span class="go">f(x) = C1*e</span>
</pre></div>
</div>
<p>Where <cite>u_2 g(u_2) + h(u_2) ne 0</cite> and <cite>f(x) ne 0</cite>.</p>
<p>See also the docstrings of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_best()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                         /    2    \</span>
<span class="go">                         | 3*x     |</span>
<span class="go">                      log|----- + 1|</span>
<span class="go">                         | 2       |</span>
<span class="go">                         \f (x)    /</span>
<span class="go">log(f(x)) = log(C1) - --------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_1st_linear">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_1st_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_1st_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_1st_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 1st order linear differential equations.</p>
<p>These are differential equations of the form</p>
<div class="math notranslate nohighlight">
\[dy/dx + P(x) y = Q(x)\text{.}\]</div>
<p>These kinds of differential equations can be solved in a general way.  The
integrating factor <cite>e^{int P(x) ,dx}</cite> will turn the equation into a
separable equation.  The general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_linear_Integral&#39;</span><span class="p">))</span>
<span class="go">       /       /                   \</span>
<span class="go">       |      |                    |</span>
<span class="go">       |      |         /          |     /</span>
<span class="go">       |      |        |           |    |</span>
<span class="go">       |      |        | P(x) dx   |  - | P(x) dx</span>
<span class="go">       |      |        |           |    |</span>
<span class="go">       |      |       /            |   /</span>
<span class="go">f(x) = |C1 +  | Q(x)*e           dx|*e</span>
<span class="go">       |      |                    |</span>
<span class="go">       \     /                     /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;1st_linear&#39;</span><span class="p">))</span>
<span class="go">f(x) = x*(C1 - cos(x))</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation">http://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 92</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_1st_power_series">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_1st_power_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_1st_power_series"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_1st_power_series" title="Permalink to this definition">¶</a></dt>
<dd><p>The power series solution is a method which gives the Taylor series expansion
to the solution of a differential equation.</p>
<p>For a first order differential equation <cite>frac{dy}{dx} = h(x, y)</cite>, a power
series solution exists at a point <cite>x = x_{0}</cite> if <cite>h(x, y)</cite> is analytic at <cite>x_{0}</cite>.
The solution is given by</p>
<div class="math notranslate nohighlight">
\[y(x) = y(x_{0}) + \sum_{n = 1}^{\infty} \frac{F_{n}(x_{0},b)(x - x_{0})^n}{n!},\]</div>
<p>where <cite>y(x_{0}) = b</cite> is the value of y at the initial value of <cite>x_{0}</cite>.
To compute the values of the <cite>F_{n}(x_{0},b)</cite> the following algorithm is
followed, until the required number of terms are generated.</p>
<ol class="arabic simple">
<li><p><cite>F_1 = h(x_{0}, b)</cite></p></li>
<li><p><cite>F_{n+1} = frac{partial F_{n}}{partial x} + frac{partial F_{n}}{partial y}F_{1}</cite></p></li>
</ol>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_power_series&#39;</span><span class="p">))</span>
<span class="go">                       3       4       5</span>
<span class="go">                   C1*x    C1*x    C1*x     / 6\</span>
<span class="go">f(x) = C1 + C1*x - ----- + ----- + ----- + O\x /</span>
<span class="go">                     6       24      60</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Travis W. Walker, Analytic power series technique for solving first-order
differential equations, p.p 17, 18</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_2nd_power_series_ordinary">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_2nd_power_series_ordinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_2nd_power_series_ordinary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_2nd_power_series_ordinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a power series solution to a second order homogeneous differential
equation with polynomial coefficients at an ordinary point. A homogenous
differential equation is of the form</p>
<div class="math notranslate nohighlight">
\[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) = 0\]</div>
<p>For simplicity it is assumed that <cite>P(x)</cite>, <cite>Q(x)</cite> and <cite>R(x)</cite> are polynomials,
it is sufficient that <cite>frac{Q(x)}{P(x)}</cite> and <cite>frac{R(x)}{P(x)}</cite> exists at
<cite>x_{0}</cite>. A recurrence relation is obtained by substituting <cite>y</cite> as <cite>sum_{n=0}^infty a_{n}x^{n}</cite>,
in the differential equation, and equating the nth term. Using this relation
various terms can be generated.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;2nd_power_series_ordinary&#39;</span><span class="p">))</span>
<span class="go">          / 4    2    \        /   2    \</span>
<span class="go">          |x    x     |        |  x     |    / 6\</span>
<span class="go">f(x) = C2*|-- - -- + 1| + C1*x*|- -- + 1| + O\x /</span>
<span class="go">          \24   2     /        \  6     /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx">http://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx</a></p></li>
<li><p>George E. Simmons, “Differential Equations with Applications and
Historical Notes”, p.p 176 - 184</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_2nd_power_series_regular">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_2nd_power_series_regular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_2nd_power_series_regular"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_2nd_power_series_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a power series solution to a second order homogeneous differential
equation with polynomial coefficients at a regular point. A second order
homogenous differential equation is of the form</p>
<div class="math notranslate nohighlight">
\[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) = 0\]</div>
<p>A point is said to regular singular at <cite>x0</cite> if <cite>x - x0frac{Q(x)}{P(x)}</cite>
and <cite>(x - x0)^{2}frac{R(x)}{P(x)}</cite> are analytic at <cite>x0</cite>. For simplicity
<cite>P(x)</cite>, <cite>Q(x)</cite> and <cite>R(x)</cite> are assumed to be polynomials. The algorithm for
finding the power series solutions is:</p>
<ol class="arabic simple">
<li><p>Try expressing <cite>(x - x0)P(x)</cite> and <cite>((x - x0)^{2})Q(x)</cite> as power series
solutions about x0. Find <cite>p0</cite> and <cite>q0</cite> which are the constants of the
power series expansions.</p></li>
<li><p>Solve the indicial equation <cite>f(m) = m(m - 1) + m*p0 + q0</cite>, to obtain the
roots <cite>m1</cite> and <cite>m2</cite> of the indicial equation.</p></li>
<li><p>If <cite>m1 - m2</cite> is a non integer there exists two series solutions. If
<cite>m1 = m2</cite>, there exists only one solution. If <cite>m1 - m2</cite> is an integer,
then the existence of one solution is confirmed. The other solution may
or may not exist.</p></li>
</ol>
<p>The power series solution is of the form <cite>x^{m}sum_{n=0}^infty a_{n}x^{n}</cite>. The
coefficients are determined by the following recurrence relation.
<cite>a_{n} = -frac{sum_{k=0}^{n-1} q_{n-k} + (m + k)p_{n-k}}{f(m + n)}</cite>. For the case
in which <cite>m1 - m2</cite> is an integer, it can be seen from the recurrence relation
that for the lower root <cite>m</cite>, when <cite>n</cite> equals the difference of both the
roots, the denominator becomes zero. So if the numerator is not equal to zero,
a second series solution exists.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
<span class="go">                              /    6    4    2    \</span>
<span class="go">                              |   x    x    x     |</span>
<span class="go">          /  4    2    \   C1*|- --- + -- - -- + 1|</span>
<span class="go">          | x    x     |      \  720   24   2     /    / 6\</span>
<span class="go">f(x) = C2*|--- - -- + 1| + ------------------------ + O\x /</span>
<span class="go">          \120   6     /              x</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>George E. Simmons, “Differential Equations with Applications and
Historical Notes”, p.p 176 - 184</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_Bernoulli">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_Bernoulli</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_Bernoulli"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_Bernoulli" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves Bernoulli differential equations.</p>
<p>These are equations of the form</p>
<div class="math notranslate nohighlight">
\[dy/dx + P(x) y = Q(x) y^n\text{, }n \ne 1`\text{.}\]</div>
<p>The substitution <cite>w = 1/y^{1-n}</cite> will transform an equation of this form
into one that is linear (see the docstring of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_linear()</span></code>).  The general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d                n</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)*f (x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Bernoulli_Integral&#39;</span><span class="p">))</span> 
<span class="go">                                                                               1</span>
<span class="go">                                                                              ----</span>
<span class="go">                                                                             1 - n</span>
<span class="go">       //                /                            \                     \</span>
<span class="go">       ||               |                             |                     |</span>
<span class="go">       ||               |                  /          |             /       |</span>
<span class="go">       ||               |                 |           |            |        |</span>
<span class="go">       ||               |        (1 - n)* | P(x) dx   |  (-1 + n)* | P(x) dx|</span>
<span class="go">       ||               |                 |           |            |        |</span>
<span class="go">       ||               |                /            |           /         |</span>
<span class="go">f(x) = ||C1 + (-1 + n)* | -Q(x)*e                   dx|*e                   |</span>
<span class="go">       ||               |                             |                     |</span>
<span class="go">       \\               /                            /                     /</span>
</pre></div>
</div>
<p>Note that the equation is separable when <cite>n = 1</cite> (see the docstring of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_separable()</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go"> f(x)</span>
<span class="go">   /</span>
<span class="go">  |                /</span>
<span class="go">  |  1            |</span>
<span class="go">  |  - dy = C1 +  | (-P(x) + Q(x)) dx</span>
<span class="go">  |  y            |</span>
<span class="go">  |              /</span>
<span class="go"> /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Bernoulli&#39;</span><span class="p">))</span>
<span class="go">                1</span>
<span class="go">f(x) = -------------------</span>
<span class="go">         /     log(x)   1\</span>
<span class="go">       x*|C1 + ------ + -|</span>
<span class="go">         \       x      x/</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Bernoulli_differential_equation">http://en.wikipedia.org/wiki/Bernoulli_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 95</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_Liouville">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_Liouville</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_Liouville"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_Liouville" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 2nd order Liouville differential equations.</p>
<p>The general form of a Liouville ODE is</p>
<div class="math notranslate nohighlight">
\[\frac{d^2 y}{dx^2} + g(y) \left(\!
\frac{dy}{dx}\!\right)^2 + h(x)
\frac{dy}{dx}\text{.}\]</div>
<p>The general solution is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                  2                    2</span>
<span class="go">        /d       \         d          d</span>
<span class="go">g(f(x))*|--(f(x))|  + h(x)*--(f(x)) + ---(f(x)) = 0</span>
<span class="go">        \dx      /         dx           2</span>
<span class="go">                                      dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Liouville_Integral&#39;</span><span class="p">))</span>
<span class="go">                                  f(x)</span>
<span class="go">          /                     /</span>
<span class="go">         |                     |</span>
<span class="go">         |     /               |     /</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |  - | h(x) dx        |    | g(y) dy</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |   /                 |   /</span>
<span class="go">C1 + C2* | e            dx +   |  e           dy = 0</span>
<span class="go">         |                     |</span>
<span class="go">        /                     /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Liouville&#39;</span><span class="p">))</span>
<span class="go">           ________________           ________________</span>
<span class="go">[f(x) = -\/ C1 + C2*log(x) , f(x) = \/ C1 + C2*log(x) ]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Goldstein and Braun, “Advanced Methods for the Solution of Differential
Equations”, pp. 98</p></li>
<li><p><a class="reference external" href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville">http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville</a></p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_Riccati_special_minus2">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_Riccati_special_minus2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_Riccati_special_minus2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_Riccati_special_minus2" title="Permalink to this definition">¶</a></dt>
<dd><p>The general Riccati equation has the form</p>
<div class="math notranslate nohighlight">
\[dy/dx = f(x) y^2 + g(x) y + h(x)\text{.}\]</div>
<p>While it does not have a general solution [1], the “special” form, <cite>dy/dx
= a y^2 - b x^c</cite>, does have solutions in many cases [2].  This routine
returns a solution for <cite>a(dy/dx) = b y^2 + c y/x + d/x^2</cite> that is obtained
by using a suitable change of variables to reduce it to the special form
and is valid when neither <cite>a</cite> nor <cite>b</cite> are zero and either <cite>c</cite> or <cite>d</cite> is
zero.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">checkodesol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">wrap_line</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">        /                                 /        __________________       \\</span>
<span class="go">        |           __________________    |       /                2        ||</span>
<span class="go">        |          /                2     |     \/  4*b*d - (a + c)  *log(x)||</span>
<span class="go">       -|a + c - \/  4*b*d - (a + c)  *tan|C1 + ----------------------------||</span>
<span class="go">        \                                 \                 2*a             //</span>
<span class="go">f(x) = ------------------------------------------------------------------------</span>
<span class="go">                                        2*b*x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati">http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati</a></p></li>
<li><p><a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf">http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf</a> -
<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf">http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf</a></p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_almost_linear">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_almost_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_almost_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_almost_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an almost-linear differential equation.</p>
<p>The general form of an almost linear differential equation is</p>
<div class="math notranslate nohighlight">
\[f(x) g(y) y + k(x) l(y) + m(x) = 0
\text{where} l'(y) = g(y)\text{.}\]</div>
<p>This can be solved by substituting <cite>l(y) = u(y)</cite>.  Making the given
substitution reduces it to a linear differential equation of the form <cite>u’
+ P(x) u + Q(x) = 0</cite>.</p>
<p>The general solution is</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="n">k</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">l</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">     d</span>
<span class="go">f(x)*--(l(y)) + g(x) + k(x)*l(y) = 0</span>
<span class="go">     dy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">hint</span> <span class="o">=</span> <span class="s1">&#39;almost_linear&#39;</span><span class="p">))</span>
<span class="go">       /     //   -y*g(x)                  \\</span>
<span class="go">       |     ||   --------     for k(x) = 0||</span>
<span class="go">       |     ||     f(x)                   ||  -y*k(x)</span>
<span class="go">       |     ||                            ||  --------</span>
<span class="go">       |     ||       y*k(x)               ||    f(x)</span>
<span class="go">l(y) = |C1 + |&lt;       ------               ||*e</span>
<span class="go">       |     ||        f(x)                ||</span>
<span class="go">       |     ||-g(x)*e                     ||</span>
<span class="go">       |     ||--------------   otherwise  ||</span>
<span class="go">       |     ||     k(x)                   ||</span>
<span class="go">       \     \\                            //</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.ode_1st_linear()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">classify_ode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">)</span>
<span class="go">Eq(f(x), (C1 - Ei(x))*exp(-x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">))</span>
<span class="go">                     -x</span>
<span class="go">f(x) = (C1 - Ei(x))*e</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_lie_group">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_lie_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_lie_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_lie_group" title="Permalink to this definition">¶</a></dt>
<dd><p>This hint implements the Lie group method of solving first order differential
equations. The aim is to convert the given differential equation from the
given coordinate given system into another coordinate system where it becomes
invariant under the one-parameter Lie group of translations. The converted ODE is
quadrature and can be solved easily. It makes use of the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.infinitesimals()</span></code> function which returns the
infinitesimals of the transformation.</p>
<p>The coordinates <cite>r</cite> and <cite>s</cite> can be found by solving the following Partial
Differential Equations.</p>
<div class="math notranslate nohighlight">
\[\xi\frac{\partial r}{\partial x} + \eta\frac{\partial r}{\partial y}
= 0\]</div>
<div class="math notranslate nohighlight">
\[\xi\frac{\partial s}{\partial x} + \eta\frac{\partial s}{\partial y}
= 1\]</div>
<p>The differential equation becomes separable in the new coordinate system</p>
<div class="math notranslate nohighlight">
\[\frac{ds}{dr} = \frac{\frac{\partial s}{\partial x} +
h(x, y)\frac{\partial s}{\partial y}}{
\frac{\partial r}{\partial x} + h(x, y)\frac{\partial r}{\partial y}}\]</div>
<p>After finding the solution by integration, it is then converted back to the original
coordinate system by subsituting <cite>r</cite> and <cite>s</cite> in terms of <cite>x</cite> and <cite>y</cite> again.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;lie_group&#39;</span><span class="p">))</span>
<span class="go">       /      2\    2</span>
<span class="go">       |     x |  -x</span>
<span class="go">f(x) = |C1 + --|*e</span>
<span class="go">       \     2 /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Solving differential equations by Symmetry Groups,
John Starrett, pp. 1 - pp. 14</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_linear_coefficients">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_linear_coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_linear_coefficients"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_linear_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a differential equation with linear coefficients.</p>
<p>The general form of a differential equation with linear coefficients is</p>
<div class="math notranslate nohighlight">
\[y' + F\left(\!\frac{a_1 x + b_1 y + c_1}{a_2 x + b_2 y +
c_2}\!\right) = 0\text{,}\]</div>
<p>where <cite>a_1</cite>, <cite>b_1</cite>, <cite>c_1</cite>, <cite>a_2</cite>, <cite>b_2</cite>, <cite>c_2</cite> are constants and <cite>a_1 b_2
- a_2 b_1 ne 0</cite>.</p>
<p>This can be solved by substituting:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x = x' + \frac{b_2 c_1 - b_1 c_2}{a_2 b_1 - a_1 b_2}\\y = y' + \frac{a_1 c_2 - a_2 c_1}{a_2 b_1 - a_1
    b_2}\text{.}\end{aligned}\end{align} \]</div>
<p>This substitution reduces the equation to a homogeneous differential
equation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.ode_1st_homogeneous_coeff_best()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">classify_ode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;linear_coefficients&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -x - sqrt(C1 + 7*x**2) - 1), Eq(f(x), -x + sqrt(C1 + 7*x**2) - 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;linear_coefficients&#39;</span><span class="p">))</span>
<span class="go">                  ___________                     ___________</span>
<span class="go">               /         2                     /         2</span>
<span class="go">[f(x) = -x - \/  C1 + 7*x   - 1, f(x) = -x + \/  C1 + 7*x   - 1]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_nth_linear_constant_coeff_homogeneous">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_nth_linear_constant_coeff_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sol'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_homogeneous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_nth_linear_constant_coeff_homogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <cite>n</cite>th order linear homogeneous differential equation with
constant coefficients.</p>
<p>This is an equation of the form</p>
<div class="math notranslate nohighlight">
\[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x)
+ a_0 f(x) = 0\text{.}\]</div>
<p>These equations can be solved in a general manner, by taking the roots of
the characteristic equation <cite>a_n m^n + a_{n-1} m^{n-1} + cdots + a_1 m +
a_0 = 0</cite>.  The solution will then be the sum of <cite>C_n x^i e^{r x}</cite> terms,
for each where <cite>C_n</cite> is an arbitrary constant, <cite>r</cite> is a root of the
characteristic equation and <cite>i</cite> is one of each from 0 to the multiplicity
of the root - 1 (for example, a root 3 of multiplicity 2 would create the
terms <cite>C_1 e^{3 x} + C_2 x e^{3 x}</cite>).  The exponential is usually expanded
for complex roots using Euler’s equation <cite>e^{I x} = cos(x) + I sin(x)</cite>.
Complex roots always come in conjugate pairs in polynomials with real
coefficients, so the two roots will be represented (after simplifying the
constants) as <cite>e^{a x} left(C_1 cos(b x) + C_2 sin(b x)right)</cite>.</p>
<p>If SymPy cannot find exact roots to the characteristic equation, a
<code class="xref py py-class docutils literal notranslate"><span class="pre">CRootOf</span></code> instance will be return
instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">Eq(f(x), C1*exp(x*CRootOf(_x**5 + 10*_x - 2, 0)) +</span>
<span class="go">C2*exp(x*CRootOf(_x**5 + 10*_x - 2, 1)) +</span>
<span class="go">C3*exp(x*CRootOf(_x**5 + 10*_x - 2, 2)) +</span>
<span class="go">C4*exp(x*CRootOf(_x**5 + 10*_x - 2, 3)) +</span>
<span class="go">C5*exp(x*CRootOf(_x**5 + 10*_x - 2, 4)))</span>
</pre></div>
</div>
<p>Note that because this method does not involve integration, there is no
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_homogeneous_Integral</span></code> hint.</p>
<p>The following is for internal use:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'sol'</span></code> returns the solution to the ODE.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'list'</span></code> returns a list of linearly independent solutions,
for use with non homogeneous solution methods like variation of
parameters and undetermined coefficients.  Note that, though the
solutions should be linearly independent, this function does not
explicitly check that.  You can do <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">simplify(wronskian(sollist))</span>
<span class="pre">!=</span> <span class="pre">0</span></code> to check for linear independence.  Also, <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">len(sollist)</span> <span class="pre">==</span>
<span class="pre">order</span></code> will need to pass.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'both'</span></code>, return a dictionary <code class="docutils literal notranslate"><span class="pre">{'sol':</span> <span class="pre">&lt;solution</span> <span class="pre">to</span> <span class="pre">ODE&gt;,</span>
<span class="pre">'list':</span> <span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">linearly</span> <span class="pre">independent</span> <span class="pre">solutions&gt;}</span></code>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">))</span>
<span class="go">                    x                            -2*x</span>
<span class="go">f(x) = (C1 + C2*x)*e  + (C3*sin(x) + C4*cos(x))*e</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Linear_differential_equation">http://en.wikipedia.org/wiki/Linear_differential_equation</a> section:
Nonhomogeneous_equation_with_constant_coefficients</p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 211</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_nth_linear_constant_coeff_undetermined_coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_undetermined_coefficients"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <cite>n</cite>th order linear differential equation with constant
coefficients using the method of undetermined coefficients.</p>
<p>This method works on differential equations of the form</p>
<div class="math notranslate nohighlight">
\[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x)
+ a_0 f(x) = P(x)\text{,}\]</div>
<p>where <cite>P(x)</cite> is a function that has a finite number of linearly
independent derivatives.</p>
<p>Functions that fit this requirement are finite sums functions of the form
<cite>a x^i e^{b x} sin(c x + d)</cite> or <cite>a x^i e^{b x} cos(c x + d)</cite>, where <cite>i</cite>
is a non-negative integer and <cite>a</cite>, <cite>b</cite>, <cite>c</cite>, and <cite>d</cite> are constants.  For
example any polynomial in <cite>x</cite>, functions like <cite>x^2 e^{2 x}</cite>, <cite>x sin(x)</cite>,
and <cite>e^x cos(x)</cite> can all be used.  Products of <cite>sin</cite>’s and <cite>cos</cite>’s have
a finite number of derivatives, because they can be expanded into <cite>sin(a
x)</cite> and <cite>cos(b x)</cite> terms.  However, SymPy currently cannot do that
expansion, so you will need to manually rewrite the expression in terms of
the above to use this method.  So, for example, you will need to manually
convert <cite>sin^2(x)</cite> into <cite>(1 + cos(2 x))/2</cite> to properly apply the method
of undetermined coefficients on it.</p>
<p>This method works by creating a trial function from the expression and all
of its linear independent derivatives and substituting them into the
original ODE.  The coefficients for each term will be a system of linear
equations, which are be solved for and substituted, giving the solution.
If any of the trial functions are linearly dependent on the solution to
the homogeneous equation, they are multiplied by sufficient <cite>x</cite> to make
them linearly independent.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">4</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;</span><span class="p">))</span>
<span class="go">       /             4\</span>
<span class="go">       |            x |  -x   4*sin(2*x)   3*cos(2*x)</span>
<span class="go">f(x) = |C1 + C2*x + --|*e   - ---------- + ----------</span>
<span class="go">       \            3 /           25           25</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Method_of_undetermined_coefficients">http://en.wikipedia.org/wiki/Method_of_undetermined_coefficients</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 221</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_nth_linear_constant_coeff_variation_of_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_variation_of_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <cite>n</cite>th order linear differential equation with constant
coefficients using the method of variation of parameters.</p>
<p>This method works on any differential equations of the form</p>
<div class="math notranslate nohighlight">
\[f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0
f(x) = P(x)\text{.}\]</div>
<p>This method works by assuming that the particular solution takes the form</p>
<div class="math notranslate nohighlight">
\[\sum_{x=1}^{n} c_i(x) y_i(x)\text{,}\]</div>
<p>where <cite>y_i</cite> is the <cite>i</cite>th solution to the homogeneous equation.  The
solution is then solved using Wronskian’s and Cramer’s Rule.  The
particular solution is given by</p>
<div class="math notranslate nohighlight">
\[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \,dx
\right) y_i(x) \text{,}\]</div>
<p>where <cite>W(x)</cite> is the Wronskian of the fundamental system (the system of <cite>n</cite>
linearly independent solutions to the homogeneous equation), and <cite>W_i(x)</cite>
is the Wronskian of the fundamental system with the <cite>i</cite>th column replaced
with <cite>[0, 0, cdots, 0, P(x)]</cite>.</p>
<p>This method is general enough to solve any <cite>n</cite>th order inhomogeneous
linear differential equation with constant coefficients, but sometimes
SymPy cannot simplify the Wronskian well enough to integrate it.  If this
method hangs, try using the
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_variation_of_parameters_Integral</span></code> hint and
simplifying the integrals manually.  Also, prefer using
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></code> when it
applies, because it doesn’t use integration, making it faster and more
reliable.</p>
<p>Warning, using simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters’ in
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> may cause it to hang, because it will
not attempt to simplify the Wronskian before integrating.  It is
recommended that you only use simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters_Integral’ for this
method, especially if the solution to the homogeneous equation has
trigonometric functions in it.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;</span><span class="p">))</span>
<span class="go">       /                     3                \</span>
<span class="go">       |                2   x *(6*log(x) - 11)|  x</span>
<span class="go">f(x) = |C1 + C2*x + C3*x  + ------------------|*e</span>
<span class="go">       \                            36        /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Variation_of_parameters">http://en.wikipedia.org/wiki/Variation_of_parameters</a></p></li>
<li><p><a class="reference external" href="http://planetmath.org/VariationOfParameters">http://planetmath.org/VariationOfParameters</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 233</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_nth_linear_euler_eq_homogeneous">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_nth_linear_euler_eq_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sol'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_nth_linear_euler_eq_homogeneous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_nth_linear_euler_eq_homogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <cite>n</cite>th order linear homogeneous variable-coefficient
Cauchy-Euler equidimensional ordinary differential equation.</p>
<p>This is an equation with form <cite>0 = a_0 f(x) + a_1 x f’(x) + a_2 x^2 f’’(x)
cdots</cite>.</p>
<p>These equations can be solved in a general manner, by substituting
solutions of the form <cite>f(x) = x^r</cite>, and deriving a characteristic equation
for <cite>r</cite>.  When there are repeated roots, we include extra terms of the
form <cite>C_{r k} ln^k(x) x^r</cite>, where <cite>C_{r k}</cite> is an arbitrary integration
constant, <cite>r</cite> is a root of the characteristic equation, and <cite>k</cite> ranges
over the multiplicity of <cite>r</cite>.  In the cases where the roots are complex,
solutions of the form <cite>C_1 x^a sin(b log(x)) + C_2 x^a cos(b log(x))</cite>
are returned, based on expansions with Eulers formula.  The general
solution is the sum of the terms found.  If SymPy cannot find exact roots
to the characteristic equation, a
<code class="xref py py-class docutils literal notranslate"><span class="pre">CRootOf</span></code> instance will be returned
instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_euler_eq_homogeneous&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">Eq(f(x), sqrt(x)*(C1 + C2*log(x)))</span>
</pre></div>
</div>
<p>Note that because this method does not involve integration, there is no
<code class="docutils literal notranslate"><span class="pre">nth_linear_euler_eq_homogeneous_Integral</span></code> hint.</p>
<p>The following is for internal use:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'sol'</span></code> returns the solution to the ODE.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'list'</span></code> returns a list of linearly independent solutions,
corresponding to the fundamental solution set, for use with non
homogeneous solution methods like variation of parameters and
undetermined coefficients.  Note that, though the solutions should be
linearly independent, this function does not explicitly check that.  You
can do <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">simplify(wronskian(sollist))</span> <span class="pre">!=</span> <span class="pre">0</span></code> to check for linear
independence.  Also, <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">len(sollist)</span> <span class="pre">==</span> <span class="pre">order</span></code> will need to pass.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'both'</span></code>, return a dictionary <code class="docutils literal notranslate"><span class="pre">{'sol':</span> <span class="pre">&lt;solution</span> <span class="pre">to</span> <span class="pre">ODE&gt;,</span>
<span class="pre">'list':</span> <span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">linearly</span> <span class="pre">independent</span> <span class="pre">solutions&gt;}</span></code>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_euler_eq_homogeneous&#39;</span><span class="p">))</span>
<span class="go">        2</span>
<span class="go">f(x) = x *(C1 + C2*x)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation">http://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation</a></p></li>
<li><p>C. Bender &amp; S. Orszag, “Advanced Mathematical Methods for Scientists and
Engineers”, Springer 1999, pp. 12</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_nth_linear_euler_eq_nonhomogeneous_undetermined_coefficients">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_nth_linear_euler_eq_nonhomogeneous_undetermined_coefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sol'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_nth_linear_euler_eq_nonhomogeneous_undetermined_coefficients"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_nth_linear_euler_eq_nonhomogeneous_undetermined_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <cite>n</cite>th order linear non homogeneous Cauchy-Euler equidimensional
ordinary differential equation using undetermined coefficients.</p>
<p>This is an equation with form <cite>g(x) = a_0 f(x) + a_1 x f’(x) + a_2 x^2 f’’(x)
cdots</cite>.</p>
<p>These equations can be solved in a general manner, by substituting
solutions of the form <cite>x = exp(t)</cite>, and deriving a characteristic equation
of form <cite>g(exp(t)) = b_0 f(t) + b_1 f’(t) + b_2 f’’(t) cdots</cite> which can
be then solved by nth_linear_constant_coeff_undetermined_coefficients if
g(exp(t)) has finite number of lineary independent derivatives.</p>
<p>Functions that fit this requirement are finite sums functions of the form
<cite>a x^i e^{b x} sin(c x + d)</cite> or <cite>a x^i e^{b x} cos(c x + d)</cite>, where <cite>i</cite>
is a non-negative integer and <cite>a</cite>, <cite>b</cite>, <cite>c</cite>, and <cite>d</cite> are constants.  For
example any polynomial in <cite>x</cite>, functions like <cite>x^2 e^{2 x}</cite>, <cite>x sin(x)</cite>,
and <cite>e^x cos(x)</cite> can all be used.  Products of <cite>sin</cite>’s and <cite>cos</cite>’s have
a finite number of derivatives, because they can be expanded into <cite>sin(a
x)</cite> and <cite>cos(b x)</cite> terms.  However, SymPy currently cannot do that
expansion, so you will need to manually rewrite the expression in terms of
the above to use this method.  So, for example, you will need to manually
convert <cite>sin^2(x)</cite> into <cite>(1 + cos(2 x))/2</cite> to properly apply the method
of undetermined coefficients on it.</p>
<p>After replacement of x by exp(t), this method works by creating a trial function
from the expression and all of its linear independent derivatives and
substituting them into the original ODE.  The coefficients for each term
will be a system of linear equations, which are be solved for and
substituted, giving the solution. If any of the trial functions are linearly
dependent on the solution to the homogeneous equation, they are multiplied
by sufficient <cite>x</cite> to make them linearly independent.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_euler_eq_nonhomogeneous_undetermined_coefficients&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="go">Eq(f(x), C1*x + C2*x**2 + log(x)/2 + 3/4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_nth_linear_euler_eq_nonhomogeneous_variation_of_parameters">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_nth_linear_euler_eq_nonhomogeneous_variation_of_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">returns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sol'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_nth_linear_euler_eq_nonhomogeneous_variation_of_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_nth_linear_euler_eq_nonhomogeneous_variation_of_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <cite>n</cite>th order linear non homogeneous Cauchy-Euler equidimensional
ordinary differential equation using variation of parameters.</p>
<p>This is an equation with form <cite>g(x) = a_0 f(x) + a_1 x f’(x) + a_2 x^2 f’’(x)
cdots</cite>.</p>
<p>This method works by assuming that the particular solution takes the form</p>
<div class="math notranslate nohighlight">
\[\sum_{x=1}^{n} c_i(x) y_i(x) {a_n} {x^n} \text{,}\]</div>
<p>where <cite>y_i</cite> is the <cite>i</cite>th solution to the homogeneous equation.  The
solution is then solved using Wronskian’s and Cramer’s Rule.  The
particular solution is given by multiplying eq given below with <cite>a_n x^{n}</cite></p>
<div class="math notranslate nohighlight">
\[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \,dx
\right) y_i(x) \text{,}\]</div>
<p>where <cite>W(x)</cite> is the Wronskian of the fundamental system (the system of <cite>n</cite>
linearly independent solutions to the homogeneous equation), and <cite>W_i(x)</cite>
is the Wronskian of the fundamental system with the <cite>i</cite>th column replaced
with <cite>[0, 0, cdots, 0, frac{x^{- n}}{a_n} g{left (x right )}]</cite>.</p>
<p>This method is general enough to solve any <cite>n</cite>th order inhomogeneous
linear differential equation, but sometimes SymPy cannot simplify the
Wronskian well enough to integrate it.  If this method hangs, try using the
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_variation_of_parameters_Integral</span></code> hint and
simplifying the integrals manually.  Also, prefer using
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></code> when it
applies, because it doesn’t use integration, making it faster and more
reliable.</p>
<p>Warning, using simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters’ in
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> may cause it to hang, because it will
not attempt to simplify the Wronskian before integrating.  It is
recommended that you only use simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters_Integral’ for this
method, especially if the solution to the homogeneous equation has
trigonometric functions in it.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_euler_eq_nonhomogeneous_variation_of_parameters&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="go">Eq(f(x), C1*x + C2*x**2 + x**4/6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_separable">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_separable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_separable"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_separable" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves separable 1st order differential equations.</p>
<p>This is any differential equation that can be written as <cite>P(y)
tfrac{dy}{dx} = Q(x)</cite>.  The solution can then just be found by
rearranging terms and integrating: <cite>int P(y) ,dy = int Q(x) ,dx</cite>.
This hint uses <code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.simplify.simplify.separatevars()</span></code> as its back
end, so if a separable equation is not caught by this solver, it is most
likely the fault of that function.
<code class="xref py py-meth docutils literal notranslate"><span class="pre">separatevars()</span></code> is
smart enough to do most expansion and factoring necessary to convert a
separable equation <cite>F(x, y)</cite> into the proper form <cite>P(x)cdot{}Q(y)</cite>.  The
general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">             d</span>
<span class="go">a(x)*b(f(x))*--(f(x)) = c(x)*d(f(x))</span>
<span class="go">             dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go">     f(x)</span>
<span class="go">   /                  /</span>
<span class="go">  |                  |</span>
<span class="go">  |  b(y)            | c(x)</span>
<span class="go">  |  ---- dy = C1 +  | ---- dx</span>
<span class="go">  |  d(y)            | a(x)</span>
<span class="go">  |                  |</span>
<span class="go"> /                  /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">   /   2       \         2</span>
<span class="go">log\3*f (x) - 1/        x</span>
<span class="go">---------------- = C1 + --</span>
<span class="go">       6                2</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 52</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_separable_reduced">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_separable_reduced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_separable_reduced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_separable_reduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a differential equation that can be reduced to the separable form.</p>
<p>The general form of this equation is</p>
<div class="math notranslate nohighlight">
\[y' + (y/x) H(x^n y) = 0\text{}.\]</div>
<p>This can be solved by substituting <cite>u(y) = x^n y</cite>.  The equation then
reduces to the separable form <cite>frac{u’}{u (mathrm{power} - H(u))} -
frac{1}{x} = 0</cite>.</p>
<p>The general solution is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                 / n     \</span>
<span class="go">d          f(x)*g\x *f(x)/</span>
<span class="go">--(f(x)) + ---------------</span>
<span class="go">dx                x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">))</span>
<span class="go"> n</span>
<span class="go">x *f(x)</span>
<span class="go">  /</span>
<span class="go"> |</span>
<span class="go"> |         1</span>
<span class="go"> |    ------------ dy = C1 + log(x)</span>
<span class="go"> |    y*(n - g(y))</span>
<span class="go"> |</span>
<span class="go"> /</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.ode_separable()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">classify_ode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), (-sqrt(C1*x**2 + 1) + 1)/x), Eq(f(x), (sqrt(C1*x**2 + 1) + 1)/x)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">))</span>
<span class="go">             ___________                ___________</span>
<span class="go">            /     2                    /     2</span>
<span class="go">        - \/  C1*x  + 1  + 1         \/  C1*x  + 1  + 1</span>
<span class="go">[f(x) = --------------------, f(x) = ------------------]</span>
<span class="go">                 x                           x</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.ode_sol_simplicity">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">ode_sol_simplicity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trysolving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#ode_sol_simplicity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.ode_sol_simplicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an extended integer representing how simple a solution to an ODE
is.</p>
<p>The following things are considered, in order from most simple to least:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> is solved for <code class="docutils literal notranslate"><span class="pre">func</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> is not solved for <code class="docutils literal notranslate"><span class="pre">func</span></code>, but can be if passed to solve (e.g.,
a solution returned by <code class="docutils literal notranslate"><span class="pre">dsolve(ode,</span> <span class="pre">func,</span> <span class="pre">simplify=False</span></code>).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">sol</span></code> is not solved for <code class="docutils literal notranslate"><span class="pre">func</span></code>, then base the result on the
length of <code class="docutils literal notranslate"><span class="pre">sol</span></code>, as computed by <code class="docutils literal notranslate"><span class="pre">len(str(sol))</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">sol</span></code> has any unevaluated <code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code>s,
this will automatically be considered less simple than any of the above.</p></li>
</ul>
<p>This function returns an integer such that if solution A is simpler than
solution B by above metric, then <code class="docutils literal notranslate"><span class="pre">ode_sol_simplicity(sola,</span> <span class="pre">func)</span> <span class="pre">&lt;</span>
<span class="pre">ode_sol_simplicity(solb,</span> <span class="pre">func)</span></code>.</p>
<p>Currently, the following are the numbers returned, but if the heuristic is
ever improved, this may change.  Only the ordering is guaranteed.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Simplicity</p></th>
<th class="head"><p>Return</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> solved for <code class="docutils literal notranslate"><span class="pre">func</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-2</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> not solved for <code class="docutils literal notranslate"><span class="pre">func</span></code> but can be</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-1</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> is not solved nor solvable for
<code class="docutils literal notranslate"><span class="pre">func</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">len(str(sol))</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> contains an
<code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">oo</span></code></p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">oo</span></code> here means the SymPy infinity, which should compare greater than
any integer.</p>
<p>If you already know <code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code> cannot solve
<code class="docutils literal notranslate"><span class="pre">sol</span></code>, you can use <code class="docutils literal notranslate"><span class="pre">trysolving=False</span></code> to skip that step, which is the
only potentially slow step.  For example,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> with the <code class="docutils literal notranslate"><span class="pre">simplify=False</span></code> flag
should do this.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sol</span></code> is a list of solutions, if the worst solution in the list
returns <code class="docutils literal notranslate"><span class="pre">oo</span></code> it returns that, otherwise it returns <code class="docutils literal notranslate"><span class="pre">len(str(sol))</span></code>,
that is, the length of the string representation of the whole list.</p>
<p class="rubric">Examples</p>
<p>This function is designed to be passed to <code class="docutils literal notranslate"><span class="pre">min</span></code> as the key argument,
such as <code class="docutils literal notranslate"><span class="pre">min(listofsolutions,</span> <span class="pre">key=lambda</span> <span class="pre">i:</span> <span class="pre">ode_sol_simplicity(i,</span>
<span class="pre">f(x)))</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">ode_sol_simplicity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, C1, C2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq1</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">C1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq2</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">C2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="p">[</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">]]</span>
<span class="go">[28, 35]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">Eq(f(x)/tan(f(x)/(2*x)), C1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.odesimp">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">odesimp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constants</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hint</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#odesimp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.odesimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies ODEs, including trying to solve for <code class="docutils literal notranslate"><span class="pre">func</span></code> and running
<code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code>.</p>
<p>It may use knowledge of the type of solution that the hint returns to
apply additional simplifications.</p>
<p>It also attempts to integrate any <code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code>s
in the expression, if the hint is not an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint.</p>
<p>This function should have no effect on expressions returned by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code>, as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> already calls
<code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code>, but the individual hint functions
do not call <code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code> (because the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code> wrapper does).  Therefore, this
function is designed for mainly internal use.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">odesimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,u2,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">wrap_line</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">                        x</span>
<span class="go">                       ----</span>
<span class="go">                       f(x)</span>
<span class="go">                         /</span>
<span class="go">                        |</span>
<span class="go">                        |   /        1   \</span>
<span class="go">                        |  -|u2 + -------|</span>
<span class="go">                        |   |        /1 \|</span>
<span class="go">                        |   |     sin|--||</span>
<span class="go">                        |   \        \u2//</span>
<span class="go">log(f(x)) = log(C1) +   |  ---------------- d(u2)</span>
<span class="go">                        |          2</span>
<span class="go">                        |        u2</span>
<span class="go">                        |</span>
<span class="go">                       /</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">odesimp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">},</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span>
<span class="gp">... </span><span class="p">))</span> 
<span class="go">    x</span>
<span class="go">--------- = C1</span>
<span class="go">   /f(x)\</span>
<span class="go">tan|----|</span>
<span class="go">   \2*x /</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.sub_func_doit">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">sub_func_doit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#sub_func_doit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.sub_func_doit" title="Permalink to this definition">¶</a></dt>
<dd><p>When replacing the func with something else, we usually want the
derivative evaluated, so this function helps in making that happen.</p>
<p>To keep subs from having to look through all derivatives, we mask them off
with dummy variables, do the func sub, and then replace masked-off
derivatives with their doit values.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.ode</span> <span class="kn">import</span> <span class="n">sub_func_doit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sub_func_doit</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sub_func_doit</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)))</span>
<span class="go">x*(-1/(x**2*(z + 1/x)) + 1/(x**3*(z + 1/x)**2)) + 1/(x*(z + 1/x))</span>
<span class="go">...- 1/(x**2*(z + 1/x)**2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.sysode_linear_2eq_order1">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">sysode_linear_2eq_order1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match_</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#sysode_linear_2eq_order1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.sysode_linear_2eq_order1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.sysode_linear_2eq_order2">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">sysode_linear_2eq_order2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match_</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#sysode_linear_2eq_order2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.sysode_linear_2eq_order2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.sysode_linear_3eq_order1">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">sysode_linear_3eq_order1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match_</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#sysode_linear_3eq_order1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.sysode_linear_3eq_order1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.sysode_linear_neq_order1">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">sysode_linear_neq_order1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match_</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#sysode_linear_neq_order1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.sysode_linear_neq_order1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.sysode_nonlinear_2eq_order1">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">sysode_nonlinear_2eq_order1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match_</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#sysode_nonlinear_2eq_order1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.sysode_nonlinear_2eq_order1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.ode.sysode_nonlinear_3eq_order1">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">sysode_nonlinear_3eq_order1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match_</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/ode.html#sysode_nonlinear_3eq_order1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.ode.sysode_nonlinear_3eq_order1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-modelparameters.sympy.solvers.pde">
<span id="modelparameters-sympy-solvers-pde-module"></span><h2>modelparameters.sympy.solvers.pde module<a class="headerlink" href="#module-modelparameters.sympy.solvers.pde" title="Permalink to this headline">¶</a></h2>
<p>This module contains pdsolve() and different helper functions that it
uses. It is heavily inspired by the ode module and hence the basic
infrastructure remains the same.</p>
<p><strong>Functions in this module</strong></p>
<blockquote>
<div><p>These are the user functions in this module:</p>
<ul class="simple">
<li><p>pdsolve()     - Solves PDE’s</p></li>
<li><p>classify_pde() - Classifies PDEs into possible hints for dsolve().</p></li>
<li><dl class="simple">
<dt>pde_separate() - Separate variables in partial differential equation either by</dt><dd><p>additive or multiplicative separation approach.</p>
</dd>
</dl>
</li>
</ul>
<p>These are the helper functions in this module:</p>
<ul class="simple">
<li><p>pde_separate_add() - Helper function for searching additive separable solutions.</p></li>
<li><dl class="simple">
<dt>pde_separate_mul() - Helper function for searching multiplicative</dt><dd><p>separable solutions.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><strong>Currently implemented solver methods</strong></p>
<p>The following methods are implemented for solving partial differential
equations.  See the docstrings of the various pde_hint() functions for
more information on each (run help(pde)):</p>
<blockquote>
<div><ul class="simple">
<li><p>1st order linear homogeneous partial differential equations
with constant coefficients.</p></li>
<li><p>1st order linear general partial differential equations
with constant coefficients.</p></li>
<li><p>1st order linear partial differential equations with
variable coefficients.</p></li>
</ul>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.pde.checkpdesol">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.pde.</span></span><span class="sig-name descname"><span class="pre">checkpdesol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pde</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solve_for_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/pde.html#checkpdesol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.pde.checkpdesol" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the given solution satisfies the partial differential
equation.</p>
<p>pde is the partial differential equation which can be given in the
form of an equation or an expression. sol is the solution for which
the pde is to be checked. This can also be given in an equation or
an expression form. If the function is not provided, the helper
function _preprocess from deutils is used to identify the function.</p>
<p>If a sequence of solutions is passed, the same sort of container will be
used to return the result for each solution.</p>
<p>The following methods are currently being implemented to check if the
solution satisfies the PDE:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Directly substitute the solution in the PDE and check. If the
solution hasn’t been solved for f, then it will solve for f
provided solve_for_func hasn’t been set to False.</p></li>
</ol>
</div></blockquote>
<p>If the solution satisfies the PDE, then a tuple (True, 0) is returned.
Otherwise a tuple (False, expr) where expr is the value obtained
after substituting the solution in the PDE. However if a known solution
returns False, it may be due to the inability of doit() to simplify it to zero.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.pde</span> <span class="kn">import</span> <span class="n">checkpdesol</span><span class="p">,</span> <span class="n">pdsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">pdsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">checkpdesol</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkpdesol</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">(False, (x*F(4*x - 3*y) - 6*F(4*x - 3*y)/25 + 4*Subs(Derivative(F(_xi_1), _xi_1), (_xi_1,), (4*x - 3*y,)))*exp(-6*x/25 - 8*y/25))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.pde.classify_pde">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.pde.</span></span><span class="sig-name descname"><span class="pre">classify_pde</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/pde.html#classify_pde"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.pde.classify_pde" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of possible pdsolve() classifications for a PDE.</p>
<p>The tuple is ordered so that first item is the classification that
pdsolve() uses to solve the PDE by default.  In general,
classifications near the beginning of the list will produce
better solutions faster than those near the end, though there are
always exceptions.  To make pdsolve use a different classification,
use pdsolve(PDE, func, hint=&lt;classification&gt;).  See also the pdsolve()
docstring for different meta-hints you can use.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dict</span></code> is true, classify_pde() will return a dictionary of
hint:match expression terms. This is intended for internal use by
pdsolve().  Note that because dictionaries are ordered arbitrarily,
this will most likely not be in the same order as the tuple.</p>
<p>You can get help on different hints by doing help(pde.pde_hintname),
where hintname is the name of the hint without “_Integral”.</p>
<p>See sympy.pde.allhints or the sympy.pde docstring for a list of all
supported hints that can be returned from classify_pde.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.pde</span> <span class="kn">import</span> <span class="n">classify_pde</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ux</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uy</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ux</span><span class="o">/</span><span class="n">u</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">uy</span><span class="o">/</span><span class="n">u</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_pde</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(&#39;1st_linear_constant_coeff_homogeneous&#39;,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.pde.pde_1st_linear_constant_coeff">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.pde.</span></span><span class="sig-name descname"><span class="pre">pde_1st_linear_constant_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solvefun</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/pde.html#pde_1st_linear_constant_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.pde.pde_1st_linear_constant_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a first order linear partial differential equation
with constant coefficients.</p>
<p>The general form of this partial differential equation is</p>
<div class="math notranslate nohighlight">
\[a \frac{df(x,y)}{dx} + b \frac{df(x,y)}{dy} + c f(x,y) = G(x,y)\]</div>
<p>where <cite>a</cite>, <cite>b</cite> and <cite>c</cite> are constants and <cite>G(x, y)</cite> can be an arbitrary
function in <cite>x</cite> and <cite>y</cite>.</p>
<p>The general solution of the PDE is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..solvers</span> <span class="kn">import</span> <span class="n">pdsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ux</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uy</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">ux</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">uy</span> <span class="o">-</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">          d               d</span>
<span class="go">a*f(x, y) + b*--(f(x, y)) + c*--(f(x, y)) - G(x, y)</span>
<span class="go">          dx              dy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">pdsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_linear_constant_coeff_Integral&#39;</span><span class="p">))</span>
<span class="go">          //          b*x + c*y                                             \</span>
<span class="go">          ||              /                                                 |</span>
<span class="go">          ||             |                                                  |</span>
<span class="go">          ||             |                                       a*xi       |</span>
<span class="go">          ||             |                                     -------      |</span>
<span class="go">          ||             |                                      2    2      |</span>
<span class="go">          ||             |      /b*xi + c*eta  -b*eta + c*xi\  b  + c       |</span>
<span class="go">          ||             |     G|------------, -------------|*e        d(xi)|</span>
<span class="go">          ||             |      |   2    2         2    2   |               |</span>
<span class="go">          ||             |      \  b  + c         b  + c    /               |</span>
<span class="go">          ||             |                                                  |</span>
<span class="go">          ||            /                                                   |</span>
<span class="go">          ||                                                                |</span>
<span class="go">f(x, y) = ||F(eta) + -------------------------------------------------------|*</span>
<span class="go">          ||                                  2    2                        |</span>
<span class="go">          \\                                 b  + c                         /</span>

<span class="go">        \|</span>
<span class="go">        ||</span>
<span class="go">        ||</span>
<span class="go">        ||</span>
<span class="go">        ||</span>
<span class="go">        ||</span>
<span class="go">        ||</span>
<span class="go">        ||</span>
<span class="go">        ||</span>
<span class="go">  -a*xi ||</span>
<span class="go"> -------||</span>
<span class="go">  2    2||</span>
<span class="go"> b  + c ||</span>
<span class="go">e       ||</span>
<span class="go">        ||</span>
<span class="go">        /|eta=-b*y + c*x, xi=b*x + c*y</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.pde</span> <span class="kn">import</span> <span class="n">pdsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">Eq(f(x, y), (F(4*x + 2*y) + exp(x/2 + 4*y)/15)*exp(x/2 - y))</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Viktor Grigoryan, “Partial Differential Equations”
Math 124A - Fall 2010, pp.7</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.pde.pde_1st_linear_constant_coeff_homogeneous">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.pde.</span></span><span class="sig-name descname"><span class="pre">pde_1st_linear_constant_coeff_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solvefun</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/pde.html#pde_1st_linear_constant_coeff_homogeneous"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.pde.pde_1st_linear_constant_coeff_homogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a first order linear homogeneous
partial differential equation with constant coefficients.</p>
<p>The general form of this partial differential equation is</p>
<div class="math notranslate nohighlight">
\[a \frac{df(x,y)}{dx} + b \frac{df(x,y)}{dy} + c f(x,y) = 0\]</div>
<p>where <cite>a</cite>, <cite>b</cite> and <cite>c</cite> are constants.</p>
<p>The general solution is of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..solvers</span> <span class="kn">import</span> <span class="n">pdsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ux</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uy</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">ux</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">uy</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">u</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">  d               d</span>
<span class="go">a*--(f(x, y)) + b*--(f(x, y)) + c*f(x, y)</span>
<span class="go">  dx              dy</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">pdsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">))</span>
<span class="go">                         -c*(a*x + b*y)</span>
<span class="go">                         ---------------</span>
<span class="go">                              2    2</span>
<span class="go">                             a  + b</span>
<span class="go">f(x, y) = F(-a*y + b*x)*e</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.pde</span> <span class="kn">import</span> <span class="p">(</span>
<span class="gp">... </span><span class="n">pde_1st_linear_constant_coeff_homogeneous</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">pdsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="go">Eq(f(x, y), F(x - y)*exp(-x/2 - y/2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">pdsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="go">                      x   y</span>
<span class="go">                    - - - -</span>
<span class="go">                      2   2</span>
<span class="go">f(x, y) = F(x - y)*e</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Viktor Grigoryan, “Partial Differential Equations”
Math 124A - Fall 2010, pp.7</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.pde.pde_1st_linear_variable_coeff">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.pde.</span></span><span class="sig-name descname"><span class="pre">pde_1st_linear_variable_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solvefun</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/pde.html#pde_1st_linear_variable_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.pde.pde_1st_linear_variable_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a first order linear partial differential equation
with variable coefficients. The general form of this partial differential equation is</p>
<div class="math notranslate nohighlight">
\[a(x, y) \frac{df(x, y)}{dx} + a(x, y) \frac{df(x, y)}{dy}
+ c(x, y) f(x, y) - G(x, y)\]</div>
<p>where <cite>a(x, y)</cite>, <cite>b(x, y)</cite>, <cite>c(x, y)</cite> and <cite>G(x, y)</cite> are arbitrary functions
in <cite>x</cite> and <cite>y</cite>. This PDE is converted into an ODE by making the following transformation.</p>
<p>1] <cite>xi</cite> as <cite>x</cite></p>
<p>2] <cite>eta</cite> as the constant in the solution to the differential equation
<cite>frac{dy}{dx} = -frac{b}{a}</cite></p>
<p>Making the following substitutions reduces it to the linear ODE</p>
<div class="math notranslate nohighlight">
\[a(\xi, \eta)\frac{du}{d\xi} + c(\xi, \eta)u - d(\xi, \eta) = 0\]</div>
<p>which can be solved using dsolve.</p>
<p>The general form of this PDE is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.pde</span> <span class="kn">import</span> <span class="n">pdsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span> <span class="p">[</span><span class="n">Function</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ux</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uy</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">b</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">ux</span> <span class="o">+</span> <span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">uy</span> <span class="o">-</span> <span class="n">G</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                                     d                     d</span>
<span class="go">-G(x, y) + a(x, y)*f(x, y) + b(x, y)*--(f(x, y)) + c(x, y)*--(f(x, y))</span>
<span class="go">                                     dx                    dy</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.pde</span> <span class="kn">import</span> <span class="n">pdsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span>  <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">Eq(f(x, y), F(x*y)*exp(y**2/2) + 1)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Viktor Grigoryan, “Partial Differential Equations”
Math 124A - Fall 2010, pp.7</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.pde.pde_separate">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.pde.</span></span><span class="sig-name descname"><span class="pre">pde_separate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mul'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/pde.html#pde_separate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.pde.pde_separate" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate variables in partial differential equation either by additive
or multiplicative separation approach. It tries to rewrite an equation so
that one of the specified variables occurs on a different side of the
equation than the others.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eq</strong> – Partial differential equation</p></li>
<li><p><strong>fun</strong> – Original function F(x, y, z)</p></li>
<li><p><strong>sep</strong> – List of separated functions [X(x), u(y, z)]</p></li>
<li><p><strong>strategy</strong> – Separation strategy. You can choose between additive
separation (‘add’) and multiplicative separation (‘mul’) which is
default.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">E</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pde_separate</span><span class="p">,</span> <span class="n">Derivative</span> <span class="k">as</span> <span class="n">D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="s1">&#39;uXT&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">D</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">E</span><span class="o">**</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="n">D</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pde_separate</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">[</span><span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;add&#39;</span><span class="p">)</span>
<span class="go">[exp(-X(x))*Derivative(X(x), x), exp(T(t))*Derivative(T(t), t)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">D</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">D</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pde_separate</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">[</span><span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mul&#39;</span><span class="p">)</span>
<span class="go">[Derivative(X(x), x, x)/X(x), Derivative(T(t), t, t)/T(t)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.pde.pde_separate_add" title="modelparameters.sympy.solvers.pde.pde_separate_add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pde_separate_add</span></code></a>, <a class="reference internal" href="#modelparameters.sympy.solvers.pde.pde_separate_mul" title="modelparameters.sympy.solvers.pde.pde_separate_mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pde_separate_mul</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.pde.pde_separate_add">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.pde.</span></span><span class="sig-name descname"><span class="pre">pde_separate_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/pde.html#pde_separate_add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.pde.pde_separate_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for searching additive separable solutions.</p>
<p>Consider an equation of two independent variables x, y and a dependent
variable w, we look for the product of two functions depending on different
arguments:</p>
<p><cite>w(x, y, z) = X(x) + y(y, z)</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">E</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pde_separate_add</span><span class="p">,</span> <span class="n">Derivative</span> <span class="k">as</span> <span class="n">D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="s1">&#39;uXT&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">D</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">E</span><span class="o">**</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="n">D</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pde_separate_add</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">[</span><span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">)])</span>
<span class="go">[exp(-X(x))*Derivative(X(x), x), exp(T(t))*Derivative(T(t), t)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.pde.pde_separate_mul">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.pde.</span></span><span class="sig-name descname"><span class="pre">pde_separate_mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/pde.html#pde_separate_mul"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.pde.pde_separate_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for searching multiplicative separable solutions.</p>
<p>Consider an equation of two independent variables x, y and a dependent
variable w, we look for the product of two functions depending on different
arguments:</p>
<p><cite>w(x, y, z) = X(x)*u(y, z)</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pde_separate_mul</span><span class="p">,</span> <span class="n">Derivative</span> <span class="k">as</span> <span class="n">D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="s1">&#39;uXY&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">D</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">D</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pde_separate_mul</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">[</span><span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Y</span><span class="p">(</span><span class="n">y</span><span class="p">)])</span>
<span class="go">[Derivative(X(x), x, x)/X(x), Derivative(Y(y), y, y)/Y(y)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.pde.pdsolve">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.pde.</span></span><span class="sig-name descname"><span class="pre">pdsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solvefun</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/pde.html#pdsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.pde.pdsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves any (supported) kind of partial differential equation.</p>
<p><strong>Usage</strong></p>
<blockquote>
<div><p>pdsolve(eq, f(x,y), hint) -&gt; Solve partial differential equation
eq for function f(x,y), using method hint.</p>
</div></blockquote>
<p><strong>Details</strong></p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">eq</span></code> can be any supported partial differential equation (see</dt><dd><p>the pde docstring for supported methods).  This can either
be an Equality, or an expression, which is assumed to be
equal to 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f(x,y)</span></code> is a function of two variables whose derivatives in that</dt><dd><p>variable make up the partial differential equation. In many
cases it is not necessary to provide this; it will be autodetected
(and an error raised if it couldn’t be detected).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hint</span></code> is the solving method that you want pdsolve to use.  Use</dt><dd><p>classify_pde(eq, f(x,y)) to get all of the possible hints for
a PDE.  The default hint, ‘default’, will use whatever hint
is returned first by classify_pde().  See Hints below for
more options that you can use for hint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">solvefun</span></code> is the convention used for arbitrary functions returned</dt><dd><p>by the PDE solver. If not set by the user, it is set by default
to be F.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote>
<div><p>Aside from the various solving methods, there are also some
meta-hints that you can pass to pdsolve():</p>
<dl class="simple">
<dt>“default”:</dt><dd><p>This uses whatever hint is returned first by
classify_pde(). This is the default argument to
pdsolve().</p>
</dd>
<dt>“all”:</dt><dd><p>To make pdsolve apply all relevant classification hints,
use pdsolve(PDE, func, hint=”all”).  This will return a
dictionary of hint:solution terms.  If a hint causes
pdsolve to raise the NotImplementedError, value of that
hint’s key will be the exception object raised.  The
dictionary will also include some special keys:</p>
<ul class="simple">
<li><p>order: The order of the PDE.  See also ode_order() in
deutils.py</p></li>
<li><p>default: The solution that would be returned by
default.  This is the one produced by the hint that
appears first in the tuple returned by classify_pde().</p></li>
</ul>
</dd>
<dt>“all_Integral”:</dt><dd><p>This is the same as “all”, except if a hint also has a
corresponding “_Integral” hint, it only returns the
“_Integral” hint.  This is useful if “all” causes
pdsolve() to hang because of a difficult or impossible
integral.  This meta-hint will also be much faster than
“all”, because integrate() is an expensive routine.</p>
</dd>
</dl>
<p>See also the classify_pde() docstring for more info on hints,
and the pde docstring for a list of all supported hints.</p>
</div></blockquote>
<dl>
<dt><strong>Tips</strong></dt><dd><ul>
<li><p>You can declare the derivative of an unknown function this way:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="c1"># x and y are the independent variables</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="c1"># f is a function of x and y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># fx will be the partial derivative of f with respect to x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fx</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># fy will be the partial derivative of f with respect to y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fy</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>See test_pde.py for many tests, which serves also as a set of
examples for how to use pdsolve().</p></li>
<li><p>pdsolve always returns an Equality class (except for the case
when the hint is “all” or “all_Integral”). Note that it is not possible
to get an explicit solution for f(x, y) as in the case of ODE’s</p></li>
<li><p>Do help(pde.pde_hintname) to get help more information on a
specific hint</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.pde</span> <span class="kn">import</span> <span class="n">pdsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ux</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uy</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">ux</span><span class="o">/</span><span class="n">u</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">uy</span><span class="o">/</span><span class="n">u</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">Eq(f(x, y), F(3*x - 2*y)*exp(-2*x/13 - 3*y/13))</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-modelparameters.sympy.solvers.polysys">
<span id="modelparameters-sympy-solvers-polysys-module"></span><h2>modelparameters.sympy.solvers.polysys module<a class="headerlink" href="#module-modelparameters.sympy.solvers.polysys" title="Permalink to this headline">¶</a></h2>
<p>Solvers of systems of polynomial equations.</p>
<dl class="py exception">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.polysys.SolveFailed">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.polysys.</span></span><span class="sig-name descname"><span class="pre">SolveFailed</span></span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/polysys.html#SolveFailed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.polysys.SolveFailed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a></p>
<p>Raised when solver’s conditions weren’t met.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.polysys.solve_biquadratic">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.polysys.</span></span><span class="sig-name descname"><span class="pre">solve_biquadratic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/polysys.html#solve_biquadratic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.polysys.solve_biquadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a system of two bivariate quadratic polynomial equations.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..polys</span> <span class="kn">import</span> <span class="n">Options</span><span class="p">,</span> <span class="n">Poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.polysys</span> <span class="kn">import</span> <span class="n">solve_biquadratic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NewOption</span> <span class="o">=</span> <span class="n">Options</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="s1">&#39;ZZ&#39;</span><span class="p">})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">7</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_biquadratic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">NewOption</span><span class="p">)</span>
<span class="go">[(1/3, 3), (41/27, 11/9)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="o">-</span><span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_biquadratic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">NewOption</span><span class="p">)</span>
<span class="go">[(-sqrt(29)/2 + 7/2, -sqrt(29)/2 - 1/2), (sqrt(29)/2 + 7/2, -1/2 +       sqrt(29)/2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.polysys.solve_generic">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.polysys.</span></span><span class="sig-name descname"><span class="pre">solve_generic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/polysys.html#solve_generic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.polysys.solve_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a generic system of polynomial equations.</p>
<p>Returns all possible solutions over C[x_1, x_2, …, x_m] of a
set F = { f_1, f_2, …, f_n } of polynomial equations,  using
Groebner basis approach. For now only zero-dimensional systems
are supported, which means F can have at most a finite number
of solutions.</p>
<p>The algorithm works by the fact that, supposing G is the basis
of F with respect to an elimination order  (here lexicographic
order is used), G and F generate the same ideal, they have the
same set of solutions. By the elimination property,  if G is a
reduced, zero-dimensional Groebner basis, then there exists an
univariate polynomial in G (in its last variable). This can be
solved by computing its roots. Substituting all computed roots
for the last (eliminated) variable in other elements of G, new
polynomial system is generated. Applying the above procedure
recursively, a finite number of solutions can be found.</p>
<p>The ability of finding all solutions by this procedure depends
on the root finding algorithms. If no solutions were found, it
means only that roots() failed, but the system is solvable. To
overcome this difficulty use numerical algorithms instead.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="buchberger01"><span class="brackets">Buchberger01</span></dt>
<dd><ol class="upperalpha simple" start="2">
<li><p>Buchberger, Groebner Bases: A Short</p></li>
</ol>
</dd>
</dl>
<p>Introduction for Systems Theorists, In: R. Moreno-Diaz,
B. Buchberger, J.L. Freire, Proceedings of EUROCAST’01,
February, 2001</p>
<dl class="citation">
<dt class="label" id="cox97"><span class="brackets">Cox97</span></dt>
<dd><ol class="upperalpha simple" start="4">
<li><p>Cox, J. Little, D. O’Shea, Ideals, Varieties</p></li>
</ol>
</dd>
</dl>
<p>and Algorithms, Springer, Second Edition, 1997, pp. 112</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..polys</span> <span class="kn">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">Options</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.polysys</span> <span class="kn">import</span> <span class="n">solve_generic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NewOption</span> <span class="o">=</span> <span class="n">Options</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;domain&#39;</span><span class="p">:</span> <span class="s1">&#39;ZZ&#39;</span><span class="p">})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_generic</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">NewOption</span><span class="p">)</span>
<span class="go">[(-1, 4)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_generic</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">NewOption</span><span class="p">)</span>
<span class="go">[(11/3, 13/3)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;ZZ&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_generic</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">NewOption</span><span class="p">)</span>
<span class="go">[(0, 0), (1/4, -1/16)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.polysys.solve_poly_system">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.polysys.</span></span><span class="sig-name descname"><span class="pre">solve_poly_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seq</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">gens</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/polysys.html#solve_poly_system"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.polysys.solve_poly_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a system of polynomial equations.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">solve_poly_system</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_poly_system</span><span class="p">([</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[(0, 0), (2, -sqrt(2)), (2, sqrt(2))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.polysys.solve_triangulated">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.polysys.</span></span><span class="sig-name descname"><span class="pre">solve_triangulated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">polys</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">gens</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/polysys.html#solve_triangulated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.polysys.solve_triangulated" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a polynomial system using Gianni-Kalkbrenner algorithm.</p>
<p>The algorithm proceeds by computing one Groebner basis in the ground
domain and then by iteratively computing polynomial factorizations in
appropriately constructed algebraic extensions of the ground domain.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.polysys</span> <span class="kn">import</span> <span class="n">solve_triangulated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_triangulated</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">[(0, 0, 1), (0, 1, 0), (1, 0, 0)]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>1. Patrizia Gianni, Teo Mora, Algebraic Solution of System of
Polynomial Equations using Groebner Bases, AAECC-5 on Applied Algebra,
Algebraic Algorithms and Error-Correcting Codes, LNCS 356 247–257, 1989</p>
</dd></dl>

</section>
<section id="module-modelparameters.sympy.solvers.recurr">
<span id="modelparameters-sympy-solvers-recurr-module"></span><h2>modelparameters.sympy.solvers.recurr module<a class="headerlink" href="#module-modelparameters.sympy.solvers.recurr" title="Permalink to this headline">¶</a></h2>
<p>This module is intended for solving recurrences or, in other words,
difference equations. Currently supported are linear, inhomogeneous
equations with polynomial or rational coefficients.</p>
<p>The solutions are obtained among polynomials, rational functions,
hypergeometric terms, or combinations of hypergeometric term which
are pairwise dissimilar.</p>
<p><code class="docutils literal notranslate"><span class="pre">rsolve_X</span></code> functions were meant as a low level interface
for <code class="docutils literal notranslate"><span class="pre">rsolve</span></code> which would use Mathematica’s syntax.</p>
<p>Given a recurrence relation:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +
... + a_{0}(n) y(n) = f(n)\]</div>
</div></blockquote>
<p>where <cite>k &gt; 0</cite> and <cite>a_{i}(n)</cite> are polynomials in <cite>n</cite>. To use
<code class="docutils literal notranslate"><span class="pre">rsolve_X</span></code> we need to put all coefficients in to a list <code class="docutils literal notranslate"><span class="pre">L</span></code> of
<cite>k+1</cite> elements the following way:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">a_{0}(n),</span> <span class="pre">...,</span> <span class="pre">a_{k-1}(n),</span> <span class="pre">a_{k}(n)</span> <span class="pre">]</span></code></p>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">L[i]</span></code>, for <cite>i=0, ldots, k</cite>, maps to
<cite>a_{i}(n) y(n+i)</cite> (<cite>y(n+i)</cite> is implicit).</p>
<p>For example if we would like to compute <cite>m</cite>-th Bernoulli polynomial
up to a constant (example was taken from rsolve_poly docstring),
then we would use <cite>b(n+1) - b(n) = m n^{m-1}</cite> recurrence, which
has solution <cite>b(n) = B_m + C</cite>.</p>
<p>Then <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">[-1,</span> <span class="pre">1]</span></code> and <cite>f(n) = m n^(m-1)</cite> and finally for <cite>m=4</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">bernoulli</span><span class="p">,</span> <span class="n">rsolve_poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve_poly</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="o">*</span><span class="n">n</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="go">C0 + n**4 - 2*n**3 + n**2</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bernoulli</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="go">n**4 - 2*n**3 + n**2 - 1/30</span>
</pre></div>
</div>
<p>For the sake of completeness, <cite>f(n)</cite> can be:</p>
<blockquote>
<div><p>[1] a polynomial              -&gt; rsolve_poly
[2] a rational function       -&gt; rsolve_ratio
[3] a hypergeometric function  -&gt; rsolve_hyper</p>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.recurr.rsolve">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.recurr.</span></span><span class="sig-name descname"><span class="pre">rsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/recurr.html#rsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.recurr.rsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve univariate recurrence with rational coefficients.</p>
<p>Given <cite>k</cite>-th order linear recurrence <cite>operatorname{L} y = f</cite>,
or equivalently:</p>
<div class="math notranslate nohighlight">
\[a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +
\cdots + a_{0}(n) y(n) = f(n)\]</div>
<p>where <cite>a_{i}(n)</cite>, for <cite>i=0, ldots, k</cite>, are polynomials or rational
functions in <cite>n</cite>, and <cite>f</cite> is a hypergeometric function or a sum
of a fixed number of pairwise dissimilar hypergeometric terms in
<cite>n</cite>, finds all solutions or returns <code class="docutils literal notranslate"><span class="pre">None</span></code>, if none were found.</p>
<p>Initial conditions can be given as a dictionary in two forms:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{</span>&#160;&#160; <span class="pre">n_0</span>&#160; <span class="pre">:</span> <span class="pre">v_0,</span>&#160;&#160; <span class="pre">n_1</span>&#160; <span class="pre">:</span> <span class="pre">v_1,</span> <span class="pre">...,</span>&#160;&#160; <span class="pre">n_m</span>&#160; <span class="pre">:</span> <span class="pre">v_m</span> <span class="pre">}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">y(n_0)</span> <span class="pre">:</span> <span class="pre">v_0,</span> <span class="pre">y(n_1)</span> <span class="pre">:</span> <span class="pre">v_1,</span> <span class="pre">...,</span> <span class="pre">y(n_m)</span> <span class="pre">:</span> <span class="pre">v_m</span> <span class="pre">}</span></code></p></li>
</ol>
</div></blockquote>
<p>or as a list <code class="docutils literal notranslate"><span class="pre">L</span></code> of values:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">v_0,</span> <span class="pre">v_1,</span> <span class="pre">...,</span> <span class="pre">v_m</span> <span class="pre">]</span></code></p>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">L[i]</span> <span class="pre">=</span> <span class="pre">v_i</span></code>, for <cite>i=0, ldots, m</cite>, maps to <cite>y(n_i)</cite>.</p>
<p class="rubric">Examples</p>
<p>Lets consider the following recurrence:</p>
<div class="math notranslate nohighlight">
\[(n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) +
2 n (n + 1) y(n) = 0\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">rsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="go">2**n*C0 + C1*factorial(n)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="p">{</span> <span class="n">y</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="mi">3</span> <span class="p">})</span>
<span class="go">3*2**n - 3*factorial(n)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.recurr.rsolve_poly" title="modelparameters.sympy.solvers.recurr.rsolve_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_poly</span></code></a>, <a class="reference internal" href="#modelparameters.sympy.solvers.recurr.rsolve_ratio" title="modelparameters.sympy.solvers.recurr.rsolve_ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_ratio</span></code></a>, <a class="reference internal" href="#modelparameters.sympy.solvers.recurr.rsolve_hyper" title="modelparameters.sympy.solvers.recurr.rsolve_hyper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_hyper</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.recurr.rsolve_hyper">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.recurr.</span></span><span class="sig-name descname"><span class="pre">rsolve_hyper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">hints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/recurr.html#rsolve_hyper"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.recurr.rsolve_hyper" title="Permalink to this definition">¶</a></dt>
<dd><p>Given linear recurrence operator <cite>operatorname{L}</cite> of order <cite>k</cite>
with polynomial coefficients and inhomogeneous equation
<cite>operatorname{L} y = f</cite> we seek for all hypergeometric solutions
over field <cite>K</cite> of characteristic zero.</p>
<p>The inhomogeneous part can be either hypergeometric or a sum
of a fixed number of pairwise dissimilar hypergeometric terms.</p>
<p>The algorithm performs three basic steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Group together similar hypergeometric terms in the
inhomogeneous part of <cite>operatorname{L} y = f</cite>, and find
particular solution using Abramov’s algorithm.</p></li>
<li><p>Compute generating set of <cite>operatorname{L}</cite> and find basis
in it, so that all solutions are linearly independent.</p></li>
<li><p>Form final solution with the number of arbitrary
constants equal to dimension of basis of <cite>operatorname{L}</cite>.</p></li>
</ol>
</div></blockquote>
<p>Term <cite>a(n)</cite> is hypergeometric if it is annihilated by first order
linear difference equations with polynomial coefficients or, in
simpler words, if consecutive term ratio is a rational function.</p>
<p>The output of this procedure is a linear combination of fixed
number of hypergeometric terms. However the underlying method
can generate larger class of solutions - D’Alembertian terms.</p>
<p>Note also that this method not only computes the kernel of the
inhomogeneous equation, but also reduces in to a basis so that
solutions generated by this procedure are linearly independent</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..solvers</span> <span class="kn">import</span> <span class="n">rsolve_hyper</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve_hyper</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">C0*(1/2 + sqrt(5)/2)**x + C1*(-sqrt(5)/2 + 1/2)**x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve_hyper</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">C0 + x*(x + 1)/2</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets">1</span></dt>
<dd><p>M. Petkovsek, Hypergeometric solutions of linear recurrences
with polynomial coefficients, J. Symbolic Computation,
14 (1992), 243-264.</p>
</dd>
<dt class="label" id="id4"><span class="brackets">2</span></dt>
<dd><ol class="upperalpha simple" start="13">
<li><p>Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.recurr.rsolve_poly">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.recurr.</span></span><span class="sig-name descname"><span class="pre">rsolve_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">hints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/recurr.html#rsolve_poly"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.recurr.rsolve_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Given linear recurrence operator <cite>operatorname{L}</cite> of order
<cite>k</cite> with polynomial coefficients and inhomogeneous equation
<cite>operatorname{L} y = f</cite>, where <cite>f</cite> is a polynomial, we seek for
all polynomial solutions over field <cite>K</cite> of characteristic zero.</p>
<p>The algorithm performs two basic steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Compute degree <cite>N</cite> of the general polynomial solution.</p></li>
<li><p>Find all polynomials of degree <cite>N</cite> or less
of <cite>operatorname{L} y = f</cite>.</p></li>
</ol>
</div></blockquote>
<p>There are two methods for computing the polynomial solutions.
If the degree bound is relatively small, i.e. it’s smaller than
or equal to the order of the recurrence, then naive method of
undetermined coefficients is being used. This gives system
of algebraic equations with <cite>N+1</cite> unknowns.</p>
<p>In the other case, the algorithm performs transformation of the
initial equation to an equivalent one, for which the system of
algebraic equations has only <cite>r</cite> indeterminates. This method is
quite sophisticated (in comparison with the naive one) and was
invented together by Abramov, Bronstein and Petkovsek.</p>
<p>It is possible to generalize the algorithm implemented here to
the case of linear q-difference and differential equations.</p>
<p>Lets say that we would like to compute <cite>m</cite>-th Bernoulli polynomial
up to a constant. For this we can use <cite>b(n+1) - b(n) = m n^{m-1}</cite>
recurrence, which has solution <cite>b(n) = B_m + C</cite>. For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">rsolve_poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve_poly</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="o">*</span><span class="n">n</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="go">C0 + n**4 - 2*n**3 + n**2</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id5"><span class="brackets">1</span></dt>
<dd><p>S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial
solutions of linear operator equations, in: T. Levelt, ed.,
Proc. ISSAC ‘95, ACM Press, New York, 1995, 290-296.</p>
</dd>
<dt class="label" id="id6"><span class="brackets">2</span></dt>
<dd><p>M. Petkovsek, Hypergeometric solutions of linear recurrences
with polynomial coefficients, J. Symbolic Computation,
14 (1992), 243-264.</p>
</dd>
<dt class="label" id="id7"><span class="brackets">3</span></dt>
<dd><ol class="upperalpha simple" start="13">
<li><p>Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.recurr.rsolve_ratio">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.recurr.</span></span><span class="sig-name descname"><span class="pre">rsolve_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">hints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/recurr.html#rsolve_ratio"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.recurr.rsolve_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Given linear recurrence operator <cite>operatorname{L}</cite> of order <cite>k</cite>
with polynomial coefficients and inhomogeneous equation
<cite>operatorname{L} y = f</cite>, where <cite>f</cite> is a polynomial, we seek
for all rational solutions over field <cite>K</cite> of characteristic zero.</p>
<p>This procedure accepts only polynomials, however if you are
interested in solving recurrence with rational coefficients
then use <code class="docutils literal notranslate"><span class="pre">rsolve</span></code> which will pre-process the given equation
and run this procedure with polynomial arguments.</p>
<p>The algorithm performs two basic steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Compute polynomial <cite>v(n)</cite> which can be used as universal
denominator of any rational solution of equation
<cite>operatorname{L} y = f</cite>.</p></li>
<li><p>Construct new linear difference equation by substitution
<cite>y(n) = u(n)/v(n)</cite> and solve it for <cite>u(n)</cite> finding all its
polynomial solutions. Return <code class="docutils literal notranslate"><span class="pre">None</span></code> if none were found.</p></li>
</ol>
</div></blockquote>
<p>Algorithm implemented here is a revised version of the original
Abramov’s algorithm, developed in 1989. The new approach is much
simpler to implement and has better overall efficiency. This
method can be easily adapted to q-difference equations case.</p>
<p>Besides finding rational solutions alone, this functions is
an important part of Hyper algorithm were it is used to find
particular solution of inhomogeneous part of a recurrence.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.recurr</span> <span class="kn">import</span> <span class="n">rsolve_ratio</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve_ratio</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="gp">... </span><span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">11</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">18</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">13</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">22</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">C2*(2*x - 3)/(2*(x**2 - 1))</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id8"><span class="brackets">1</span></dt>
<dd><p>S. A. Abramov, Rational solutions of linear difference
and q-difference equations with polynomial coefficients,
in: T. Levelt, ed., Proc. ISSAC ‘95, ACM Press, New York,
1995, 285-289</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.recurr.rsolve_hyper" title="modelparameters.sympy.solvers.recurr.rsolve_hyper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_hyper</span></code></a></p>
</div>
</dd></dl>

</section>
<section id="module-modelparameters.sympy.solvers.solvers">
<span id="modelparameters-sympy-solvers-solvers-module"></span><h2>modelparameters.sympy.solvers.solvers module<a class="headerlink" href="#module-modelparameters.sympy.solvers.solvers" title="Permalink to this headline">¶</a></h2>
<p>This module contain solvers for all kinds of equations:</p>
<blockquote>
<div><ul class="simple">
<li><p>algebraic or transcendental, use solve()</p></li>
<li><p>recurrence, use rsolve()</p></li>
<li><p>differential, use dsolve()</p></li>
<li><p>nonlinear (numerically), use nsolve()
(you will need a good starting point)</p></li>
</ul>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.check_assumptions">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">check_assumptions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">against</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">assumptions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#check_assumptions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.check_assumptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether expression <cite>expr</cite> satisfies all assumptions.</p>
<p><cite>assumptions</cite> is a dict of assumptions: {‘assumption’: True|False, …}.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">check_assumptions</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">check_assumptions</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_assumptions</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_assumptions</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">negative</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_assumptions</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">7</span><span class="p">),</span> <span class="n">real</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_assumptions</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_assumptions</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">5</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>To check assumptions of <code class="docutils literal notranslate"><span class="pre">expr</span></code> against another variable or expression,
pass the expression or variable as <code class="docutils literal notranslate"><span class="pre">against</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">check_assumptions</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p><cite>None</cite> is returned if check_assumptions() could not conclude.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">check_assumptions</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_assumptions</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.checksol">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">checksol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#checksol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.checksol" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether sol is a solution of equation f == 0.</p>
<p>Input can be either a single symbol and corresponding value
or a dictionary of symbols and values. When given as a dictionary
and flag <code class="docutils literal notranslate"><span class="pre">simplify=True</span></code>, the values in the dictionary will be
simplified. <code class="docutils literal notranslate"><span class="pre">f</span></code> can be a single equation or an iterable of equations.
A solution must satisfy all equations in <code class="docutils literal notranslate"><span class="pre">f</span></code> to be considered valid;
if a solution does not satisfy any equation, False is returned; if one or
more checks are inconclusive (and none are False) then None
is returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..solvers</span> <span class="kn">import</span> <span class="n">checksol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checksol</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checksol</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checksol</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To check if an expression is zero using checksol, pass it
as <code class="docutils literal notranslate"><span class="pre">f</span></code> and send an empty dictionary for <code class="docutils literal notranslate"><span class="pre">symbol</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">checksol</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">{})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>None is returned if checksol() could not conclude.</p>
<dl class="simple">
<dt>flags:</dt><dd><dl class="simple">
<dt>‘numerical=True (default)’</dt><dd><p>do a fast numerical check if <code class="docutils literal notranslate"><span class="pre">f</span></code> has only one symbol.</p>
</dd>
<dt>‘minimal=True (default is False)’</dt><dd><p>a very fast, minimal testing.</p>
</dd>
<dt>‘warn=True (default is False)’</dt><dd><p>show a warning if checksol() could not conclude.</p>
</dd>
<dt>‘simplify=True (default)’</dt><dd><p>simplify solution before substituting into function and
simplify the function before trying specific simplifications</p>
</dd>
<dt>‘force=True (default is False)’</dt><dd><p>make positive all symbols without assumptions regarding sign.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.denoms">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">denoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#denoms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.denoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (recursively) set of all denominators that appear in eq
that contain any symbol in <code class="docutils literal notranslate"><span class="pre">symbols</span></code>; if <code class="docutils literal notranslate"><span class="pre">symbols</span></code> are not
provided then all denominators will be returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solvers</span> <span class="kn">import</span> <span class="n">denoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sqrt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">denoms</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>
<span class="go">{y}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">denoms</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">))</span>
<span class="go">{y, z}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">denoms</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">/</span><span class="n">z</span><span class="p">)</span>
<span class="go">{x, z}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">denoms</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">/</span><span class="n">z</span><span class="p">)</span>
<span class="go">{2, z}</span>
</pre></div>
</div>
<p>If <cite>symbols</cite> are provided then only denominators containing
those symbols will be returned</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">denoms</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">{y, z}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.det_minor">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">det_minor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#det_minor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.det_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <code class="docutils literal notranslate"><span class="pre">det(M)</span></code> computed from minors without
introducing new nesting in products.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.solvers.det_perm" title="modelparameters.sympy.solvers.solvers.det_perm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">det_perm</span></code></a>, <a class="reference internal" href="#modelparameters.sympy.solvers.solvers.det_quick" title="modelparameters.sympy.solvers.solvers.det_quick"><code class="xref py py-obj docutils literal notranslate"><span class="pre">det_quick</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.det_perm">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">det_perm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#det_perm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.det_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the det(<code class="docutils literal notranslate"><span class="pre">M</span></code>) by using permutations to select factors.
For size larger than 8 the number of permutations becomes prohibitively
large, or if there are no symbols in the matrix, it is better to use the
standard determinant routines, e.g. <cite>M.det()</cite>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.solvers.det_minor" title="modelparameters.sympy.solvers.solvers.det_minor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">det_minor</span></code></a>, <a class="reference internal" href="#modelparameters.sympy.solvers.solvers.det_quick" title="modelparameters.sympy.solvers.solvers.det_quick"><code class="xref py py-obj docutils literal notranslate"><span class="pre">det_quick</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.det_quick">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">det_quick</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#det_quick"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.det_quick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">det(M)</span></code> assuming that either
there are lots of zeros or the size of the matrix
is small. If this assumption is not met, then the normal
Matrix.det function will be used with method = <code class="docutils literal notranslate"><span class="pre">method</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.solvers.det_minor" title="modelparameters.sympy.solvers.solvers.det_minor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">det_minor</span></code></a>, <a class="reference internal" href="#modelparameters.sympy.solvers.solvers.det_perm" title="modelparameters.sympy.solvers.solvers.det_perm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">det_perm</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.inv_quick">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">inv_quick</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#inv_quick"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.inv_quick" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse of <code class="docutils literal notranslate"><span class="pre">M</span></code>, assuming that either
there are lots of zeros or the size of the matrix
is small.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.minsolve_linear_system">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">minsolve_linear_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">symbols</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#minsolve_linear_system"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.minsolve_linear_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Find a particular solution to a linear system.</p>
<p>In particular, try to find a solution with the minimal possible number
of non-zero variables using a naive algorithm with exponential complexity.
If <code class="docutils literal notranslate"><span class="pre">quick=True</span></code>, a heuristic is used.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.nsolve">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">nsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#nsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.nsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a nonlinear equation system numerically:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">args</span><span class="p">,]</span> <span class="n">x0</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mpmath&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>f is a vector function of symbolic expressions representing the system.
args are the variables. If there is only one variable, this argument can
be omitted.
x0 is a starting vector close to a solution.</p>
<p>Use the modules keyword to specify which modules should be used to
evaluate the function and the Jacobian matrix. Make sure to use a module
that supports matrices. For more information on the syntax, please see the
docstring of lambdify.</p>
<p>If the keyword arguments contain ‘dict’=True (default is False) nsolve
will return a list (perhaps empty) of solution mappings. This might be
especially useful if you want to use nsolve as a fallback to solve since
using the dict argument for both methods produces return values of
consistent type structure. Please note: to keep this consistency with
solve, the solution will be returned in a list even though nsolve
(currently at least) only finds one solution at a time.</p>
<p>Overdetermined systems are supported.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">nsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mpmath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">x1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">-</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nsolve</span><span class="p">((</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
<span class="go">Matrix([[-1.19287309935246], [1.27844411169911]])</span>
</pre></div>
</div>
<p>For one-dimensional functions the syntax is simplified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">nsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">3.14159265358979</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">3.14159265358979</span>
</pre></div>
</div>
<p>To solve with higher precision than the default, use the prec argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0.739085133215161</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="go">0.73908513321516064165531208767387340401341175890076</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">0.73908513321516064165531208767387340401341175890076</span>
</pre></div>
</div>
<p>To solve for complex roots of real functions, a nonreal initial point
must be specified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">1.4142135623731*I</span>
</pre></div>
</div>
<p>mpmath.findroot is used and you can find there more extensive
documentation, especially concerning keyword parameters and
available solvers. Note, however, that functions which are very
steep near the root the verification of the solution may fail. In
this case you should use the flag <cite>verify=False</cite> and
independently verify the solution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">cosh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">3.14</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Could not find root within given tolerance. (1.39267e+230 &gt; 2.1684e-19)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span> <span class="o">=</span> <span class="n">nsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">3.14</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span> <span class="n">ans</span>
<span class="go">312.588469032184</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2.1e+121</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">f</span><span class="o">/</span><span class="n">f</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">7.4e-15</span>
</pre></div>
</div>
<p>One might safely skip the verification if bounds of the root are known
and a bisection method is used:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="mf">3.14</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="mf">3.14</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">bounds</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;bisect&#39;</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">315.730061685774</span>
</pre></div>
</div>
<p>Alternatively, a function may be better behaved when the
denominator is ignored. Since this is not always the case, however,
the decision of what function to use is left to the discretion of
the user.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="mf">0.46</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Could not find root within given tolerance. (10000 &gt; 2.1684e-19)</span>
<span class="go">Try another starting point or tweak arguments.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.46</span><span class="p">)</span>
<span class="go">0.46792545969349058</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.solve">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">symbols</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebraically solves equations and systems of equations.</p>
<dl class="simple">
<dt>Currently supported are:</dt><dd><ul class="simple">
<li><p>polynomial,</p></li>
<li><p>transcendental</p></li>
<li><p>piecewise combinations of the above</p></li>
<li><p>systems of linear and polynomial equations</p></li>
<li><p>systems containing relational expressions.</p></li>
</ul>
</dd>
</dl>
<p>Input is formed as:</p>
<ul class="simple">
<li><dl class="simple">
<dt>f</dt><dd><ul>
<li><p>a single Expr or Poly that must be zero,</p></li>
<li><p>an Equality</p></li>
<li><p>a Relational expression or boolean</p></li>
<li><p>iterable of one or more of the above</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>symbols (object(s) to solve for) specified as</dt><dd><ul>
<li><p>none given (other non-numeric objects will be used)</p></li>
<li><p>single symbol</p></li>
<li><p>denested list of symbols
e.g. solve(f, x, y)</p></li>
<li><p>ordered iterable of symbols
e.g. solve(f, [x, y])</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>flags</dt><dd><dl class="simple">
<dt>‘dict’=True (default is False)</dt><dd><p>return list (perhaps empty) of solution mappings</p>
</dd>
<dt>‘set’=True (default is False)</dt><dd><p>return list of symbols and set of tuple(s) of solution(s)</p>
</dd>
<dt>‘exclude=[] (default)’</dt><dd><p>don’t try to solve for any of the free symbols in exclude;
if expressions are given, the free symbols in them will
be extracted automatically.</p>
</dd>
<dt>‘check=True (default)’</dt><dd><p>If False, don’t do any testing of solutions. This can be
useful if one wants to include solutions that make any
denominator zero.</p>
</dd>
<dt>‘numerical=True (default)’</dt><dd><p>do a fast numerical check if <code class="docutils literal notranslate"><span class="pre">f</span></code> has only one symbol.</p>
</dd>
<dt>‘minimal=True (default is False)’</dt><dd><p>a very fast, minimal testing.</p>
</dd>
<dt>‘warn=True (default is False)’</dt><dd><p>show a warning if checksol() could not conclude.</p>
</dd>
<dt>‘simplify=True (default)’</dt><dd><p>simplify all but polynomials of order 3 or greater before
returning them and (if check is not False) use the
general simplify function on the solutions and the
expression obtained when they are substituted into the
function which should be zero</p>
</dd>
<dt>‘force=True (default is False)’</dt><dd><p>make positive all symbols without assumptions regarding sign.</p>
</dd>
<dt>‘rational=True (default)’</dt><dd><p>recast Floats as Rational; if this option is not used, the
system containing floats may fail to solve because of issues
with polys. If rational=None, Floats will be recast as
rationals but the answer will be recast as Floats. If the
flag is False then nothing will be done to the Floats.</p>
</dd>
<dt>‘manual=True (default is False)’</dt><dd><p>do not use the polys/matrix method to solve a system of
equations, solve them one at a time as you might “manually”</p>
</dd>
<dt>‘implicit=True (default is False)’</dt><dd><p>allows solve to return a solution for a pattern in terms of
other functions that contain that pattern; this is only
needed if the pattern is inside of some invertible function
like cos, exp, ….</p>
</dd>
<dt>‘particular=True (default is False)’</dt><dd><p>instructs solve to try to find a particular solution to a linear
system with as many zeros as possible; this is very expensive</p>
</dd>
<dt>‘quick=True (default is False)’</dt><dd><p>when using particular=True, use a fast heuristic instead to find a
solution with many zeros (instead of using the very slow method
guaranteed to find the largest number of zeros possible)</p>
</dd>
<dt>‘cubics=True (default)’</dt><dd><p>return explicit solutions when cubic expressions are encountered</p>
</dd>
<dt>‘quartics=True (default)’</dt><dd><p>return explicit solutions when quartic expressions are encountered</p>
</dd>
<dt>‘quintics=True (default)’</dt><dd><p>return explicit solutions (if possible) when quintic expressions
are encountered</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
<p class="rubric">Examples</p>
<p>The output varies according to the input and can be seen by example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p>boolean or univariate Relational</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(-oo &lt; x) &amp; (x &lt; 3)</span>
</pre></div>
</div>
</li>
<li><p>to always get a list of solution mappings, use flag dict=True</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[{x: 3}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span>
<span class="go">[{x: 3, y: 1}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
</li>
<li><p>to get a list of symbols and set of solution(s) use flag set=True</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([x, y], {(-sqrt(3), 1), (sqrt(3), 1)})</span>
</pre></div>
</div>
</li>
<li><p>single expression and single symbol that is in the expression</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[y]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([x], {(-y,), (y,)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([x], {(-1,), (1,), (-I,), (I,)})</span>
</pre></div>
</div>
</li>
<li><p>single expression with no symbol that is in the expression</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</li>
<li><p>single expression with no symbol given</p>
<blockquote>
<div><p>In this case, all free symbols will be selected as potential
symbols to solve for. If the equation is univariate then a list
of solutions is returned; otherwise – as is the case when symbols are
given as an iterable of length &gt; 1 – a list of mappings will be returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[{x: -y}, {x: y}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[{x: -y}, {x: y}, {z: 0}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[{x: y**2}, {z: 0}]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>when an object other than a Symbol is given as a symbol, it is
isolated algebraically and an implicit solution may be obtained.
This is mostly provided as a convenience to save one from replacing
the object with a Symbol and solving for that Symbol. It will only
work if the specified object can be replaced with a Symbol using the
subs method.</p>
<blockquote>
<div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[x + f(x)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[-x + Derivative(f(x), x)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([exp(x)], {(-sqrt(-x),), (sqrt(-x),)})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">eqs</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Indexed</span><span class="p">))</span>
<span class="go">{A[1]: 1, A[2]: 2}</span>
</pre></div>
</div>
<ul>
<li><p>To solve for a <em>symbol</em> implicitly, use ‘implicit=True’:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[-LambertW(1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[-exp(x)]</span>
</pre></div>
</div>
</li>
<li><p>It is possible to solve for anything that can be targeted with
subs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[-sqrt(3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">{y: -2 + sqrt(3), x + 2: -sqrt(3)}</span>
</pre></div>
</div>
</li>
<li><p>Nothing heroic is done in this implicit solving so you may end up
with a symbol still in the solution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">{y: -sqrt(3)/(x + 3), x + 2: (-2*x - 6 + sqrt(3))/(x + 3)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">y</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{x: -y - 4, x*y: -3*y - sqrt(3)}</span>
</pre></div>
</div>
</li>
<li><p>if you attempt to solve for a number remember that the number
you have obtained does not necessarily mean that the value is
equivalent to the expression obtained:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[sqrt(2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># /!\ -1 is targeted, too</span>
<span class="go">[x/(y - 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">solve</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="mi">1</span><span class="p">)]</span>
<span class="go">[-x + y]</span>
</pre></div>
</div>
</li>
<li><p>To solve for a function within a derivative, use dsolve.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>single expression and more than 1 symbol</p>
<blockquote>
<div><ul>
<li><p>when there is a linear solution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[{x: y**2}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[{y: x**2}]</span>
</pre></div>
</div>
</li>
<li><p>when undetermined coefficients are identified</p>
<blockquote>
<div><ul>
<li><p>that are linear</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">{a: -2, b: 2}</span>
</pre></div>
</div>
</li>
<li><p>that are nonlinear</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([a, b], {(-sqrt(2), sqrt(2)), (sqrt(2), -sqrt(2))})</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</li>
<li><p>if there is no linear solution then the first successful
attempt for a nonlinear solution will be returned</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[{x: -y}, {x: y}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[{x: 2*LambertW(y/2)}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[{y: -x*sqrt(exp(x))}, {y: x*sqrt(exp(x))}]</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</li>
<li><p>iterable of one or more of the above</p>
<blockquote>
<div><ul>
<li><p>involving relationals or bools</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">Eq(x, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</li>
<li><p>when the system is linear</p>
<blockquote>
<div><ul>
<li><p>with a solution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{x: 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">15</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{x: -3, y: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">15</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">{x: -3, y: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{x: -5*y + 2, z: 21*y - 6}</span>
</pre></div>
</div>
</li>
<li><p>without a solution</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[]</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</li>
<li><p>when the system is not linear</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([x, y], {(-2, -2), (0, 2), (2, -2)})</span>
</pre></div>
</div>
</li>
<li><p>if no symbols are given, all free symbols will be selected and a list
of mappings returned</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">])</span>
<span class="go">[{x: 2, y: -4}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">{</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">})</span>
<span class="go">[{x: 2, f(x): -4}]</span>
</pre></div>
</div>
</li>
<li><p>if any equation doesn’t depend on the symbol(s) given it will be
eliminated from the equation set and an answer may be given
implicitly in terms of variables that were not of interest</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{x: y}</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</li>
</ul>
<p class="rubric">Notes</p>
<p>solve() with check=True (default) will run through the symbol tags to
elimate unwanted solutions.  If no assumptions are included all possible
solutions will be returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">solve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[-1, 1]</span>
</pre></div>
</div>
<p>By using the positive tag only one solution will be returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;pos&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">pos</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>Assumptions aren’t checked when <cite>solve()</cite> input involves
relationals or bools.</p>
<p>When the solutions are checked, those that make any denominator zero
are automatically excluded. If you do not want to exclude such solutions
then use the check=False option:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">limit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 0 is excluded</span>
<span class="go">[pi]</span>
</pre></div>
</div>
<p>If check=False then a solution to the numerator being zero is found: x = 0.
In this case, this is a spurious solution since sin(x)/x has the well known
limit (without dicontinuity) of 1 at x = 0:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[0, pi]</span>
</pre></div>
</div>
<p>In the following case, however, the limit exists and is equal to the the
value of x = 0 that is excluded when check=True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>When solving polynomial expressions, one might not want explicit solutions
(which can be quite long). If the expression is univariate, CRootOf
instances will be returned instead:</p>
<blockquote>
<div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[-1/((-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)) - (-1/2 -</span>
<span class="go">sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3, -(-1/2 +</span>
<span class="go">sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3 - 1/((-1/2 +</span>
<span class="go">sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)), -(3*sqrt(69)/2 +</span>
<span class="go">27/2)**(1/3)/3 - 1/(3*sqrt(69)/2 + 27/2)**(1/3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cubics</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[CRootOf(x**3 - x + 1, 0),</span>
<span class="go"> CRootOf(x**3 - x + 1, 1),</span>
<span class="go"> CRootOf(x**3 - x + 1, 2)]</span>
</pre></div>
</div>
<p>If the expression is multivariate, no solution might be returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cubics</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</div></blockquote>
<p>Sometimes solutions will be obtained even when a flag is False because the
expression could be factored. In the following example, the equation can
be factored as the product of a linear and a quadratic factor so explicit
solutions (which did not require solving a cubic expression) are obtained:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">cubics</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[-1, -1 + sqrt(2), -sqrt(2) - 1]</span>
</pre></div>
</div>
<p>Because of SymPy’s use of the principle root (issue #8789), some solutions
to radical equations will be missed unless check=False:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[1/3]</span>
</pre></div>
</div>
<p>In the above example there is only a single solution to the equation. Other
expressions will yield spurious roots which must be checked manually;
roots which give a negative argument to odd-powered radicals will also need
special checking:</p>
<blockquote>
<div><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">real_root</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>  <span class="c1"># this gives 2 solutions but misses a 3rd</span>
<span class="go">[CRootOf(7*_p**5 - 7*_p**3 + 1, 1)**15,</span>
<span class="go">CRootOf(7*_p**5 - 7*_p**3 + 1, 2)**15]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">]</span>
<span class="go">[0.48, 0.e-110, 0.e-110, 0.052, 0.052]</span>
</pre></div>
</div>
<p>The first solution is negative so real_root must be used to see that
it satisfies the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">real_root</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">0.e-110</span>
</pre></div>
</div>
</div></blockquote>
<p>If the roots of the equation are not real then more care will be necessary
to find the roots, especially for higher order equations. Consider the
following expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>We will construct a known value for this expression at x = 3 by selecting
the 1-th root for each radical:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr1</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">expr1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>The solve function is unable to find any exact roots to this equation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span> <span class="n">eq1</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq1</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">([], [])</span>
</pre></div>
</div>
<p>The function unrad, however, can be used to get a form of the equation for
which numerical roots can be found:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solvers</span> <span class="kn">import</span> <span class="n">unrad</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">nroots</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span> <span class="o">=</span> <span class="n">unrad</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pvals</span> <span class="o">=</span> <span class="n">nroots</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inversion</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">inversion</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pvals</span><span class="p">]</span>
</pre></div>
</div>
<p>Although eq or eq1 could have been used to find xvals, the solution can
only be verified with expr1:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">-</span> <span class="n">v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">xi</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">chop</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xvals</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">]</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span> <span class="o">=</span> <span class="n">expr1</span> <span class="o">-</span> <span class="n">v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">xi</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">chop</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xvals</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">]</span>
<span class="go">[-3.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.solve_linear">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">solve_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#solve_linear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.solve_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple derived from f = lhs - rhs that is one of
the following:</p>
<blockquote>
<div><p>(0, 1) meaning that <code class="docutils literal notranslate"><span class="pre">f</span></code> is independent of the symbols in
<code class="docutils literal notranslate"><span class="pre">symbols</span></code> that aren’t in <code class="docutils literal notranslate"><span class="pre">exclude</span></code>, e.g:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solvers</span> <span class="kn">import</span> <span class="n">solve_linear</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span>  <span class="c1"># = y*(1 - 1) = 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(0, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(0, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="go">(0, 1)</span>
</pre></div>
</div>
<p>(0, 0) meaning that there is no solution to the equation
amongst the symbols given.</p>
<blockquote>
<div><p>(If the first element of the tuple is not zero then
the function is guaranteed to be dependent on a symbol
in <code class="docutils literal notranslate"><span class="pre">symbols</span></code>.)</p>
</div></blockquote>
<p>(symbol, solution) where symbol appears linearly in the
numerator of <code class="docutils literal notranslate"><span class="pre">f</span></code>, is in <code class="docutils literal notranslate"><span class="pre">symbols</span></code> (if given) and is
not in <code class="docutils literal notranslate"><span class="pre">exclude</span></code> (if given). No simplification is done
to <code class="docutils literal notranslate"><span class="pre">f</span></code> other than a <code class="docutils literal notranslate"><span class="pre">mul=True</span></code> expansion, so the
solution will correspond strictly to a unique solution.</p>
<p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> are the numerator and
denominator of <code class="docutils literal notranslate"><span class="pre">f</span></code> when the numerator was not linear
in any symbol of interest; <code class="docutils literal notranslate"><span class="pre">n</span></code> will never be a symbol
unless a solution for that symbol was found (in which case
the second element is the solution, not the denominator).</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..core.power</span> <span class="kn">import</span> <span class="n">Pow</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..polys.polytools</span> <span class="kn">import</span> <span class="n">cancel</span>
</pre></div>
</div>
<p>The variable <code class="docutils literal notranslate"><span class="pre">x</span></code> appears as a linear variable in each of the
following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(x, -y**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(x, y**(-2))</span>
</pre></div>
</div>
<p>When not linear in x or y then the numerator and denominator are returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(x**2 - 3*y**2, y**2)</span>
</pre></div>
</div>
<p>If the numerator of the expression is a symbol then (0, 0) is
returned if the solution for that symbol would have set any
denominator to 0:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
<span class="go">(x, -2*x + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
<p>But automatic rewriting may cause a symbol in the denominator to
appear in the numerator so a solution will be returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">**-</span><span class="mi">1</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(x, 0)</span>
</pre></div>
</div>
<p>Use an unevaluated expression to avoid this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is allowed to cancel in the following expression, then it
appears to be linear in <code class="docutils literal notranslate"><span class="pre">x</span></code>, but this sort of cancellation is not
done by <code class="docutils literal notranslate"><span class="pre">solve_linear</span></code> so the solution will always satisfy the
original expression without causing a division by zero error.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">cancel</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
<span class="go">(x, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(x**2*(-z**2 + 1), x)</span>
</pre></div>
</div>
<p>A list of symbols for which a solution is desired may be given:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>
<span class="go">(y, -x - z)</span>
</pre></div>
</div>
<p>A list of symbols to ignore may also be given:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="go">(y, -x - z)</span>
</pre></div>
</div>
<p>(A solution for <code class="docutils literal notranslate"><span class="pre">y</span></code> is obtained because it is the first variable
from the canonically sorted list of symbols that had a linear
solution.)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.solve_linear_system">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">solve_linear_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">symbols</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#solve_linear_system"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.solve_linear_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve system of N linear equations with M variables, which means
both under- and overdetermined systems are supported. The possible
number of solutions is zero, one or infinite. Respectively, this
procedure will return None or a dictionary with solutions. In the
case of underdetermined systems, all arbitrary parameters are skipped.
This may cause a situation in which an empty dictionary is returned.
In that case, all symbols can be assigned arbitrary values.</p>
<p>Input to this functions is a Nx(M+1) matrix, which means it has
to be in augmented form. If you prefer to enter N equations and M
unknowns then use <cite>solve(Neqs, *Msymbols)</cite> instead. Note: a local
copy of the matrix is made by this routine so the matrix that is
passed will not be modified.</p>
<p>The algorithm used here is fraction-free Gaussian elimination,
which results, after elimination, in an upper-triangular matrix.
Then solutions are found using back-substitution. This approach
is more efficient and compact than the Gauss-Jordan method.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">solve_linear_system</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<p>Solve the following system:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span> <span class="n">y</span> <span class="o">==</span>  <span class="mi">2</span>
<span class="o">-</span><span class="mi">2</span> <span class="n">x</span> <span class="o">+</span>   <span class="n">y</span> <span class="o">==</span> <span class="mi">14</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">((</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{x: -6, y: 2}</span>
</pre></div>
</div>
<p>A degenerate system returns an empty dictionary.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">((</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.solve_linear_system_LU">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">solve_linear_system_LU</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">syms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#solve_linear_system_LU"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.solve_linear_system_LU" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the augmented matrix system using LUsolve and returns a dictionary
in which solutions are keyed to the symbols of syms <em>as ordered</em>.</p>
<p>The matrix must be invertible.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solvers</span> <span class="kn">import</span> <span class="n">solve_linear_system_LU</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear_system_LU</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">{x: 1/2, y: 1/4, z: -1/2}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.matrices.LUsolve</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.solve_undetermined_coeffs">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">solve_undetermined_coeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">equ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#solve_undetermined_coeffs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.solve_undetermined_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve equation of a type p(x; a_1, …, a_k) == q(x) where both
p, q are univariate polynomials and f depends on k parameters.
The result of this functions is a dictionary with symbolic
values of those parameters with respect to coefficients in q.</p>
<p>This functions accepts both Equations class instances and ordinary
SymPy expressions. Specification of parameters and variable is
obligatory for efficiency and simplicity reason.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..solvers</span> <span class="kn">import</span> <span class="n">solve_undetermined_coeffs</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_undetermined_coeffs</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{a: 1/2, b: -1/2}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_undetermined_coeffs</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{a: 1/c, b: -1/c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solvers.unrad">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solvers.</span></span><span class="sig-name descname"><span class="pre">unrad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">syms</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solvers.html#unrad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solvers.unrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove radicals with symbolic arguments and return (eq, cov),
None or raise an error:</p>
<p>None is returned if there are no radicals to remove.</p>
<p>NotImplementedError is raised if there are radicals and they cannot be
removed or if the relationship between the original symbols and the
change of variable needed to rewrite the system as a polynomial cannot
be solved.</p>
<p>Otherwise the tuple, <code class="docutils literal notranslate"><span class="pre">(eq,</span> <span class="pre">cov)</span></code>, is returned where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>``eq``, ``cov``
    ``eq`` is an equation without radicals (in the symbol(s) of
    interest) whose solutions are a superset of the solutions to the
    original expression. ``eq`` might be re-written in terms of a new
    variable; the relationship to the original variables is given by
    ``cov`` which is a list containing ``v`` and ``v**p - b`` where
    ``p`` is the power needed to clear the radical and ``b`` is the
    radical now expressed as a polynomial in the symbols of interest.
    For example, for sqrt(2 - x) the tuple would be
    ``(c, c**2 - 2 + x)``. The solutions of ``eq`` will contain
    solutions to the original equation (if there are any).
</pre></div>
</div>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">syms</span></code></dt><dd><p>an iterable of symbols which, if provided, will limit the focus of
radical removal: only radicals with one or more of the symbols of
interest will be cleared. All free symbols are used if <code class="docutils literal notranslate"><span class="pre">syms</span></code> is not
set.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">flags</span></code> are used internally for communication during recursive calls.
Two options are also recognized:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>``take``, when defined, is interpreted as a single-argument function
that returns True if a given Pow should be handled.
</pre></div>
</div>
<p>Radicals can be removed from an expression if:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span>   <span class="nb">all</span> <span class="n">bases</span> <span class="n">of</span> <span class="n">the</span> <span class="n">radicals</span> <span class="n">are</span> <span class="n">the</span> <span class="n">same</span><span class="p">;</span> <span class="n">a</span> <span class="n">change</span> <span class="n">of</span> <span class="n">variables</span> <span class="ow">is</span>
    <span class="n">done</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span><span class="o">.</span>
<span class="o">*</span>   <span class="k">if</span> <span class="nb">all</span> <span class="n">radicals</span> <span class="n">appear</span> <span class="ow">in</span> <span class="n">one</span> <span class="n">term</span> <span class="n">of</span> <span class="n">the</span> <span class="n">expression</span>
<span class="o">*</span>   <span class="n">there</span> <span class="n">are</span> <span class="n">only</span> <span class="mi">4</span> <span class="n">terms</span> <span class="k">with</span> <span class="n">sqrt</span><span class="p">()</span> <span class="n">factors</span> <span class="ow">or</span> <span class="n">there</span> <span class="n">are</span> <span class="n">less</span> <span class="n">than</span>
    <span class="n">four</span> <span class="n">terms</span> <span class="n">having</span> <span class="n">sqrt</span><span class="p">()</span> <span class="n">factors</span>
<span class="o">*</span>   <span class="n">there</span> <span class="n">are</span> <span class="n">only</span> <span class="n">two</span> <span class="n">terms</span> <span class="k">with</span> <span class="n">radicals</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solvers</span> <span class="kn">import</span> <span class="n">unrad</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">real_roots</span><span class="p">,</span> <span class="n">solve</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">unrad</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">(x**5 - 64, [])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unrad</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">(x**3 - x**2 - 2*x - 1, [])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unrad</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(_p**3 + _p**2 - 2, [_p, _p**6 - x])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-modelparameters.sympy.solvers.solveset">
<span id="modelparameters-sympy-solvers-solveset-module"></span><h2>modelparameters.sympy.solvers.solveset module<a class="headerlink" href="#module-modelparameters.sympy.solvers.solveset" title="Permalink to this headline">¶</a></h2>
<p>This module contains functions to:</p>
<blockquote>
<div><ul class="simple">
<li><p>solve a single equation for a single variable, in any domain either real or complex.</p></li>
<li><p>solve a system of linear equations with N variables and M equations.</p></li>
<li><p>solve a system of Non Linear Equations with N variables and M equations</p></li>
</ul>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.domain_check">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">domain_check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#domain_check"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.domain_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns False if point p is infinite or any subexpression of f
is infinite or becomes so after replacing symbol with p. If none of
these conditions is met then True will be returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solveset</span> <span class="kn">import</span> <span class="n">domain_check</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The function relies on the assumption that the original form
of the equation has not been changed by automatic simplification.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># x/x is automatically simplified to 1</span>
<span class="go">True</span>
</pre></div>
</div>
<ul class="simple">
<li><p>To deal with automatic evaluations use evaluate=False:</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.invert_complex">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">invert_complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">S.Complexes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.invert_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the complex valued equation <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">y</span></code> to a set of equations
<code class="docutils literal notranslate"><span class="pre">{g(x)</span> <span class="pre">=</span> <span class="pre">h_1(y),</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_n(y)</span> <span class="pre">}</span></code> where <code class="docutils literal notranslate"><span class="pre">g(x)</span></code> is
a simpler function than <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>.  The return value is a tuple <code class="docutils literal notranslate"><span class="pre">(g(x),</span>
<span class="pre">set_h)</span></code>, where <code class="docutils literal notranslate"><span class="pre">g(x)</span></code> is a function of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">set_h</span></code> is
the set of function <code class="docutils literal notranslate"><span class="pre">{h_1(y),</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">h_n(y)}</span></code>.
Here, <code class="docutils literal notranslate"><span class="pre">y</span></code> is not necessarily a symbol.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">set_h</span></code> contains the functions, along with the information
about the domain in which they are valid, through set
operations. For instance, if <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">Abs(x)</span> <span class="pre">-</span> <span class="pre">n</span></code> is inverted
in the real domain, then <code class="docutils literal notranslate"><span class="pre">set_h</span></code> is not simply
<cite>{-n, n}</cite> as the nature of <cite>n</cite> is unknown; rather, it is:
<cite>Intersection([0, oo) {n}) U Intersection((-oo, 0], {-n})</cite></p>
<p>By default, the complex domain is used which means that inverting even
seemingly simple functions like <code class="docutils literal notranslate"><span class="pre">exp(x)</span></code> will give very different
results from those obtained in the real domain.
(In the case of <code class="docutils literal notranslate"><span class="pre">exp(x)</span></code>, the inversion via <code class="docutils literal notranslate"><span class="pre">log</span></code> is multi-valued
in the complex domain, having infinitely many branches.)</p>
<p>If you are working with real values only (or you are not sure which
function to use) you should probably set the domain to
<code class="docutils literal notranslate"><span class="pre">S.Reals</span></code> (or use <cite>invert_real</cite> which does that automatically).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solveset</span> <span class="kn">import</span> <span class="n">invert_complex</span><span class="p">,</span> <span class="n">invert_real</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
</pre></div>
</div>
<p>When does exp(x) == y?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invert_complex</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, ImageSet(Lambda(_n, I*(2*_n*pi + arg(y)) + log(Abs(y))), S.Integers))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, Intersection(S.Reals, {log(y)}))</span>
</pre></div>
</div>
<p>When does exp(x) == 1?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invert_complex</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, ImageSet(Lambda(_n, 2*_n*I*pi), S.Integers))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, {0})</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#modelparameters.sympy.solvers.solveset.invert_real" title="modelparameters.sympy.solvers.solveset.invert_real"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert_real</span></code></a>, <a class="reference internal" href="#modelparameters.sympy.solvers.solveset.invert_complex" title="modelparameters.sympy.solvers.solveset.invert_complex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert_complex</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.invert_real">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">invert_real</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">S.Reals</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#invert_real"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.invert_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverts a real-valued function. Same as _invert, but sets
the domain to <code class="docutils literal notranslate"><span class="pre">S.Reals</span></code> before inverting.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.linear_eq_to_matrix">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">linear_eq_to_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">equations</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#linear_eq_to_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.linear_eq_to_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a given System of Equations into Matrix form.
Here <cite>equations</cite> must be a linear system of equations in
<cite>symbols</cite>. The order of symbols in input <cite>symbols</cite> will
determine the order of coefficients in the returned
Matrix.</p>
<p>The Matrix form corresponds to the augmented matrix form.
For example:</p>
<div class="math notranslate nohighlight">
\[4x + 2y + 3z  = 1\]</div>
<div class="math notranslate nohighlight">
\[3x +  y +  z  = -6\]</div>
<div class="math notranslate nohighlight">
\[2x + 4y + 9z  = 2\]</div>
<p>This system would return <cite>A</cite> &amp; <cite>b</cite> as given below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="p">[</span> <span class="mi">4</span>  <span class="mi">2</span>  <span class="mi">3</span> <span class="p">]</span>          <span class="p">[</span> <span class="mi">1</span> <span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">3</span>  <span class="mi">1</span>  <span class="mi">1</span> <span class="p">]</span>   <span class="n">b</span>  <span class="o">=</span>   <span class="p">[</span><span class="o">-</span><span class="mi">6</span> <span class="p">]</span>
    <span class="p">[</span> <span class="mi">2</span>  <span class="mi">4</span>  <span class="mi">9</span> <span class="p">]</span>          <span class="p">[</span> <span class="mi">2</span> <span class="p">]</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">linear_eq_to_matrix</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y, z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">z</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[1, 2, 3],</span>
<span class="go">[3, 1, 1],</span>
<span class="go">[2, 4, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[ 1],</span>
<span class="go">[-6],</span>
<span class="go">[ 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[1,  0, 1],</span>
<span class="go">[0,  1, 1],</span>
<span class="go">[1, -1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[1],</span>
<span class="go">[0],</span>
<span class="go">[0]])</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Symbolic coefficients are also supported</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a, b, c, d, e, f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">f</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[a, b],</span>
<span class="go">[d, e]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span>
<span class="go">Matrix([</span>
<span class="go">[c],</span>
<span class="go">[f]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.linsolve">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">linsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#linsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.linsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve system of N linear equations with M variables, which
means both under - and overdetermined systems are supported.
The possible number of solutions is zero, one or infinite.
Zero solutions throws a ValueError, where as infinite
solutions are represented parametrically in terms of given
symbols. For unique solution a FiniteSet of ordered tuple
is returned.</p>
<p>All Standard input formats are supported:
For the given set of Equations, the respective input types
are given below:</p>
<div class="math notranslate nohighlight">
\[3x + 2y -   z = 1\]</div>
<div class="math notranslate nohighlight">
\[2x - 2y + 4z = -2\]</div>
<div class="math notranslate nohighlight">
\[2x -   y + 2z = 0\]</div>
<ul class="simple">
<li><p>Augmented Matrix Form, <cite>system</cite> given below:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>         <span class="p">[</span><span class="mi">3</span>   <span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>  <span class="mi">1</span><span class="p">]</span>
<span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span>  <span class="o">-</span><span class="mi">2</span>   <span class="mi">4</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
         <span class="p">[</span><span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>   <span class="mi">2</span>  <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p>List Of Equations Form</p></li>
</ul>
<p><cite>system  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z]</cite></p>
<ul class="simple">
<li><p>Input A &amp; b Matrix Form (from Ax = b) are given as below:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="p">[</span><span class="mi">3</span>   <span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span> <span class="p">]</span>         <span class="p">[</span>  <span class="mi">1</span> <span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span>  <span class="o">-</span><span class="mi">2</span>   <span class="mi">4</span> <span class="p">]</span>    <span class="n">b</span> <span class="o">=</span>  <span class="p">[</span> <span class="o">-</span><span class="mi">2</span> <span class="p">]</span>
    <span class="p">[</span><span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>   <span class="mi">2</span> <span class="p">]</span>         <span class="p">[</span>  <span class="mi">0</span> <span class="p">]</span>
</pre></div>
</div>
<p><cite>system = (A, b)</cite></p>
<p>Symbols to solve for should be given as input in all the
cases either in an iterable or as comma separated arguments.
This is done to maintain consistency in returning solutions
in the form of variable input by the user.</p>
<p>The algorithm used here is Gauss-Jordan elimination, which
results, after elimination, in an row echelon form matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>A FiniteSet of ordered tuple of values of <cite>symbols</cite> for which</p></li>
<li><p>the <cite>system</cite> has solution.</p></li>
<li><p><em>Please note that general FiniteSet is unordered, the solution</em></p></li>
<li><p><em>returned here is not simply a FiniteSet of solutions, rather</em></p></li>
<li><p><em>it is a FiniteSet of ordered tuple, i.e. the first &amp; only</em></p></li>
<li><p><em>argument to FiniteSet is a tuple of solutions, which is ordered,</em></p></li>
<li><p><em>&amp; hence the returned solution is ordered.</em></p></li>
<li><p><em>Also note that solution could also have been returned as an</em></p></li>
<li><p>ordered tuple, FiniteSet is just a wrapper <cite>{}</cite> around</p></li>
<li><p><em>the tuple. It has no other significance except for</em></p></li>
<li><p><em>the fact it is just used to maintain a consistent output</em></p></li>
<li><p><em>format throughout the solveset.</em></p></li>
<li><p><em>Returns EmptySet(), if the linear system is inconsistent.</em></p></li>
</ul>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.10)"><strong>ValueError</strong></a> – The input is not valid.
    The symbols are not given.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">linsolve</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x, y, z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[1, 2,  3],</span>
<span class="go">[4, 5,  6],</span>
<span class="go">[7, 8, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[3],</span>
<span class="go">[6],</span>
<span class="go">[9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">{(-1, 2, 0)}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Parametric Solution: In case the system is under determined, the function
will return parametric solution in terms of the given symbols.
Free symbols in the system are returned as it is. For e.g. in the system
below, <cite>z</cite> is returned as the solution for variable z, which means z is a
free symbol, i.e. it can take arbitrary values.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">{(z - 1, -2*z + 2, z)}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>List of Equations as input</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Eqns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">Eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">{(1, -2, -2)}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Augmented Matrix as input</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span>
<span class="go">Matrix([</span>
<span class="go">[2, 1,  3, 1],</span>
<span class="go">[2, 6,  8, 3],</span>
<span class="go">[6, 8, 18, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">{(3/10, 2/5, 0)}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Solve for symbolic coefficients</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a, b, c, d, e, f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">f</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d))}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>A degenerate system returns solution as set of given
symbols.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{(x, y)}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>For an empty system linsolve returns empty set</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">([</span> <span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">EmptySet()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.nonlinsolve">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">nonlinsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">symbols</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#nonlinsolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.nonlinsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve system of N non linear equations with M variables, which means both
under and overdetermined systems are supported. Positive dimensional
system is also supported (A system with infinitely many solutions is said
to be positive-dimensional). In Positive dimensional system solution will
be dependent on at least one symbol. Returns both real solution
and complex solution(If system have). The possible number of solutions
is zero, one or infinite.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<em>list of equations</em>) – The target system of equations</p></li>
<li><p><strong>symbols</strong> (<em>list of Symbols</em>) – symbols should be given as a sequence eg. list</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A FiniteSet of ordered tuple of values of <cite>symbols</cite> for which the <cite>system</cite></p></li>
<li><p><em>has solution. Order of values in the tuple is same as symbols present in</em></p></li>
<li><p>the parameter <cite>symbols</cite>.</p></li>
<li><p><em>Please note that general FiniteSet is unordered, the solution returned</em></p></li>
<li><p><em>here is not simply a FiniteSet of solutions, rather it is a FiniteSet of</em></p></li>
<li><p><em>ordered tuple, i.e. the first &amp; only argument to FiniteSet is a tuple of</em></p></li>
<li><p><em>solutions, which is ordered, &amp; hence the returned solution is ordered.</em></p></li>
<li><p><em>Also note that solution could also have been returned as an ordered tuple,</em></p></li>
<li><p>FiniteSet is just a wrapper <cite>{}</cite> around the tuple. It has no other</p></li>
<li><p><em>significance except for the fact it is just used to maintain a consistent</em></p></li>
<li><p><em>output format throughout the solveset.</em></p></li>
<li><p><em>For the given set of Equations, the respective input types</em></p></li>
<li><p><em>are given below</em></p></li>
<li><p><em>.. math:: x*y - 1 = 0</em></p></li>
<li><p><em>.. math:: 4*x**2 + y**2 - 5 = 0</em></p></li>
<li><p><cite>system  = [x*y - 1, 4*x**2 + y**2 - 5]</cite></p></li>
<li><p><cite>symbols = [x, y]</cite></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.10)"><strong>ValueError</strong></a> – The input is not valid.
    The symbols are not given.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.10)"><strong>AttributeError</strong></a> – The input symbols are not <cite>Symbol</cite> type.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..core.symbol</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solveset</span> <span class="kn">import</span> <span class="n">nonlinsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y, z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">{(-1, -1), (-1/2, -2), (1/2, 2), (1, 1)}</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p>Positive dimensional system and complements:</p></li>
</ol>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..polys.polytools</span> <span class="kn">import</span> <span class="n">is_zero_dimensional</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a, b, c, d&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq1</span> <span class="o">=</span>  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq2</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">d</span><span class="o">*</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq3</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">d</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq4</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">,</span> <span class="n">eq3</span><span class="p">,</span> <span class="n">eq4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_zero_dimensional</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">nonlinsolve</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">  -1       1               1      -1</span>
<span class="go">{(---, -d, -, {d} \ {0}), (-, -d, ---, {d} \ {0})}</span>
<span class="go">   d       d               d       d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">{(-y + 2, y)}</span>
</pre></div>
</div>
<p>2. If some of the equations are non polynomial equation then <cite>nonlinsolve</cite>
will call <cite>substitution</cite> function and returns real and complex solutions,
if present.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">{(log(sin(2)), 2), (ImageSet(Lambda(_n, I*(2*_n*pi + pi) +</span>
<span class="go">    log(sin(2))), S.Integers), -2), (ImageSet(Lambda(_n, 2*_n*I*pi +</span>
<span class="go">    Mod(log(sin(2)), 2*I*pi)), S.Integers), 2)}</span>
</pre></div>
</div>
<p>3. If system is Non linear polynomial zero dimensional then it returns
both solution (real and complex solutions, if present using
<cite>solve_poly_system</cite>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">{(-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I)}</span>
</pre></div>
</div>
<p>4. <cite>nonlinsolve</cite> can solve some linear(zero or positive dimensional)
system (because it is using <cite>groebner</cite> function to get the
groebner basis and then <cite>substitution</cite> function basis as the new <cite>system</cite>).
But it is not recommended to solve linear system using <cite>nonlinsolve</cite>,
because <cite>linsolve</cite> is better for all kind of linear system.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span><span class="n">z</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">9</span> <span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">{(3*z - 5, -z + 4, z)}</span>
</pre></div>
</div>
<p>5. System having polynomial equations and only real solution is present
(will be solved using <cite>solve_poly_system</cite>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">((</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">{(191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">{(1, 2), (1 + sqrt(5), -sqrt(5) + 2), (-sqrt(5) + 1, 2 + sqrt(5))}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
<span class="go">{(2, 1), (2 + sqrt(5), -sqrt(5) + 1), (-sqrt(5) + 2, 1 + sqrt(5))}</span>
</pre></div>
</div>
<p>6. It is better to use symbols instead of Trigonometric Function or
Function (e.g. replace <cite>sin(x)</cite> with symbol, replace <cite>f(x)</cite> with symbol
and so on. Get soln from <cite>nonlinsolve</cite> and then using <cite>solveset</cite> get
the value of <cite>x</cite>)</p>
<p>1. A positive dimensional system solver : nonlinsolve can return
solution for positive dimensional system. It finds the
Groebner Basis of the positive dimensional system(calling it as
basis) then we can start solving equation(having least number of
variable first in the basis) using solveset and substituting that
solved solutions into other equation(of basis) to get solution in
terms of minimum variables. Here the important thing is how we
are substituting the known values and in which equations.</p>
<p>2. Real and Complex both solutions : nonlinsolve returns both real
and complex solution. If all the equations in the system are polynomial
then using <cite>solve_poly_system</cite> both real and complex solution is returned.
If all the equations in the system are not polynomial equation then goes to
<cite>substitution</cite> method with this polynomial and non polynomial equation(s),
to solve for unsolved variables. Here to solve for particular variable
solveset_real and solveset_complex is used. For both real and complex
solution function <cite>_solve_using_know_values</cite> is used inside <cite>substitution</cite>
function.(<cite>substitution</cite> function will be called when there is any non
polynomial equation(s) is present). When solution is valid then add its
general solution in the final result.</p>
<p>3. Complement and Intersection will be added if any : nonlinsolve maintains
dict for complements and Intersections. If solveset find complements or/and
Intersection with any Interval or set during the execution of
<cite>substitution</cite> function ,then complement or/and Intersection for that
variable is added before returning final solution.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.solve_decomposition">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">solve_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#solve_decomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.solve_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to solve equations via the principle of “Decomposition
and Rewriting”.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solveset</span> <span class="kn">import</span> <span class="n">solve_decomposition</span> <span class="k">as</span> <span class="n">sd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sd</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">{0, log(2)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sd</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">          3*pi</span>
<span class="go">{2*n*pi + ---- | n in S.Integers}</span>
<span class="go">           2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sd</span><span class="p">(</span><span class="n">f3</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{2*n*pi - 2 | n in S.Integers} U {pi*(2*n + 1) - 2 | n in S.Integers}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.solveset">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">solveset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">S.Complexes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#solveset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.solveset" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a given inequality or equation with set as output</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<a class="reference internal" href="modelparameters.sympy.core.html#modelparameters.sympy.core.expr.Expr" title="modelparameters.sympy.core.expr.Expr"><em>Expr</em></a><em> or </em><em>a relational.</em>) – The target equation or inequality</p></li>
<li><p><strong>symbol</strong> (<a class="reference internal" href="modelparameters.sympy.core.html#modelparameters.sympy.core.symbol.Symbol" title="modelparameters.sympy.core.symbol.Symbol"><em>Symbol</em></a>) – The variable for which the equation is solved</p></li>
<li><p><strong>domain</strong> (<a class="reference internal" href="modelparameters.sympy.sets.html#modelparameters.sympy.sets.sets.Set" title="modelparameters.sympy.sets.sets.Set"><em>Set</em></a>) – The domain over which the equation is solved</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Set</em> – A set of values for <cite>symbol</cite> for which <cite>f</cite> is True or is equal to
zero. An <cite>EmptySet</cite> is returned if <cite>f</cite> is False or nonzero.
A <cite>ConditionSet</cite> is returned as unsolved object if algorithms
to evaluate complete solution are not yet implemented.</p></li>
<li><p><cite>solveset</cite> claims to be complete in the solution set that it returns.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.10)"><strong>NotImplementedError</strong></a> – The algorithms to solve inequalities in complex domain  are
    not yet implemented.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.10)"><strong>ValueError</strong></a> – The input is not valid.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.10)"><strong>RuntimeError</strong></a> – It is a bug, please report to the github issue tracker.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Python interprets 0 and 1 as False and True, respectively, but
in this function they refer to solutions of an expression. So 0 and 1
return the Domain and EmptySet, respectively, while True and False
return the opposite (as they are assumed to be solutions of relational
expressions).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#modelparameters.sympy.solvers.solveset.solveset_real" title="modelparameters.sympy.solvers.solveset.solveset_real"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solveset_real</span></code></a></dt><dd><p>solver for real domain</p>
</dd>
<dt><a class="reference internal" href="#modelparameters.sympy.solvers.solveset.solveset_complex" title="modelparameters.sympy.solvers.solveset.solveset_complex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solveset_complex</span></code></a></dt><dd><p>solver for complex domain</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solveset</span> <span class="kn">import</span> <span class="n">solveset</span><span class="p">,</span> <span class="n">solveset_real</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The default domain is complex. Not specifying a domain will lead
to the solving of the equation in the complex domain (and this
is not affected by the assumptions on the symbol):</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{2*n*I*pi | n in S.Integers}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{2*n*I*pi | n in S.Integers}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>If you want to use <cite>solveset</cite> to solve the equation in the
real domain, provide a real domain. (Using <cite>solveset_real</cite>
does this automatically.)</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">{0}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{0}</span>
</pre></div>
</div>
<p>The solution is mostly unaffected by assumptions on the symbol,
but there may be some slight difference:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">({2*n*pi | n in S.Integers} \ {0}) U ({2*n*pi + pi | n in S.Integers} \ {0})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{2*n*pi | n in S.Integers} U {2*n*pi + pi | n in S.Integers}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Inequalities can be solved over the real domain only. Use of a complex
domain leads to a NotImplementedError.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">Interval.open(0, oo)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.solveset_complex">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">solveset_complex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#solveset_complex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.solveset_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.solveset_real">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">solveset_real</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#solveset_real"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.solveset_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.solvify">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">solvify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#solvify"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.solvify" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an equation using solveset and returns the solution in accordance
with the <cite>solve</cite> output API.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>We classify the output based on the type of solution returned by <cite>solveset</cite>.</p></li>
<li><p><em>Solution    |    Output</em></p></li>
<li><p><em>—————————————-</em></p></li>
<li><p><em>FiniteSet   | list</em></p></li>
<li><p>ImageSet,   | list (if <cite>f</cite> is periodic)</p></li>
<li><p><em>Union       |</em></p></li>
<li><p><em>EmptySet    | empty list</em></p></li>
<li><p><em>Others      | None</em></p></li>
</ul>
</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#NotImplementedError" title="(in Python v3.10)"><strong>NotImplementedError</strong></a> – A ConditionSet is the input.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solveset</span> <span class="kn">import</span> <span class="n">solvify</span><span class="p">,</span> <span class="n">solveset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solvify</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">[-3, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solvify</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">[pi/2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solvify</span><span class="p">(</span><span class="n">tan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">[0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solvify</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Complexes</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solvify</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">[0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modelparameters.sympy.solvers.solveset.substitution">
<span class="sig-prename descclassname"><span class="pre">modelparameters.sympy.solvers.solveset.</span></span><span class="sig-name descname"><span class="pre">substitution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[{}]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known_symbols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_symbols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modelparameters/sympy/solvers/solveset.html#substitution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modelparameters.sympy.solvers.solveset.substitution" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Solves the <cite>system</cite> using substitution method. It is used in
<cite>nonlinsolve</cite>. This will be called from <cite>nonlinsolve</cite> when any
equation(s) is non polynomial equation.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>system</strong> (<em>list of equations</em>) – The target system of equations</p></li>
<li><p><strong>symbols</strong> (<em>list of symbols to be solved.</em>) – The variable(s) for which the system is solved</p></li>
<li><p><strong>known_symbols</strong> (<em>list of solved symbols</em>) – Values are known for these variable(s)</p></li>
<li><p><strong>result</strong> (<em>An empty list</em><em> or </em><em>list of dict</em>) – If No symbol values is known then empty list otherwise
symbol as keys and corresponding value in dict.</p></li>
<li><p><strong>exclude</strong> (<em>Set of expression.</em>) – Mostly denominator expression(s) of the equations of the system.
Final solution should not satisfy these expressions.</p></li>
<li><p><strong>all_symbols</strong> (<em>known_symbols + symbols</em><em>(</em><em>unsolved</em><em>)</em><em></em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A FiniteSet of ordered tuple of values of <cite>all_symbols</cite> for which the</p></li>
<li><p><cite>system</cite> has solution. Order of values in the tuple is same as symbols</p></li>
<li><p>present in the parameter <cite>all_symbols</cite>. If parameter <cite>all_symbols</cite> is None</p></li>
<li><p>then same as symbols present in the parameter <cite>symbols</cite>.</p></li>
<li><p><em>Please note that general FiniteSet is unordered, the solution returned</em></p></li>
<li><p><em>here is not simply a FiniteSet of solutions, rather it is a FiniteSet of</em></p></li>
<li><p><em>ordered tuple, i.e. the first &amp; only argument to FiniteSet is a tuple of</em></p></li>
<li><p><em>solutions, which is ordered, &amp; hence the returned solution is ordered.</em></p></li>
<li><p><em>Also note that solution could also have been returned as an ordered tuple,</em></p></li>
<li><p>FiniteSet is just a wrapper <cite>{}</cite> around the tuple. It has no other</p></li>
<li><p><em>significance except for the fact it is just used to maintain a consistent</em></p></li>
<li><p><em>output format throughout the solveset.</em></p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.10)"><strong>ValueError</strong></a> – The input is not valid.
    The symbols are not given.</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.10)"><strong>AttributeError</strong></a> – The input symbols are not <cite>Symbol</cite> type.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..core.symbol</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">.solveset</span> <span class="kn">import</span> <span class="n">substitution</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">substitution</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="p">[{</span><span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">}],</span> <span class="p">[</span><span class="n">y</span><span class="p">],</span> <span class="nb">set</span><span class="p">([]),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">{(-1, 1)}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>when you want soln should not satisfy eq <cite>x + 1 = 0</cite></p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">substitution</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="p">[{</span><span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">}],</span> <span class="p">[</span><span class="n">y</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
<span class="go">EmptySet()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">substitution</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="p">[{</span><span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">}],</span> <span class="p">[</span><span class="n">y</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
<span class="go">{(1, -1)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">substitution</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">{(-3, 4), (2, -1)}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Returns both real and complex solution</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y, z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">substitution</span><span class="p">([</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">{(log(sin(2)), 2), (ImageSet(Lambda(_n, I*(2*_n*pi + pi) +</span>
<span class="go">    log(sin(2))), S.Integers), -2), (ImageSet(Lambda(_n, 2*_n*I*pi +</span>
<span class="go">    Mod(log(sin(2)), 2*I*pi)), S.Integers), 2)}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="o">-</span><span class="mi">3</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">y</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">substitution</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">{(-log(3), -sqrt(-exp(2*x) - sin(log(3)))),</span>
<span class="go">(-log(3), sqrt(-exp(2*x) - sin(log(3)))),</span>
<span class="go">(ImageSet(Lambda(_n, 2*_n*I*pi + Mod(-log(3), 2*I*pi)), S.Integers),</span>
<span class="go">ImageSet(Lambda(_n, -sqrt(-exp(2*x) + sin(2*_n*I*pi +</span>
<span class="go">Mod(-log(3), 2*I*pi)))), S.Integers)),</span>
<span class="go">(ImageSet(Lambda(_n, 2*_n*I*pi + Mod(-log(3), 2*I*pi)), S.Integers),</span>
<span class="go">ImageSet(Lambda(_n, sqrt(-exp(2*x) + sin(2*_n*I*pi +</span>
<span class="go">    Mod(-log(3), 2*I*pi)))), S.Integers))}</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-modelparameters.sympy.solvers">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-modelparameters.sympy.solvers" title="Permalink to this headline">¶</a></h2>
<p>A module for solving all kinds of equations.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..solvers</span> <span class="kn">import</span> <span class="n">solve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">..abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">5</span><span class="o">+</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="go">[-1]</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">modelparameters.sympy.solvers package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.bivariate">modelparameters.sympy.solvers.bivariate module</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.decompogen">modelparameters.sympy.solvers.decompogen module</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.deutils">modelparameters.sympy.solvers.deutils module</a><ul>
<li><a class="reference internal" href="#contains">Contains</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.diophantine">modelparameters.sympy.solvers.diophantine module</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.inequalities">modelparameters.sympy.solvers.inequalities module</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.ode">modelparameters.sympy.solvers.ode module</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.pde">modelparameters.sympy.solvers.pde module</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.polysys">modelparameters.sympy.solvers.polysys module</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.recurr">modelparameters.sympy.solvers.recurr module</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.solvers">modelparameters.sympy.solvers.solvers module</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers.solveset">modelparameters.sympy.solvers.solveset module</a></li>
<li><a class="reference internal" href="#module-modelparameters.sympy.solvers">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modelparameters.sympy.simplify.html"
                        title="previous chapter">modelparameters.sympy.simplify package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="modelparameters.sympy.stats.html"
                        title="next chapter">modelparameters.sympy.stats package</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/modelparameters.sympy.solvers.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="modelparameters.sympy.stats.html" title="modelparameters.sympy.stats package"
             >next</a> |</li>
        <li class="right" >
          <a href="modelparameters.sympy.simplify.html" title="modelparameters.sympy.simplify package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">modelparameters 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modelparameters.html" >modelparameters package</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modelparameters.sympy.html" >modelparameters.sympy package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modelparameters.sympy.solvers package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Johan Hake, Henrik Finsberg.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>